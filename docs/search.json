[
  {
    "objectID": "vidigi_docs/vidigi_vs_bupar.html",
    "href": "vidigi_docs/vidigi_vs_bupar.html",
    "title": "Vidigi vs BupaR",
    "section": "",
    "text": "Tip\n\n\n\nSwitch this page to the light mode using the toggle at the top of the navigation sidebar on the left of this page.\nI have not yet worked out how to change the colour of the text on the resulting process maps, so using light mode is currently the only way to see it.\nThe title of this section is perhaps misleading! As the author of the package, I think the visuals produced by the two packages occupy slightly different niches, and the use of both can benefit your project.\nAs an additional bonus, the process of creating the logs you require for a vidigi project give you the perfect dataset for your bupaR visuals too!\nbupaR outputs could form part of a verification and validation strategy. They can also perform part of your communications strategy, helping to provide a talking point for meetings with stakeholders in much the same way as a screenshot of your Simul8 or Anylogic model would. In the absence of a graphical interface for building a model, the bupar outputs can help you - and your stakeholders - to ensure that linkages between different model steps are sensible and appropriate.\nWe will begin in Python, working to add a couple of columns to our vidigi event log to prepare it for use in bupaR.\nNow, it’s time to move to R (as bupaR and the bupaverse is only implemented in R).\npm4py exists as a process analytics package for Python, but the visuals of bupaR are of a high quality.",
    "crumbs": [
      "Other",
      "Vidigi vs BupaR"
    ]
  },
  {
    "objectID": "vidigi_docs/vidigi_vs_bupar.html#creating-outputs",
    "href": "vidigi_docs/vidigi_vs_bupar.html#creating-outputs",
    "title": "Vidigi vs BupaR",
    "section": "Creating outputs",
    "text": "Creating outputs\n\nProcess Maps\n\nAbsolute frequencies\n\nactivity_log %&gt;%\n    process_map(frequency(\"absolute\"))\n\n\n\n\n\n\nactivity_log %&gt;%\n    process_map(frequency(\"absolute-case\"))\n\n\n\n\n\n\n\nRelative frequencies\n\nactivity_log %&gt;%\n    process_map(frequency(\"relative\"))\n\n\n\n\n\n\nactivity_log %&gt;%\n    process_map(frequency(\"relative-case\"),\n              render_options = list(edge_label_color = \"white\"))\n\n\n\n\n\n\nactivity_log %&gt;%\n    process_map(frequency(\"relative-consequent\"),\n              render_options = list(edge_label_color = \"white\"))\n\n\n\n\n\n\n\n\nPerformance Maps\n\nMean Waits\n\nactivity_log %&gt;%\n    process_map(performance())\n\n\n\n\n\n\n\nMax Waits\n\nactivity_log %&gt;%\n    process_map(performance(FUN = max))\n\nWarning: There was 1 warning in `summarize()`.\nℹ In argument: `label = do.call(...)`.\nℹ In group 9: `ACTIVITY_CLASSIFIER_ = NA` and `from_id = NA`.\nCaused by warning in `type()`:\n! no non-missing arguments to max; returning -Inf\n\n\nWarning: There were 2 warnings in `summarize()`.\nThe first warning was:\nℹ In argument: `value = do.call(...)`.\nℹ In group 1: `ACTIVITY_CLASSIFIER_ = \"ARTIFICIAL_END\"`, `next_act = NA`,\n  `from_id = 1`, `to_id = NA`.\nCaused by warning in `type()`:\n! no non-missing arguments to max; returning -Inf\nℹ Run `dplyr::last_dplyr_warnings()` to see the 1 remaining warning.\n\n\n\n\n\n\n\n\n90th percentile\n\np90 &lt;- function(x, ...) {\n    quantile(x, probs = 0.9, ...)\n}\n\nactivity_log %&gt;%\n    process_map(performance(FUN = p90))\n\n\n\n\n\n\n\n\nAnalytics\nTake a look at this page in the bupaR docs details of each of these plots.\n\nIdle Time\n\nactivity_log %&gt;%\n    idle_time(\"resource\", units = \"mins\")\n\n# A tibble: 20 × 2\n   resource_id_full       idle_time     \n   &lt;chr&gt;                  &lt;drtn&gt;        \n 1 MINORS_treatment_1     2101.6612 mins\n 2 MINORS_treatment_2     2065.5869 mins\n 3 MINORS_treatment_3     2043.3483 mins\n 4 MINORS_treatment_4     1945.5681 mins\n 5 TRAUMA_treatment_1     1415.3914 mins\n 6 TRAUMA_treatment_2     1275.9829 mins\n 7 TRAUMA_treatment_3     1208.0795 mins\n 8 TRAUMA_treatment_5     1098.2404 mins\n 9 triage_2               1043.9654 mins\n10 triage_1                999.9198 mins\n11 TRAUMA_treatment_4      959.1452 mins\n12 MINORS_registration_2   951.0949 mins\n13 MINORS_registration_1   943.0261 mins\n14 TRAUMA_stabilisation_1  881.6663 mins\n15 TRAUMA_stabilisation_2  714.7071 mins\n16 TRAUMA_stabilisation_3  691.9842 mins\n17 TRAUMA_stabilisation_4  564.1900 mins\n18 MINORS_examination_2    469.1167 mins\n19 MINORS_examination_1    463.9669 mins\n20 MINORS_examination_3    441.1148 mins\n\n\n\nactivity_log %&gt;%\n    idle_time(\"resource\", units = \"mins\") %&gt;%\n    plot()\n\n\n\n\n\n\n\n\n\n\nProcessing Time\n\nactivity_log %&gt;%\n    processing_time(\"log\", units = \"mins\") %&gt;%\n    plot()\n\n\n\n\n\n\n\n\n\nactivity_log %&gt;%\n    processing_time(\"case\", units = \"mins\") %&gt;%\n    plot()\n\n\n\n\n\n\n\n\n\nactivity_log %&gt;%\n    processing_time(\"activity\", units = \"mins\") %&gt;%\n    plot()\n\n\n\n\n\n\n\n\n\nactivity_log %&gt;%\n    processing_time(\"resource-activity\", units = \"mins\") %&gt;%\n    plot()\n\n\n\n\n\n\n\n\n\n\nThroughput time\n\nactivity_log %&gt;%\n    throughput_time(\"log\", units = \"mins\") %&gt;%\n    plot()\n\n\n\n\n\n\n\n\n\n\nActivity Presence\n\nactivity_log %&gt;%\n    activity_presence() %&gt;%\n    plot()\n\n\n\n\n\n\n\n\n\n\n\nResource visualisations\n\nHandover-of-work network\n\nactivity_log %&gt;%\n    resource_map()\n\n\n\n\n\n\n\nResource precedence matrix\n\nactivity_log %&gt;%\n    resource_matrix() %&gt;%\n    plot()\n\n\n\n\n\n\n\n\n\n\n\nProcess matrix\n\nactivity_log %&gt;%\n    process_matrix(frequency(\"absolute\")) %&gt;%\n    plot()\n\n\n\n\n\n\n\n\n\n\nTrace Explorer\nThis plot helps us to unerstand how often different combinations of activities occur, and whether there are any unexpected paths in our data.\n\nactivity_log %&gt;%\n    trace_explorer(n_traces = 10)\n\nWarning: Fewer traces (6) found than specified `n_traces` (10).\n\n\n\n\n\n\n\n\n\n\n\nAnimated process map\n\nactivity_log %&gt;%\n    animate_process()\n\n\n\n\n\nLet’s compare directly with our vidigi output.\n\n\n\n\n\n\nTip\n\n\n\nThe key difference between what is produced via bupaverse’s animate_process and what can be created via vidigi is the ability of vidigi to more clearly show the scale of queues, and the number of resources available at any given point.\nVidigi can also more clearly highlight the impact of priority on resources through the use of distinct icons, though this is not demonstrated in this example.\n\n\n\n\n\n\n\n\nClick here to expand vidigi animation generation code\n\n\n\n\n\n\nfrom examples.example_2_branching_multistep.ex_2_model_classes import Trial, g\nfrom vidigi.animation import animate_activity_log\nimport pandas as pd\nimport plotly.io as pio\n#pio.renderers.default = \"notebook\"\npio.renderers.default = \"iframe\"\n\ng.sim_duration = 3000\ng.number_of_runs = 3\n\nmy_trial = Trial()\n\nmy_trial.run_trial()\n\nevent_position_df = pd.DataFrame([\n                # {'event': 'arrival', 'x':  10, 'y': 250, 'label': \"Arrival\" },\n\n                # Triage - minor and trauma\n                {'event': 'triage_wait_begins',\n                 'x':  160, 'y': 375, 'label': \"Waiting for&lt;br&gt;Triage\"  },\n                {'event': 'triage_begins',\n                 'x':  160, 'y': 315, 'resource':'n_triage', 'label': \"Being Triaged\" },\n\n                # Minors (non-trauma) pathway\n                {'event': 'MINORS_registration_wait_begins',\n                 'x':  300, 'y': 145, 'label': \"Waiting for&lt;br&gt;Registration\"  },\n                {'event': 'MINORS_registration_begins',\n                 'x':  300, 'y': 85, 'resource':'n_reg', 'label':'Being&lt;br&gt;Registered'  },\n\n                {'event': 'MINORS_examination_wait_begins',\n                 'x':  465, 'y': 145, 'label': \"Waiting for&lt;br&gt;Examination\"  },\n                {'event': 'MINORS_examination_begins',\n                 'x':  465, 'y': 85, 'resource':'n_exam', 'label': \"Being&lt;br&gt;Examined\" },\n\n                {'event': 'MINORS_treatment_wait_begins',\n                 'x':  630, 'y': 145, 'label': \"Waiting for&lt;br&gt;Treatment\"  },\n                {'event': 'MINORS_treatment_begins',\n                 'x':  630, 'y': 85, 'resource':'n_cubicles_non_trauma_treat', 'label': \"Being&lt;br&gt;Treated\" },\n\n                # Trauma pathway\n                {'event': 'TRAUMA_stabilisation_wait_begins',\n                 'x': 300, 'y': 560, 'label': \"Waiting for&lt;br&gt;Stabilisation\" },\n                {'event': 'TRAUMA_stabilisation_begins',\n                 'x': 300, 'y': 490, 'resource':'n_trauma', 'label': \"Being&lt;br&gt;Stabilised\" },\n\n                {'event': 'TRAUMA_treatment_wait_begins',\n                 'x': 630, 'y': 560, 'label': \"Waiting for&lt;br&gt;Treatment\" },\n                {'event': 'TRAUMA_treatment_begins',\n                 'x': 630, 'y': 490, 'resource':'n_cubicles_trauma_treat', 'label': \"Being&lt;br&gt;Treated\" },\n\n                 {'event': 'exit',\n                 'x':  670, 'y': 330, 'label': \"Exit\"}\n            ])\n\n\nanimate_activity_log(\n        event_log=my_trial.all_event_logs[my_trial.all_event_logs['run']==0],\n        event_position_df=event_position_df,\n        scenario=g(),\n        debug_mode=False,\n        setup_mode=False,\n        every_x_time_units=5,\n        include_play_button=True,\n        gap_between_entities=10,\n        gap_between_rows=20,\n        plotly_height=900,\n        plotly_width=1600,\n        override_x_max=700,\n        override_y_max=675,\n        icon_and_text_size=20,\n        wrap_queues_at=10,\n        step_snapshot_max=50,\n        limit_duration=3000,\n        time_display_units=\"dhm\",\n        display_stage_labels=False,\n        add_background_image=\"https://raw.githubusercontent.com/Bergam0t/vidigi/refs/heads/main/examples/example_2_branching_multistep/Full%20Model%20Background%20Image%20-%20Horizontal%20Layout.drawio.png\",\n    )\n\n\n\n\n\n\n\n\n\n\n\nOther chart types\n\nDotted chart\nWe can see the impact of the pattern of daily arrivals across the course of the model, with the waits clearing out overnight when arrivals slow down.\n\nactivity_log %&gt;%\n    dotted_chart(x = \"absolute\")\n\n\n\n\n\n\n\n\n\nactivity_log %&gt;%\n    dotted_chart(x = \"relative\", sort=\"start\")\n\n\n\n\n\n\n\n\n\n\nBreaking down dotted charts by route\n\nMinors\n\nactivity_log %&gt;%\n    filter(event_name %in% c('MINORS_examination', 'MINORS_registration', 'MINORS_treatment', 'triage')) %&gt;%\n    dotted_chart(x = \"absolute\")\n\n\n\n\n\n\n\n\n\nactivity_log %&gt;%\n    filter(event_name %in% c('MINORS_examination', 'MINORS_registration', 'MINORS_treatment', 'triage')) %&gt;%\n    dotted_chart(x = \"relative\", sort=\"start\")\n\n\n\n\n\n\n\n\n\n\nTrauma\n\nactivity_log %&gt;%\n    filter(event_name %in% c('TRAUMA_stabilisation', 'TRAUMA_treatment', 'triage')) %&gt;%\n    dotted_chart(x = \"absolute\")\n\n\n\n\n\n\n\n\n\nactivity_log %&gt;%\n    filter(event_name %in% c('TRAUMA_stabilisation', 'TRAUMA_treatment', 'triage')) %&gt;%\n    dotted_chart(x = \"relative\", sort=\"start\")",
    "crumbs": [
      "Other",
      "Vidigi vs BupaR"
    ]
  },
  {
    "objectID": "vidigi_docs/vidigi_vs_bupar.html#conclusion",
    "href": "vidigi_docs/vidigi_vs_bupar.html#conclusion",
    "title": "Vidigi vs BupaR",
    "section": "Conclusion",
    "text": "Conclusion\nvidigi and bupaR are complementary packages to use when visualising, verifying and validating your simulation models - or working with real-world process data.",
    "crumbs": [
      "Other",
      "Vidigi vs BupaR"
    ]
  },
  {
    "objectID": "vidigi_docs/introduction.html",
    "href": "vidigi_docs/introduction.html",
    "title": "Usage Instructions with SimPy",
    "section": "",
    "text": "Visual display of the outputs of discrete event simulations in simpy have been identified as one of the limitations of simpy, potentially hindering adoption of FOSS simulation in comparison to commercial modelling offerings or GUI FOSS alternatives such as JaamSim.\n\nWhen compared to commercial DES software packages that are commonly used in health research, such as Simul8, or AnyLogic, a limitation of our approach is that we do not display a dynamic patient pathway or queuing network that updates as the model runs a single replication. This is termed Visual Interactive Simulation (VIS) and can help users understand where process problems and delays occur in a patient pathway; albeit with the caveat that single replications can be outliers. A potential FOSS solution compatible with a browser-based app could use a Python package that can represent a queuing network, such as NetworkX, and displaying results via matplotlib. If sophisticated VIS is essential for a FOSS model then researchers may need to look outside of web apps; for example, salabim provides a powerful FOSS solution for custom animation of DES models. - Monks T and Harper A. Improving the usability of open health service delivery simulation models using Python and web apps [version 2; peer review: 3 approved]. NIHR Open Res 2023, 3:48 (https://doi.org/10.3310/nihropenres.13467.2)\n\nThis package allows visually appealing, flexible visualisations of the movement of entities through some kind of pathway.\nIt is primarily tested with discrete event simulations to be created from simpy models, such as the examples below.\n\nPlotly is leveraged to create the final animation, meaning that users can benefit from the ability to further customise or extend the plotly plot, as well as easily integrating with web frameworks such as Streamlit, Dash or Shiny for Python.\nThe code has been designed to be flexible and could potentially be used with alternative simulation packages such as ciw or simmer if it is possible to provide all of the required details in the logs that are output.",
    "crumbs": [
      "Introduction"
    ]
  },
  {
    "objectID": "vidigi_docs/introduction.html#introduction",
    "href": "vidigi_docs/introduction.html#introduction",
    "title": "Usage Instructions with SimPy",
    "section": "",
    "text": "Visual display of the outputs of discrete event simulations in simpy have been identified as one of the limitations of simpy, potentially hindering adoption of FOSS simulation in comparison to commercial modelling offerings or GUI FOSS alternatives such as JaamSim.\n\nWhen compared to commercial DES software packages that are commonly used in health research, such as Simul8, or AnyLogic, a limitation of our approach is that we do not display a dynamic patient pathway or queuing network that updates as the model runs a single replication. This is termed Visual Interactive Simulation (VIS) and can help users understand where process problems and delays occur in a patient pathway; albeit with the caveat that single replications can be outliers. A potential FOSS solution compatible with a browser-based app could use a Python package that can represent a queuing network, such as NetworkX, and displaying results via matplotlib. If sophisticated VIS is essential for a FOSS model then researchers may need to look outside of web apps; for example, salabim provides a powerful FOSS solution for custom animation of DES models. - Monks T and Harper A. Improving the usability of open health service delivery simulation models using Python and web apps [version 2; peer review: 3 approved]. NIHR Open Res 2023, 3:48 (https://doi.org/10.3310/nihropenres.13467.2)\n\nThis package allows visually appealing, flexible visualisations of the movement of entities through some kind of pathway.\nIt is primarily tested with discrete event simulations to be created from simpy models, such as the examples below.\n\nPlotly is leveraged to create the final animation, meaning that users can benefit from the ability to further customise or extend the plotly plot, as well as easily integrating with web frameworks such as Streamlit, Dash or Shiny for Python.\nThe code has been designed to be flexible and could potentially be used with alternative simulation packages such as ciw or simmer if it is possible to provide all of the required details in the logs that are output.",
    "crumbs": [
      "Introduction"
    ]
  },
  {
    "objectID": "vidigi_docs/introduction.html#examples",
    "href": "vidigi_docs/introduction.html#examples",
    "title": "Usage Instructions with SimPy",
    "section": "Examples",
    "text": "Examples\nTo develop and demonstrate the concept, it has so far been used to incorporate visualisation into several existing simpy models that were not initially designed with this sort of visualisation in mind: - a minor injuries unit, showing the utility of the model at high resolutions with branching pathways and the ability to add in a custom background to clearly demarcate process steps\n\n\nan elective surgical pathway (with a focus on cancelled theatre slots due to bed unavailability in recovery areas), with length of stay displayed as well as additional text and graphical data\n\n\n\na community mental health assessment pathway, showing the wait to an appointment as well as highlighting ‘urgent’ patients with a different icon and showing the time from referral to appointment below the patient icons when they attend the appointment.\n\n\n\na community mental health assessment pathway with pooling of clinics, showing the ‘home’ clinic for clients via icon so the balance between ‘home’ and ‘other’ clients can be explored.\n\n\n\na community mental health assessment and treatment pathway, showing the movement of clients between a wait list, a booking list, and returning for repeat appointments over a period of time while sitting on a caseload in between.",
    "crumbs": [
      "Introduction"
    ]
  },
  {
    "objectID": "vidigi_docs/introduction.html#creating-a-visualisation-from-an-existing-model",
    "href": "vidigi_docs/introduction.html#creating-a-visualisation-from-an-existing-model",
    "title": "Usage Instructions with SimPy",
    "section": "Creating a visualisation from an existing model",
    "text": "Creating a visualisation from an existing model\nTwo key things need to happen to existing models to work with the visualisation code: 1. All simpy resources need to be changed to simpy stores containing a custom resource with an ID attribute 2. Logging needs to be added at key points: arrival, (queueing, resource use start, resource use end), departure where the steps in the middle can be repeated for as many queues and resource types as required\n\n1. All simpy resources need to be changed to simpy stores containing a custom resource with an ID attribute\nTo allow the use of resources to be visualised correctly - with entities staying with the same resource throughout the time they are using it - it is essential to be able to identify and track individual resources.\nBy default, this is not possible with Simpy resources. They have no ID attribute or similar.\n\n\nClick here for behind-the-scenes details on this\n\nThe easiest workaround which drops fairly painlessly into existing models is to use a simpy store with a custom resource class.\nThe custom resource is setup as follows:\n\nclass CustomResource(simpy.Resource):\n    def __init__(self, env, capacity, id_attribute=None):\n        super().__init__(env, capacity)\n        self.id_attribute = id_attribute\n\n    def request(self, *args, **kwargs):\n        # Add logic to handle the ID attribute when a request is made\n        return super().request(*args, **kwargs)\n\n    def release(self, *args, **kwargs):\n        # Add logic to handle the ID attribute when a release is made\n        return super().release(*args, **kwargs)\n\nThe creation of simpy resources is then replaced with the following pattern:\n\nbeds = simpy.Store(environment)\n\nfor i in range(number_of_beds):\n    beds.put(\n        CustomResource(\n            environment,\n            capacity=1,\n            id_attribute=i+1)\n        )\n\n\nvidigi.utils provides a helper function for setting up simpy resources in teh required manner.\nFor a given resource that would have been created like this:\n\nnurses = simpy.Resource(simpy_environment, capacity=number_of_nurses)\n\nYou would use\n\nfrom vidigi.utils import populate_store\nnurses = simpy.Store(simpy_environment)\n\npopulate_store(num_resources=number_of_nurses, simpy_store=nurses, sim_env=simpy_environment)\n\nInstead of requesting a resource in the standard way, you instead use the .get() method.\n\nreq = beds.get()\n\nor\n\nwith beds.get() as req:\n  ...CODE HERE THAT USES THE RESOURCE...\n\nAt the end, it is important to put the resource back into the store, even if you used the ‘with’ notation, so it can be made available to the next requester:\n\nbeds.put(req)\n\nThis becomes slightly more complex with conditional requesting (for example, where a resource request is made but if it cannot be fulfilled in time, the requester will renege). This is demonstrated in example 3.\nThe benefit of this is that when we are logging, we can use the .id_attribute attribute of the custom resource to record the resource that was in use. This can have wider benefits for monitoring individual resource utilisation within your model as well.\n\n\n2. Logging needs to be added at key points\nThe animation function needs to be passed an event log with the following layout:\n\n\n\n\n\n\n\n\n\n\n\npatient\npathway\nevent_type\nevent\ntime\nresource_id\n\n\n\n\n15\nPrimary\narrival_departure\narrival\n1.22\n\n\n\n15\nPrimary\nqueue\nenter_queue_for_bed\n1.35\n\n\n\n27\nRevision\narrival_departure\narrival\n1.47\n\n\n\n27\nRevision\nqueue\nenter_queue_for_bed\n1.58\n\n\n\n12\nPrimary\nresource_use_end\npost_surgery_stay_ends\n1.9\n4\n\n\n15\nRevision\nresource_use\npost_survery_stay_begins\n1.9\n4\n\n\n\nOne easy way to achieve this is by appending dictionaries to a list at each important point in the process. For example:\n\nevent_log = []\n...\n...\nevent_log.append(\n      {'patient': id,\n      'pathway': 'Revision',\n      'event_type': 'resource_use',\n      'event': 'post_surgery_stay_begins',\n      'time': self.env.now,\n      'resource_id': bed.id_attribute}\n  )\n\nThe list of dictionaries can then be converted to a pandas dataframe using\n\npd.DataFrame(event_log)\n\nand passed to the animation function where required.\n\nEvent types\nFour event types are supported in the model: ‘arrival_departure’, ‘resource_use’, ‘resource_use_end’, and ‘queue’.\nAs a minimum, you will require the use of ‘arrival_departure’ events and one of - ‘resource_use’/‘resource_use_end’ - OR ‘queue’\nYou can also use both ‘resource_use’ and ‘queue’ within the same model very effectively (see ex_1_simplest_case and ex_2_branching_and_optional_paths).\n\narrival_departure\nWithin this, a minimum of two ‘arrival_departure’ events per entity are mandatory - arrival and depart, both with an event_type of arrival_departure, as shown below.\n\nevent_log.append(\n      {'patient': unique_entity_identifier,\n      'pathway': 'Revision',\n      'event_type': 'arrival_departure',\n      'event': 'arrival',\n      'time': env.now}\n  )\n\n\nevent_log.append(\n      {'patient': unique_entity_identifier,\n      'pathway': 'Revision',\n      'event_type': 'arrival_departure',\n      'event': 'depart',\n      'time': env.now}\n  )\n\nThese are critical as they are used to determine when patients should first and last appear in the model. Forgetting to include a departure step for all types of patients can lead to slow model performance as the size of the event logs for individual moments will continue to increase indefinitely.\n\n\nqueue\nQueues are key steps in the model.\nIt is possible to solely use queues and never make use of a simpy resource.\nBy tracking each important step in the process as a ‘queue’ step, the movement of patients can be accurately tracked.\nPatients will be ordered by the point at which they are added to the queue, with the first entries appearing at the front (bottom-right) of the queue.\n\nevent_log.append(\n            {'patient': unique_entity_identifier,\n             'pathway': 'High intensity',\n             'event_type': 'queue',\n             'event': 'appointment_booked_waiting',\n             'time': self.env.now\n             }\n        )\n\nWhile the keys shown above are mandatory, you can add as many additional keys to a step’s log as desired. This can allow you to flexibly make use of the event log for other purposes as well as the animation.\n\n\nresource_use and resource_use_end\nResource use is more complex to include but comes with two key benefits over the queue: - it becomes easier to monitor the length of time a resource is in use by a single entity as users won’t ‘move through’ the resource use stage (which can also prove confusing to less experienced viewers) - it becomes possible to show the total number of resources that are available, making it easier to understand how well resources are being utilised at different stages\n\nclass CustomResource(simpy.Resource):\n    def __init__(self, env, capacity, id_attribute=None):\n        super().__init__(env, capacity)\n        self.id_attribute = id_attribute\n\n    def request(self, *args, **kwargs):\n        # Add logic to handle the ID attribute when a request is made\n        # For example, you can assign an ID to the requester\n        # self.id_attribute = assign_id_logic()\n        return super().request(*args, **kwargs)\n\n    def release(self, *args, **kwargs):\n        # Add logic to handle the ID attribute when a release is made\n        # For example, you can reset the ID attribute\n        # reset_id_logic(self.id_attribute)\n        return super().release(*args, **kwargs)\n\ntriage = simpy.Store(self.env)\n\nfor i in range(n_triage):\n    triage.put(\n        CustomResource(\n            env,\n            capacity=1,\n            id_attribute = i+1)\n        )\n\n# request sign-in/triage\ntriage_resource = yield triage.get()\n\nevent_log.append(\n    {'patient': unique_entity_identifier,\n     'pathway': 'Trauma',\n     'event_type': 'resource_use',\n     'event': 'triage_begins',\n     'time': env.now,\n     'resource_id': triage_resource.id_attribute\n    }\n)\n\nyield self.env.timeout(1)\n\nevent_log.append(\n            {'patient': unique_entity_identifier,\n             'pathway': 'Trauma',\n             'event_type': 'resource_use_end',\n             'event': 'triage_complete',\n             'time': env.now,\n             'resource_id': triage_resource.id_attribute}\n        )\n\n# Resource is no longer in use, so put it back in the store\ntriage.put(triage_resource)\n\nWhen providing your event position details, it then just requires you to include an identifier for the resource.\nNOTE: At present this requires you to be using an class to manage your resource counts (if following HSMA simpy structure, this will be your g class).\nThis requirement is planned to be removed in a future version of the work, allowing more flexibility.\n\n{'event': 'TRAUMA_stabilisation_begins',\n 'x': 300, 'y': 500, 'resource':'n_trauma', 'label': \"Being&lt;br&gt;Stabilised\" }",
    "crumbs": [
      "Introduction"
    ]
  },
  {
    "objectID": "vidigi_docs/introduction.html#creating-the-animation",
    "href": "vidigi_docs/introduction.html#creating-the-animation",
    "title": "Usage Instructions with SimPy",
    "section": "Creating the animation",
    "text": "Creating the animation\n\nDetermining event positioning in the animation\nOnce the event log has been created, the positions of each queue and resource must be set up.\nAn easy way to create this is passing a list of dictionaries to the pd.DataFrame function.\nThe columns required are event: This must match the label used for the event in the event log x: The x coordinate of the event for the animation. This will correspond to the bottom-right hand corner of a queue, or the rightmost resource. y: The y coordinate of the event for the animaation. This will correspond to the lowest row of a queue, or the central point of the resources. label: A label for the stage. This can be hidden at a later step if you opt to use a background image with labels built-in. Note that line breaks in the label can be created using the HTML tag &lt;br&gt;. resource (OPTIONAL): Only required if the step is a resource_use step. This looks at the ‘scenario’ object passed to the animate_activity_log() function and pulls the attribute with the given name, which should give the number of available resources for that step.\n\n        event_position_df = pd.DataFrame([\n                # Triage\n                {'event': 'triage_wait_begins',\n                 'x':  160, 'y': 400, 'label': \"Waiting for&lt;br&gt;Triage\"  },\n                {'event': 'triage_begins',\n                 'x':  160, 'y': 315, 'resource':'n_triage', 'label': \"Being Triaged\" },\n\n                # Trauma pathway\n                {'event': 'TRAUMA_stabilisation_wait_begins',\n                 'x': 300, 'y': 560, 'label': \"Waiting for&lt;br&gt;Stabilisation\" },\n                {'event': 'TRAUMA_stabilisation_begins',\n                 'x': 300, 'y': 500, 'resource':'n_trauma', 'label': \"Being&lt;br&gt;Stabilised\" },\n\n                {'event': 'TRAUMA_treatment_wait_begins',\n                 'x': 630, 'y': 560, 'label': \"Waiting for&lt;br&gt;Treatment\" },\n                {'event': 'TRAUMA_treatment_begins',\n                 'x': 630, 'y': 500, 'resource':'n_cubicles', 'label': \"Being&lt;br&gt;Treated\" },\n\n                 {'event': 'exit',\n                 'x':  670, 'y': 330, 'label': \"Exit\"}\n            ])\n\n\n\nCreating the animation\nThere are two main ways to create the animation:\n\nusing the one-step function animate_activity_log() (see pages/1_Simple_ED_interactive, pages/2_Simple_ED_Forced_Overcrowding or pages/3_Complex_ED_Interactive for examples of this)\nusing the functions reshape_for_animations(), generate_animation_df() and generate_animation() separately, passing the output of each to the next step. This allows you to apply significant extra customisations; examples demonstrating this will be added soon.",
    "crumbs": [
      "Introduction"
    ]
  },
  {
    "objectID": "vidigi_docs/introduction.html#emergency-department-treatment-centre-model",
    "href": "vidigi_docs/introduction.html#emergency-department-treatment-centre-model",
    "title": "Usage Instructions with SimPy",
    "section": "Emergency department (Treatment Centre) model",
    "text": "Emergency department (Treatment Centre) model\nMonks.T, Harper.A, Anagnoustou. A, Allen.M, Taylor.S. (2022) Open Science for Computer Simulation\nhttps://github.com/TomMonks/treatment-centre-sim\nThe layout code for the emergency department model: https://github.com/hsma-programme/Teaching_DES_Concepts_Streamlit",
    "crumbs": [
      "Introduction"
    ]
  },
  {
    "objectID": "vidigi_docs/introduction.html#the-hospital-efficiency-project-model",
    "href": "vidigi_docs/introduction.html#the-hospital-efficiency-project-model",
    "title": "Usage Instructions with SimPy",
    "section": "The hospital efficiency project model",
    "text": "The hospital efficiency project model\nHarper, A., & Monks, T. Hospital Efficiency Project Orthopaedic Planning Model Discrete-Event Simulation [Computer software]. https://doi.org/10.5281/zenodo.7951080\nhttps://github.com/AliHarp/HEP/tree/main",
    "crumbs": [
      "Introduction"
    ]
  },
  {
    "objectID": "vidigi_docs/introduction.html#simulation-model-with-scheduling-example",
    "href": "vidigi_docs/introduction.html#simulation-model-with-scheduling-example",
    "title": "Usage Instructions with SimPy",
    "section": "Simulation model with scheduling example",
    "text": "Simulation model with scheduling example\nMonks, T.\nhttps://github.com/health-data-science-OR/stochastic_systems\nhttps://github.com/health-data-science-OR/stochastic_systems/tree/master/labs/simulation/lab5",
    "crumbs": [
      "Introduction"
    ]
  },
  {
    "objectID": "vidigi_docs/adding_vidigi_to_a_simple_simpy_model_hsma_structure.html",
    "href": "vidigi_docs/adding_vidigi_to_a_simple_simpy_model_hsma_structure.html",
    "title": "Adding Vidigi to a Simple simpy Model (HSMA Structure)",
    "section": "",
    "text": "On the Health Service Modelling Associates (HSMA) course we teach a particular way of writing your simpy models. More details of the approach we take can be found in our Little Book of DES.\nHowever, the core concepts of adding vidigi to your models will be the same across different models - so this example will hopefully be helpful regardless of the way you structure your simpy models.",
    "crumbs": [
      "Walkthroughs",
      "Adding Vidigi to a Simple simpy Model (HSMA Structure)"
    ]
  },
  {
    "objectID": "vidigi_docs/adding_vidigi_to_a_simple_simpy_model_hsma_structure.html#vidigis-requirements",
    "href": "vidigi_docs/adding_vidigi_to_a_simple_simpy_model_hsma_structure.html#vidigis-requirements",
    "title": "Adding Vidigi to a Simple simpy Model (HSMA Structure)",
    "section": "Vidigi’s requirements",
    "text": "Vidigi’s requirements\nThe key input vidigi requires an event log of the times that each entity in your system reached key milestones like arriving in the system, beginning to queue for a resource, being seen by a resource, and exiting the system.\nWe also need to tell vidigi what kind of activity is happening at each point:\n\narrive/depart\nqueue\nresource_use\n\nWe also provide vidigi with a table of coordinates that will help it to lay out our entities and resources, and determine their path from the entrance, to the exit, and to some extent their movement between stages.\nVidigi then takes this event log and the layout table and will process them into a table that tracks the position of every entity in the system at specified time intervals.",
    "crumbs": [
      "Walkthroughs",
      "Adding Vidigi to a Simple simpy Model (HSMA Structure)"
    ]
  },
  {
    "objectID": "vidigi_docs/adding_vidigi_to_a_simple_simpy_model_hsma_structure.html#hsma-model-structure",
    "href": "vidigi_docs/adding_vidigi_to_a_simple_simpy_model_hsma_structure.html#hsma-model-structure",
    "title": "Adding Vidigi to a Simple simpy Model (HSMA Structure)",
    "section": "HSMA Model Structure",
    "text": "HSMA Model Structure\nIn HSMA, we use four primary classes to structure our models:\n\ng, which stores model parameters (like the number of resources of a given type and distribution parameters) and simulation parameters (like the number of replications to run and the )\nEntity, which may be named something more descriptive like ‘Patient’ or ‘Customer’. You may also have more than one entity class. Each entity will store information such as its ID, and will be passed into the model to work through the pathway.\nModel, which will generate entities, simulate the pathway the entity takes through the system, and contain a way to run a single replication of the model\nTrial, which allows us to run the simulation multiple times, collect results from all of these, and get an indication of average performance and performance variation across our different model runs",
    "crumbs": [
      "Walkthroughs",
      "Adding Vidigi to a Simple simpy Model (HSMA Structure)"
    ]
  },
  {
    "objectID": "vidigi_docs/adding_vidigi_to_a_simple_simpy_model_hsma_structure.html#a-simple-model",
    "href": "vidigi_docs/adding_vidigi_to_a_simple_simpy_model_hsma_structure.html#a-simple-model",
    "title": "Adding Vidigi to a Simple simpy Model (HSMA Structure)",
    "section": "A Simple Model",
    "text": "A Simple Model\nWe’re going to start off with a very simple model of a walk-in clinic pathway.\nIn this clinic, patients arrive and are seen in the order they arrive by one of several available nurses. All nurses have the same skillset, so the queue is a simple first-in-first-out (FIFO). There is some variability in the arrival time of patients, as well as variability in how long it takes for each patient to be seen.\n\nthe g Class\nIn our g class, we set up parameters that will be used throughout.\n\nclass g:\n    random_number_set = 42 # Control\n    ial seeds of each stream of pseudorandom numbers used\n\n    n_cubicles = 3 # The number of treatment cubicles\n    trauma_treat_mean = 40 # Mean of the trauma cubicle treatment distribution (Lognormal)\n    trauma_treat_var = 5 # Variance of the trauma cubicle treatment distribution (Lognormal)\n\n    arrival_rate = 5 # mean of the exponential distribution for sampling the inter-arrival time of entities\n\n\n    sim_duration = 600 # The number of time units the simulation will run for\n    number_of_runs = 100 # The number of times the simulation will be run with different random number streams\n\n\n\nthe Patient Class\nOur Patient class represents a single individual.\nThe attributes in this class are used to track various metrics that will be used for determining how well our particular scenario has performed - think of it like a person holding a clipboard that is having various times and figures recorded on it as they move through the system.\n\nclass Patient:\n    def __init__(self, p_id):\n        self.identifier = p_id\n        self.arrival = -np.inf\n        self.wait_treat = -np.inf\n        self.total_time = -np.inf\n        self.treat_duration = -np.inf\n\n\n\nthe Model Class\nOur model class is more complex.\n:::\n\nthe init method\nFirst, we set up a series of attributes\n\n    def __init__(self, run_number):\n        # Create a SimPy environment in which everything will live\n        self.env = simpy.Environment()\n\n        # Create a patient counter (which we'll use as a patient ID)\n        self.patient_counter = 0\n\n        self.patients = []\n\n        # Create our resources\n        self.init_resources()\n\n        # Store the passed in run number\n        self.run_number = run_number\n\n        # Create a new Pandas DataFrame that will store some results against\n        # the patient ID (which we'll use as the index).\n        self.results_df = pd.DataFrame()\n        self.results_df[\"Patient ID\"] = [1]\n        self.results_df[\"Queue Time Cubicle\"] = [0.0]\n        self.results_df[\"Time with Nurse\"] = [0.0]\n        self.results_df.set_index(\"Patient ID\", inplace=True)\n\n        # Create an attribute to store the mean queuing times across this run of\n        # the model\n        self.mean_q_time_cubicle = 0\n\n        self.patient_inter_arrival_dist = Exponential(mean = g.arrival_rate,\n                                                      random_seed = self.run_number*g.random_number_set)\n        self.treat_dist = Lognormal(mean = g.trauma_treat_mean,\n                                    stdev = g.trauma_treat_var,\n                                    random_seed = self.run_number*g.random_number_set)\n\n\n\nthe init_resources method\n\n    def init_resources(self):\n        '''\n        Init the number of resources\n\n        Resource list:\n            1. Nurses/treatment bays (same thing in this model)\n\n        '''\n        self.treatment_cubicles = simpy.Resource(self.env, capacity=g.n_cubicles)\n\n\n\nthe generator_patient_arrivals method\n\n    def generator_patient_arrivals(self):\n        # We use an infinite loop here to keep doing this indefinitely whilst\n        # the simulation runs\n        while True:\n            # Increment the patient counter by 1 (this means our first patient\n            # will have an ID of 1)\n            self.patient_counter += 1\n\n            # Create a new patient - an instance of the Patient Class we\n            # defined above.  Remember, we pass in the ID when creating a\n            # patient - so here we pass the patient counter to use as the ID.\n            p = Patient(self.patient_counter)\n\n            # Store patient in list for later easy access\n            self.patients.append(p)\n\n            # Tell SimPy to start up the attend_clinic generator function with\n            # this patient (the generator function that will model the\n            # patient's journey through the system)\n            self.env.process(self.attend_clinic(p))\n\n            # Randomly sample the time to the next patient arriving.  Here, we\n            # sample from an exponential distribution (common for inter-arrival\n            # times), and pass in a lambda value of 1 / mean.  The mean\n            # inter-arrival time is stored in the g class.\n            sampled_inter = self.patient_inter_arrival_dist.sample()\n\n            # Freeze this instance of this function in place until the\n            # inter-arrival time we sampled above has elapsed.  Note - time in\n            # SimPy progresses in \"Time Units\", which can represent anything\n            # you like (just make sure you're consistent within the model)\n            yield self.env.timeout(sampled_inter)\n\n\n\nthe attend_clinic function\n\n    def attend_clinic(self, patient):\n        self.arrival = self.env.now\n\n        # request examination resource\n        start_wait = self.env.now\n\n        with self.treatment_cubicles.request() as req:\n            # Seize a treatment resource when available\n            yield req\n\n            # record the waiting time for registration\n            self.wait_treat = self.env.now - start_wait\n\n            # sample treatment duration\n            self.treat_duration = self.treat_dist.sample()\n            yield self.env.timeout(self.treat_duration)\n\n        # total time in system\n        self.total_time = self.env.now - self.arrival\n\n\n\nthe calculate_run_results function\n\n    def calculate_run_results(self):\n        # Take the mean of the queuing times across patients in this run of the\n        # model.\n        self.mean_q_time_cubicle = self.results_df[\"Queue Time Cubicle\"].mean()\n\n\n\nthe run function\n\n    def run(self):\n        # Start up our DES entity generators that create new patients.  We've\n        # only got one in this model, but we'd need to do this for each one if\n        # we had multiple generators.\n        self.env.process(self.generator_patient_arrivals())\n\n        # Run the model for the duration specified in g class\n        self.env.run(until=g.sim_duration)\n\n        # Now the simulation run has finished, call the method that calculates\n        # run results\n        self.calculate_run_results()\n\n\n\n\nthe Trial Class\n\nthe init method\n\ndef  __init__(self):\n    self.df_trial_results = pd.DataFrame()\n    self.df_trial_results[\"Run Number\"] = [0]\n    self.df_trial_results[\"Arrivals\"] = [0]\n    self.df_trial_results[\"Mean Queue Time Cubicle\"] = [0.0]\n    self.df_trial_results.set_index(\"Run Number\", inplace=True)\n\n\n\nThe run_trial method\nRun the simulation for the number of runs specified in g class.\nor each run, we create a new instance of the Model class and call its run method, which sets everything else in motion.\nOnce the run has completed, we grab out the stored run results (just mean queuing time here) and store it against the run number in the trial results dataframe.\n\n    def run_trial(self):\n        print(f\"{g.n_cubicles} nurses\")\n        print(\"\") ## Print a blank line\n\n        for run in range(g.number_of_runs):\n            random.seed(run)\n\n            my_model = Model(run)\n            my_model.run()\n\n            self.df_trial_results.loc[run] = [my_model.mean_q_time_cubicle]\n\n        return self.df_trial_results",
    "crumbs": [
      "Walkthroughs",
      "Adding Vidigi to a Simple simpy Model (HSMA Structure)"
    ]
  },
  {
    "objectID": "vidigi_docs/adding_vidigi_to_a_simple_simpy_model_hsma_structure.html#making-changes-for-vidigi",
    "href": "vidigi_docs/adding_vidigi_to_a_simple_simpy_model_hsma_structure.html#making-changes-for-vidigi",
    "title": "Adding Vidigi to a Simple simpy Model (HSMA Structure)",
    "section": "Making Changes for Vidigi",
    "text": "Making Changes for Vidigi\n\nimports\n\n\n\nOriginal\n\nimport random\nimport numpy as np\nimport pandas as pd\nimport simpy\nfrom sim_tools.distributions import Exponential, Lognormal\n\n\n\n\n\n\nWith Vidigi Modifications\n\nimport random\nimport numpy as np\nimport pandas as pd\nimport simpy\nfrom sim_tools.distributions import Exponential, Lognormal\nfrom vidigi.utils import populate_store \nfrom vidigi.animation import animate_activity_log \n\n\n\n\n\n\nthe g Class\nOur g class is unchanged.\n\n\nthe Entity Class\nOur entity class - in this case, Patient - is unchanged.\n\n\nthe Model Class\n\nThe init method\nTo our init method for the Model class, we add an empty list that will store event logs throughout the model run for each patient.\n\n\n\nOriginal\n\ndef __init__(self, run_number):\n    # Create a SimPy environment in which everything will live\n    self.env = simpy.Environment()\n\n    # Create a patient counter (which we'll use as a patient ID)\n    self.patient_counter = 0\n\n    # Create an empty list to store patient objects in\n    self.patients = []\n\n    # Create our resources\n    self.init_resources()\n\n    # Store the passed in run number\n    self.run_number = run_number\n\n    # Create a new Pandas DataFrame that will store some results\n    # against the patient ID (which we'll use as the index).\n    self.results_df = pd.DataFrame()\n    self.results_df[\"Patient ID\"] = [1]\n    self.results_df[\"Queue Time Cubicle\"] = [0.0]\n    self.results_df[\"Time with Nurse\"] = [0.0]\n    self.results_df.set_index(\"Patient ID\", inplace=True)\n\n    # Create an attribute to store the mean queuing times\n    # across this run of the model\n    self.mean_q_time_cubicle = 0\n\n    self.patient_inter_arrival_dist = Exponential(\n        mean = g.arrival_rate,\n        random_seed = self.run_number*g.random_number_set\n        )\n\n    self.treat_dist = Lognormal(\n        mean = g.trauma_treat_mean,\n        stdev = g.trauma_treat_var,\n        random_seed = self.run_number*g.random_number_set\n        )\n\n\n\n\n\n\nWith Vidigi Modifications\n\ndef __init__(self, run_number):\n    # Create a SimPy environment in which everything will live\n    self.env = simpy.Environment()\n\n    # Add an empty list to store our event logs in \n    self.event_log = [] \n\n    # Create a patient counter (which we'll use as a patient ID)\n    self.patient_counter = 0\n\n    # Create an empty list to store patient objects in\n    self.patients = []\n\n    # Create our resources\n    self.init_resources()\n\n    # Store the passed in run number\n    self.run_number = run_number\n\n    # Create a new Pandas DataFrame that will store some results\n    # against the patient ID (which we'll use as the index)\n    self.results_df = pd.DataFrame()\n    self.results_df[\"Patient ID\"] = [1]\n    self.results_df[\"Queue Time Cubicle\"] = [0.0]\n    self.results_df[\"Time with Nurse\"] = [0.0]\n    self.results_df.set_index(\"Patient ID\", inplace=True)\n\n    # Create an attribute to store the mean queuing times\n    # across this run of the model\n    self.mean_q_time_cubicle = 0\n\n    self.patient_inter_arrival_dist = Exponential(\n        mean = g.arrival_rate,\n        random_seed = self.run_number*g.random_number_set\n        )\n\n    self.treat_dist = Lognormal(\n        mean = g.trauma_treat_mean,\n        stdev = g.trauma_treat_var,\n        random_seed = self.run_number*g.random_number_set\n        )\n\n\n\n\n\n\nthe init_resources method\nVidigi needs to know which resource a user made use of so that we can ensure it stays with the correct resource throughout its time in the animation.\nThe standard simpy Resource does not have a way of tracking that, so we need to do two things: - create a simpy Store that we will store our resources in - use the vidigi helper function populate_store() to generate a store full of special resources that each have a unique ID we can track when doing our event logging\nOverall, the use of stores won’t generally change your code too much - and we cover exactly what needs to change a little later in this document.\nIf you are using priority resources, this step will be a little different - see Example 3 in the documents if you need to use Resources that prioritise some entities over others.\n\n\n\nOriginal\n\ndef init_resources(self):\n    self.treatment_cubicles = simpy.Resource(\n        self.env,\n        capacity=g.n_cubicles\n        )\n\n\n\n\n\n\nWith Vidigi Modifications\n\ndef init_resources(self):\n    self.treatment_cubicles = simpy.Store(self.env) \n\n    populate_store(  \n        num_resources=g.n_cubicles, \n        simpy_store=self.treatment_cubicles, \n        sim_env=self.env\n        ) \n\n\n\n\n\n\nthe generator_patient_arrivals method\nThis method is unchanged.\n\n\nthe attend_clinic method\nThis is the key place in which we add our logging. The logs are what vidigi relies on to calculate who should be where, when, within the animation.\nEvent logging takes the format below:\n\nself.event_log.append(\n        {'patient': entity_identifier,\n            'pathway': 'My_Pathway_Name',\n            'event_type': 'arrival_departure', # or 'queue', 'resource_use', or 'resource_use_end'\n            'event': 'arrival', # or 'depart', or for 'queue' and 'resource_use' or 'resource_use_end' you can determine your own event name\n            'time': self.env.now}\n    )\n\nMore details about event logging can be found in the ‘Event Logging’ page.\nThis is also where we need to change the way we request resources to account for the fact we are now using a simpy store instead of directly interacting with our simpy resources.\nWhere we would have previously used\n\nwith self.treatment_cubicles.request() as req:\n    # Seize a treatment resource when available\n    yield req\n\n    # ALL CODE WHERE WE NEED TO KEEP HOLD OF THE RESOURCE\n\n# CONTINUE AFTER RELEASING RESOURCE HERE\n\nwe instead now use\n\n# Seize a treatment resource when available\ntreatment_resource = yield self.treatment_cubicles.get()\n\n# ALL CODE WHERE WE NEED TO KEEP HOLD OF THE RESOURCE\n\n# CONTINUE AFTER RELEASING RESOURCE HERE\n\n# Resource is no longer in use, so put it back in the store\nself.treatment_cubicles.put(treatment_resource)\n\n\n\n\nOriginal\n\ndef attend_clinic(self, patient):\n    self.arrival = self.env.now\n\n    # request examination resource\n    start_wait = self.env.now\n\n    with self.treatment_cubicles.request() as req:\n        # Seize a treatment resource when available\n        yield req\n\n        # record the waiting time for registration\n        self.wait_treat = self.env.now - start_wait\n\n        # sample treatment duration\n        self.treat_duration = self.treat_dist.sample()\n        yield self.env.timeout(self.treat_duration)\n\n    # total time in system\n    self.total_time = self.env.now - self.arrival\n\n\n\n\n\n\nWith Vidigi Modifications\n\ndef attend_clinic(self, patient):\n    self.arrival = self.env.now\n    self.event_log.append( \n        {'patient': patient.identifier, \n            'pathway': 'Simplest', \n            'event_type': 'arrival_departure', \n            # you must use this event name for arrival events\n            'event': 'arrival',  \n            'time': self.env.now} \n    ) \n\n    # request examination resource\n    start_wait = self.env.now\n    self.event_log.append( \n        {'patient': patient.identifier, \n            'pathway': 'Simplest', \n            # for a queue, you can define your chosen event name\n            'event': 'treatment_wait_begins', \n            'event_type': 'queue', \n            'time': self.env.now} \n    ) \n\n    # Seize a treatment resource when available\n    treatment_resource = yield self.treatment_cubicles.get() \n\n    # record the waiting time for registration\n    self.wait_treat = self.env.now - start_wait\n    self.event_log.append( \n        {'patient': patient.identifier, \n            'pathway': 'Simplest', \n            'event': 'treatment_begins', \n            # for a resource_use, you can define your chosen event name\n            'event_type': 'resource_use', \n            'time': self.env.now, \n            # grab the resource id from the treatment_resource requested\n            'resource_id': treatment_resource.id_attribute \n            } \n    ) \n\n    # sample treatment duration\n    self.treat_duration = self.treat_dist.sample()\n    yield self.env.timeout(self.treat_duration)\n\n    self.event_log.append( \n        {'patient': patient.identifier, \n            'pathway': 'Simplest', \n            # for a resource_use_end, you can define your chosen event name\n            'event': 'treatment_complete', \n            'event_type': 'resource_use_end', \n            'time': self.env.now, \n            'resource_id': treatment_resource.id_attribute} \n    ) \n\n    # Resource is no longer in use, so put it back in the store \n    self.treatment_cubicles.put(treatment_resource) \n\n    # total time in system\n    self.total_time = self.env.now - self.arrival\n    self.event_log.append( \n        {'patient': patient.identifier, \n        'pathway': 'Simplest', \n        'event': 'depart', # you must use this event name for departure events \n        'event_type': 'arrival_departure', \n        'time': self.env.now} \n    ) \n\n\n\n\n\n\nthe calculate_run_results method\nThis method is unchanged.\n\n\nthe run method\n\n\n\nOriginal\n\ndef run(self):\n    # Start up our DES entity generators that create new patients.  We've\n    # only got one in this model, but we'd need to do this for each one if\n    # we had multiple generators.\n    self.env.process(self.generator_patient_arrivals())\n\n    # Run the model for the duration specified in g class\n    self.env.run(until=g.sim_duration)\n\n    # Now the simulation run has finished, call the method that calculates\n    # run results\n    self.calculate_run_results()\n\n\n\n\n\n\nWith Vidigi Modifications\n\ndef run(self):\n    # Start up our DES entity generators that create new patients.  We've\n    # only got one in this model, but we'd need to do this for each one if\n    # we had multiple generators.\n    self.env.process(self.generator_patient_arrivals())\n\n    # Run the model for the duration specified in g class\n    self.env.run(until=g.sim_duration)\n\n    # Now the simulation run has finished, call the method that calculates\n    # run results\n    self.calculate_run_results()\n\n    self.event_log = pd.DataFrame(self.event_log) \n\n    self.event_log[\"run\"] = self.run_number \n\n    return {'results': self.results_df, 'event_log': self.event_log}  \n\n\n\n\n\n\n\nthe Trial Class\n\nthe init method\n\n\n\nOriginal\n\ndef  __init__(self):\n    self.df_trial_results = pd.DataFrame()\n    self.df_trial_results[\"Run Number\"] = [0]\n    self.df_trial_results[\"Arrivals\"] = [0]\n    self.df_trial_results[\"Mean Queue Time Cubicle\"] = [0.0]\n    self.df_trial_results.set_index(\"Run Number\", inplace=True)\n\n\n\n\n\n\nWith Vidigi Modifications\n\ndef  __init__(self):\n    self.df_trial_results = pd.DataFrame()\n    self.df_trial_results[\"Run Number\"] = [0]\n    self.df_trial_results[\"Arrivals\"] = [0]\n    self.df_trial_results[\"Mean Queue Time Cubicle\"] = [0.0]\n    self.df_trial_results.set_index(\"Run Number\", inplace=True)\n\n    self.all_event_logs = [] \n\n\n\n\n\n\nthe run_trial method\n\n\n\nOriginal\n\ndef run_trial(self):\n    for run in range(g.number_of_runs):\n        random.seed(run)\n\n        my_model = Model(run)\n        my_model.run()\n\n        self.df_trial_results.loc[run] = [\n            my_model.mean_q_time_cubicle\n        ]\n\n    return self.df_trial_results\n\n\n\n\n\n\nWith Vidigi Modifications\n\ndef run_trial(self):\n    for run in range(g.number_of_runs):\n        random.seed(run)\n\n        my_model = Model(run)\n        model_outputs = my_model.run()\n        patient_level_results = model_outputs[\"results\"] \n        event_log = model_outputs[\"event_log\"] \n\n        self.df_trial_results.loc[run] = [\n            my_model.mean_q_time_cubicle\n        ]\n\n        self.all_event_logs.append(event_log) \n\n    self.all_event_logs = pd.concat(self.all_event_logs)",
    "crumbs": [
      "Walkthroughs",
      "Adding Vidigi to a Simple simpy Model (HSMA Structure)"
    ]
  },
  {
    "objectID": "vidigi_docs/adding_vidigi_to_a_simple_simpy_model_hsma_structure.html#using-vidigi-to-create-an-animation-from-our-event-log",
    "href": "vidigi_docs/adding_vidigi_to_a_simple_simpy_model_hsma_structure.html#using-vidigi-to-create-an-animation-from-our-event-log",
    "title": "Adding Vidigi to a Simple simpy Model (HSMA Structure)",
    "section": "Using vidigi to create an animation from our event log",
    "text": "Using vidigi to create an animation from our event log\nFor simple animations with vidigi, it is recommended that you use the animate_activity_log function.\nThis all-in-one function takes an event log of the structure discussed above, then turns it into an animated output that can be embedded in a quarto document, a web app, or saved as a standalone HTML file.\nFirst, we need to create an instance of our trial class, then run the trial.\n\nmy_trial = Trial()\n\nmy_trial.run_trial()\n\nThe dataframe of event logs can then be viewed using my_trial.all_event_logs\n\nThe event_position_df\nWe can then generate our coordinates for the initial positioning of each step.\n\n\n\n\n\n\nNote\n\n\n\nThe ‘event’ names must match the event names you assigned in the logging steps.\nHowever, this will not be displayed anywhere in the final setup. Instead, use ‘label’ to define a human-readable label that can optionally be displayed in the final animation.\n\n\n\n\n\n\n\n\nWarning\n\n\n\n‘label’ should not be left out or be an empty string - both of these will cause problems.\n\n\n\n\n\n\n\n\nNote\n\n\n\nYou only need to provide positions for\n\narrival\ndeparture\nqueue\nresource_use (optional - you can have an animation that is only queues)\n\ni.e. you do not need to provide coordinates for resource_use_end\nYou can also opt to skip any queue or resource_use steps you do not want to show, though note that this could produce a misleading output if not carefully explained to end users\n\n\n\n\n\n\n\n\nTip\n\n\n\nFor queues and resource use, the coordinate will correspond to the bottom-right-hand corner of the block of queueing entities or resources.\n\n\n\nevent_position_df = pd.DataFrame([\n                    {'event': 'arrival',\n                     'x':  50, 'y': 300,\n                     'label': \"Arrival\" },\n\n                    # Triage - minor and trauma\n                    {'event': 'treatment_wait_begins',\n                     'x':  205, 'y': 275,\n                     'label': \"Waiting for Treatment\"},\n\n                    {'event': 'treatment_begins',\n                     'x':  205, 'y': 175,\n                     'resource':'n_cubicles',\n                     'label': \"Being Treated\"},\n\n                    {'event': 'exit',\n                     'x':  270, 'y': 70,\n                     'label': \"Exit\"}\n\n                ])",
    "crumbs": [
      "Walkthroughs",
      "Adding Vidigi to a Simple simpy Model (HSMA Structure)"
    ]
  },
  {
    "objectID": "vidigi_docs/adding_vidigi_to_a_simple_simpy_model_hsma_structure.html#creating-the-animation",
    "href": "vidigi_docs/adding_vidigi_to_a_simple_simpy_model_hsma_structure.html#creating-the-animation",
    "title": "Adding Vidigi to a Simple simpy Model (HSMA Structure)",
    "section": "Creating the animation",
    "text": "Creating the animation\nFinally, we can create the animation.\n\n\n\n\n\n\nWarning\n\n\n\nIt is important that you only pass in a single run at a time!\nPassing a dataframe in containing more than one run will produce incorrect animations.\nYou may, however, wish to give the user control over which run they visualise using a dropdown in something like Streamlit or Shiny - or perhaps\n\n\n\nsingle_run_event_log_df = my_trial.all_event_logs[my_trial.all_event_logs['run']==1]\n\nanimate_activity_log(\n        event_log=single_run_event_log_df,\n        event_position_df= event_position_df,\n        scenario=g(), # Use an instance of the g class as our scenario\n        limit_duration=g.sim_duration,\n        debug_mode=True, # Turn on logging messages\n        setup_mode=True, # Turn on axis units - this can help with honing your event_position_df\n        every_x_time_units=1,\n        include_play_button=True,\n        icon_and_text_size=20,\n        gap_between_entities=6,\n        gap_between_rows=25,\n        plotly_height=700,\n        frame_duration=200,\n        plotly_width=1200,\n        override_x_max=300,\n        override_y_max=500,\n        wrap_queues_at=25,\n        step_snapshot_max=125,\n        time_display_units=\"dhm\",\n        display_stage_labels=True # display our Label column from our event_position_df\n    )\n\n\n\n\n\n\n\nClick here to view the full code\n\n\n\n\n\n\nimport random\nimport numpy as np\nimport pandas as pd\nimport simpy\nfrom sim_tools.distributions import Exponential, Lognormal\nfrom vidigi.utils import populate_store\nfrom vidigi.animation import animate_activity_log\n\n# Class to store global parameter values.  We don't create an instance of this\n# class - we just refer to the class blueprint itself to access the numbers\n# inside.\nclass g:\n    '''\n    Create a scenario to parameterise the simulation model\n\n    Parameters:\n    -----------\n    random_number_set: int, optional (default=DEFAULT_RNG_SET)\n        Set to control the initial seeds of each stream of pseudo\n        random numbers used in the model.\n\n    n_cubicles: int\n        The number of treatment cubicles\n\n    trauma_treat_mean: float\n        Mean of the trauma cubicle treatment distribution (Lognormal)\n\n    trauma_treat_var: float\n        Variance of the trauma cubicle treatment distribution (Lognormal)\n\n    arrival_rate: float\n        Set the mean of the exponential distribution that is used to sample the\n        inter-arrival time of patients\n\n    sim_duration: int\n        The number of time units the simulation will run for\n\n    number_of_runs: int\n        The number of times the simulation will be run with different random number streams\n\n    '''\n    random_number_set = 42\n\n    n_cubicles = 3\n    trauma_treat_mean = 40\n    trauma_treat_var = 5\n\n    arrival_rate = 5\n\n    sim_duration = 600\n    number_of_runs = 100\n\n# Class representing patients coming in to the clinic.\nclass Patient:\n    '''\n    Class defining details for a patient entity\n    '''\n    def __init__(self, p_id):\n        '''\n        Constructor method\n\n        Params:\n        -----\n        identifier: int\n            a numeric identifier for the patient.\n        '''\n        self.identifier = p_id\n        self.arrival = -np.inf\n        self.wait_treat = -np.inf\n        self.total_time = -np.inf\n        self.treat_duration = -np.inf\n\n# Class representing our model of the clinic.\nclass Model:\n    '''\n    Simulates the simplest minor treatment process for a patient\n\n    1. Arrive\n    2. Examined/treated by nurse when one available\n    3. Discharged\n    '''\n    # Constructor to set up the model for a run.  We pass in a run number when\n    # we create a new model.\n    def __init__(self, run_number):\n        # Create a SimPy environment in which everything will live\n        self.env = simpy.Environment()\n\n        self.event_log = []\n\n        # Create a patient counter (which we'll use as a patient ID)\n        self.patient_counter = 0\n\n        self.patients = []\n\n        # Create our resources\n        self.init_resources()\n\n        # Store the passed in run number\n        self.run_number = run_number\n\n        # Create a new Pandas DataFrame that will store some results against\n        # the patient ID (which we'll use as the index).\n        self.results_df = pd.DataFrame()\n        self.results_df[\"Patient ID\"] = [1]\n        self.results_df[\"Queue Time Cubicle\"] = [0.0]\n        self.results_df[\"Time with Nurse\"] = [0.0]\n        self.results_df.set_index(\"Patient ID\", inplace=True)\n\n        # Create an attribute to store the mean queuing times across this run of\n        # the model\n        self.mean_q_time_cubicle = 0\n\n        self.patient_inter_arrival_dist = Exponential(mean = g.arrival_rate,\n                                                      random_seed = self.run_number*g.random_number_set)\n        self.treat_dist = Lognormal(mean = g.trauma_treat_mean,\n                                    stdev = g.trauma_treat_var,\n                                    random_seed = self.run_number*g.random_number_set)\n\n    def init_resources(self):\n        '''\n        Init the number of resources\n        and store in the arguments container object\n\n        Resource list:\n            1. Nurses/treatment bays (same thing in this model)\n\n        '''\n        self.treatment_cubicles = simpy.Store(self.env)\n\n        populate_store(num_resources=g.n_cubicles,\n                       simpy_store=self.treatment_cubicles,\n                       sim_env=self.env)\n\n        # for i in range(g.n_cubicles):\n        #     self.treatment_cubicles.put(\n        #         CustomResource(\n        #             self.env,\n        #             capacity=1,\n        #             id_attribute = i+1)\n        #         )\n\n    # A generator function that represents the DES generator for patient\n    # arrivals\n    def generator_patient_arrivals(self):\n        # We use an infinite loop here to keep doing this indefinitely whilst\n        # the simulation runs\n        while True:\n            # Increment the patient counter by 1 (this means our first patient\n            # will have an ID of 1)\n            self.patient_counter += 1\n\n            # Create a new patient - an instance of the Patient Class we\n            # defined above.  Remember, we pass in the ID when creating a\n            # patient - so here we pass the patient counter to use as the ID.\n            p = Patient(self.patient_counter)\n\n            # Store patient in list for later easy access\n            self.patients.append(p)\n\n            # Tell SimPy to start up the attend_clinic generator function with\n            # this patient (the generator function that will model the\n            # patient's journey through the system)\n            self.env.process(self.attend_clinic(p))\n\n            # Randomly sample the time to the next patient arriving.  Here, we\n            # sample from an exponential distribution (common for inter-arrival\n            # times), and pass in a lambda value of 1 / mean.  The mean\n            # inter-arrival time is stored in the g class.\n            sampled_inter = self.patient_inter_arrival_dist.sample()\n\n            # Freeze this instance of this function in place until the\n            # inter-arrival time we sampled above has elapsed.  Note - time in\n            # SimPy progresses in \"Time Units\", which can represent anything\n            # you like (just make sure you're consistent within the model)\n            yield self.env.timeout(sampled_inter)\n\n    # A generator function that represents the pathway for a patient going\n    # through the clinic.\n    # The patient object is passed in to the generator function so we can\n    # extract information from / record information to it\n    def attend_clinic(self, patient):\n        self.arrival = self.env.now\n        self.event_log.append(\n            {'patient': patient.identifier,\n             'pathway': 'Simplest',\n             'event_type': 'arrival_departure',\n             'event': 'arrival',\n             'time': self.env.now}\n        )\n\n        # request examination resource\n        start_wait = self.env.now\n        self.event_log.append(\n            {'patient': patient.identifier,\n             'pathway': 'Simplest',\n             'event': 'treatment_wait_begins',\n             'event_type': 'queue',\n             'time': self.env.now}\n        )\n\n        # Seize a treatment resource when available\n        treatment_resource = yield self.treatment_cubicles.get()\n\n        # record the waiting time for registration\n        self.wait_treat = self.env.now - start_wait\n        self.event_log.append(\n            {'patient': patient.identifier,\n                'pathway': 'Simplest',\n                'event': 'treatment_begins',\n                'event_type': 'resource_use',\n                'time': self.env.now,\n                'resource_id': treatment_resource.id_attribute\n                }\n        )\n\n        # sample treatment duration\n        self.treat_duration = self.treat_dist.sample()\n        yield self.env.timeout(self.treat_duration)\n\n        self.event_log.append(\n            {'patient': patient.identifier,\n                'pathway': 'Simplest',\n                'event': 'treatment_complete',\n                'event_type': 'resource_use_end',\n                'time': self.env.now,\n                'resource_id': treatment_resource.id_attribute}\n        )\n\n        # Resource is no longer in use, so put it back in\n        self.treatment_cubicles.put(treatment_resource)\n\n        # total time in system\n        self.total_time = self.env.now - self.arrival\n        self.event_log.append(\n            {'patient': patient.identifier,\n            'pathway': 'Simplest',\n            'event': 'depart',\n            'event_type': 'arrival_departure',\n            'time': self.env.now}\n        )\n\n\n    # This method calculates results over a single run.  Here we just calculate\n    # a mean, but in real world models you'd probably want to calculate more.\n    def calculate_run_results(self):\n        # Take the mean of the queuing times across patients in this run of the\n        # model.\n        self.mean_q_time_cubicle = self.results_df[\"Queue Time Cubicle\"].mean()\n\n    # The run method starts up the DES entity generators, runs the simulation,\n    # and in turns calls anything we need to generate results for the run\n    def run(self):\n        # Start up our DES entity generators that create new patients.  We've\n        # only got one in this model, but we'd need to do this for each one if\n        # we had multiple generators.\n        self.env.process(self.generator_patient_arrivals())\n\n        # Run the model for the duration specified in g class\n        self.env.run(until=g.sim_duration)\n\n        # Now the simulation run has finished, call the method that calculates\n        # run results\n        self.calculate_run_results()\n\n        self.event_log = pd.DataFrame(self.event_log)\n\n        self.event_log[\"run\"] = self.run_number\n\n        return {'results': self.results_df, 'event_log': self.event_log}\n\n# Class representing a Trial for our simulation - a batch of simulation runs.\nclass Trial:\n    # The constructor sets up a pandas dataframe that will store the key\n    # results from each run against run number, with run number as the index.\n    def  __init__(self):\n        self.df_trial_results = pd.DataFrame()\n        self.df_trial_results[\"Run Number\"] = [0]\n        self.df_trial_results[\"Arrivals\"] = [0]\n        self.df_trial_results[\"Mean Queue Time Cubicle\"] = [0.0]\n        self.df_trial_results.set_index(\"Run Number\", inplace=True)\n\n        self.all_event_logs = []\n\n    # Method to run a trial\n    def run_trial(self):\n        print(f\"{g.n_cubicles} nurses\")\n        print(\"\") ## Print a blank line\n\n        # Run the simulation for the number of runs specified in g class.\n        # For each run, we create a new instance of the Model class and call its\n        # run method, which sets everything else in motion.  Once the run has\n        # completed, we grab out the stored run results (just mean queuing time\n        # here) and store it against the run number in the trial results\n        # dataframe.\n        for run in range(g.number_of_runs):\n            random.seed(run)\n\n            my_model = Model(run)\n            model_outputs = my_model.run()\n            patient_level_results = model_outputs[\"results\"]\n            event_log = model_outputs[\"event_log\"]\n\n            self.df_trial_results.loc[run] = [\n                len(patient_level_results),\n                my_model.mean_q_time_cubicle,\n            ]\n\n            # print(event_log)\n\n            self.all_event_logs.append(event_log)\n\n        self.all_event_logs = pd.concat(self.all_event_logs)\n\n\n\n\n\nmy_trial = Trial()\n\nmy_trial.run_trial()\n\nsingle_run_event_log_df = my_trial.all_event_logs[my_trial.all_event_logs['run']==1]\n\nanimate_activity_log(\n        event_log=single_run_event_log_df,\n        event_position_df= event_position_df,\n        scenario=g(), # Use an instance of the g class as our scenario\n        limit_duration=g.sim_duration,\n        debug_mode=True, # Turn on logging messages\n        setup_mode=True, # Turn on axis units - this can help with honing your event_position_df\n        every_x_time_units=1,\n        include_play_button=True,\n        icon_and_text_size=20,\n        gap_between_entities=6,\n        gap_between_rows=25,\n        plotly_height=700,\n        frame_duration=200,\n        plotly_width=1200,\n        override_x_max=300,\n        override_y_max=500,\n        wrap_queues_at=25,\n        step_snapshot_max=125,\n        time_display_units=\"dhm\",\n        display_stage_labels=True # display our Label column from our event_position_df\n    )\n\n3 nurses\n\nAnimation function called at 15:17:04\nIteration through minute-by-minute logs complete 15:17:07\nSnapshot df concatenation complete at 15:17:07\nReshaped animation dataframe finished construction at 15:17:07\nPlacement dataframe finished construction at 15:17:07\nOutput animation generation complete at 15:17:09\nTotal Time Elapsed: 4.72 seconds\n\n\n                                                \n\n\nWhen you have finished tweaking the layout, you can further enhance your output.\n\nanimate_activity_log(\n        event_log=single_run_event_log_df,\n        event_position_df= event_position_df,\n        scenario=g(),\n        limit_duration=g.sim_duration,\n        debug_mode=False, # Turn off logging messages\n        setup_mode=False, # Turn off axis units\n        every_x_time_units=1,\n        include_play_button=True,\n        icon_and_text_size=20,\n        gap_between_entities=6,\n        gap_between_rows=25,\n        plotly_height=700,\n        frame_duration=200,\n        plotly_width=1200,\n        override_x_max=300,\n        override_y_max=500,\n        wrap_queues_at=25,\n        step_snapshot_max=125,\n        time_display_units=\"dhm\",\n        display_stage_labels=False, # hide our Label column from our event_position_df\n        # Add a local or web-hosted image as our background\n        add_background_image=\"https://raw.githubusercontent.com/Bergam0t/vidigi/refs/heads/main/examples/example_1_simplest_case/Simplest%20Model%20Background%20Image%20-%20Horizontal%20Layout.drawio.png\")\n\n                                                \n\n\nWe can then rerun our animation, passing in different parameters - though make sure to rerun your trial if you do so!\nHere, we will increase the number of cubicles from 3 to 7 and see the impact this has on the queue size.\n\ng.n_cubicles = 7 \n\nmy_trial = Trial()\n\nmy_trial.run_trial()\n\nsingle_run_event_log_df = my_trial.all_event_logs[my_trial.all_event_logs['run']==1]\n\nanimate_activity_log(\n        event_log=single_run_event_log_df,\n        event_position_df= event_position_df,\n        scenario=g(),\n        limit_duration=g.sim_duration,\n        debug_mode=False, # Turn off logging messages\n        setup_mode=False, # Turn off axis units\n        every_x_time_units=1,\n        include_play_button=True,\n        icon_and_text_size=20,\n        gap_between_entities=6,\n        gap_between_rows=25,\n        plotly_height=700,\n        frame_duration=200,\n        plotly_width=1200,\n        override_x_max=300,\n        override_y_max=500,\n        wrap_queues_at=25,\n        step_snapshot_max=125,\n        time_display_units=\"dhm\",\n        display_stage_labels=False, # hide our Label column from our event_position_df\n        # Add a local or web-hosted image as our background\n        add_background_image=\"https://raw.githubusercontent.com/Bergam0t/vidigi/refs/heads/main/examples/example_1_simplest_case/Simplest%20Model%20Background%20Image%20-%20Horizontal%20Layout.drawio.png\")\n\n7 nurses",
    "crumbs": [
      "Walkthroughs",
      "Adding Vidigi to a Simple simpy Model (HSMA Structure)"
    ]
  },
  {
    "objectID": "reference/utils.populate_store.html",
    "href": "reference/utils.populate_store.html",
    "title": "utils.populate_store",
    "section": "",
    "text": "utils.populate_store(num_resources, simpy_store, sim_env)\nPopulate a SimPy Store (or VidigiPriorityStore) with CustomResource objects.\nThis function creates a specified number of CustomResource objects and adds them to a SimPy Store or VidigiPriorityStore.\nEach CustomResource is initialized with a capacity of 1 and a unique ID attribute, which is crucial for animation functions where you wish to show an individual entity consistently using the same resource.\nIf using VidigiPriorityStore, you will need to pass the relevant priority in to the .get() argument when pulling a resource out of the store.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nnum_resources\nint\nThe number of CustomResource objects to create and add to the store.\nrequired\n\n\nsimpy_store\nsimpy.Store or vidigi.utils.VidigiPriorityStore\nThe SimPy Store object to populate with resources.\nrequired\n\n\nsim_env\nsimpy.Environment\nThe SimPy environment in which the resources and store exist.\nrequired\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nNone\n\n\n\n\n\n\n\n\nEach CustomResource is created with a capacity of 1.\nThe ID attribute of each CustomResource is set to its index in the creation loop plus one, ensuring unique IDs starting from 1.\nThis function is typically used to initialize a pool of resources at the start of a simulation.\n\n\n\n\n&gt;&gt;&gt; import simpy\n&gt;&gt;&gt; env = simpy.Environment()\n&gt;&gt;&gt; resource_store = simpy.Store(env)\n&gt;&gt;&gt; populate_store(5, resource_store, env)\n&gt;&gt;&gt; len(resource_store.items)  # The store now contains 5 CustomResource objects\n5",
    "crumbs": [
      "Reference",
      "Simpy Utility Functions and Classes",
      "utils.populate_store"
    ]
  },
  {
    "objectID": "reference/utils.populate_store.html#parameters",
    "href": "reference/utils.populate_store.html#parameters",
    "title": "utils.populate_store",
    "section": "",
    "text": "Name\nType\nDescription\nDefault\n\n\n\n\nnum_resources\nint\nThe number of CustomResource objects to create and add to the store.\nrequired\n\n\nsimpy_store\nsimpy.Store or vidigi.utils.VidigiPriorityStore\nThe SimPy Store object to populate with resources.\nrequired\n\n\nsim_env\nsimpy.Environment\nThe SimPy environment in which the resources and store exist.\nrequired",
    "crumbs": [
      "Reference",
      "Simpy Utility Functions and Classes",
      "utils.populate_store"
    ]
  },
  {
    "objectID": "reference/utils.populate_store.html#returns",
    "href": "reference/utils.populate_store.html#returns",
    "title": "utils.populate_store",
    "section": "",
    "text": "Name\nType\nDescription\n\n\n\n\n\nNone",
    "crumbs": [
      "Reference",
      "Simpy Utility Functions and Classes",
      "utils.populate_store"
    ]
  },
  {
    "objectID": "reference/utils.populate_store.html#notes",
    "href": "reference/utils.populate_store.html#notes",
    "title": "utils.populate_store",
    "section": "",
    "text": "Each CustomResource is created with a capacity of 1.\nThe ID attribute of each CustomResource is set to its index in the creation loop plus one, ensuring unique IDs starting from 1.\nThis function is typically used to initialize a pool of resources at the start of a simulation.",
    "crumbs": [
      "Reference",
      "Simpy Utility Functions and Classes",
      "utils.populate_store"
    ]
  },
  {
    "objectID": "reference/utils.populate_store.html#examples",
    "href": "reference/utils.populate_store.html#examples",
    "title": "utils.populate_store",
    "section": "",
    "text": "&gt;&gt;&gt; import simpy\n&gt;&gt;&gt; env = simpy.Environment()\n&gt;&gt;&gt; resource_store = simpy.Store(env)\n&gt;&gt;&gt; populate_store(5, resource_store, env)\n&gt;&gt;&gt; len(resource_store.items)  # The store now contains 5 CustomResource objects\n5",
    "crumbs": [
      "Reference",
      "Simpy Utility Functions and Classes",
      "utils.populate_store"
    ]
  },
  {
    "objectID": "reference/utils.CustomResource.html",
    "href": "reference/utils.CustomResource.html",
    "title": "utils.CustomResource",
    "section": "",
    "text": "utils.CustomResource(self, env, capacity, id_attribute=None)\nA custom resource class that extends simpy.Resource with an additional ID attribute.\nThis class allows for more detailed tracking and management of resources in a simulation by adding an ID attribute to each resource instance.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nenv\nsimpy.Environment\nThe SimPy environment in which this resource exists.\nrequired\n\n\ncapacity\nint\nThe capacity of the resource (how many units can be in use simultaneously).\nrequired\n\n\nid_attribute\nany\nAn identifier for the resource (default is None).\nNone\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nid_attribute\nany\nAn identifier for the resource, which can be used for custom tracking or logic.\n\n\n\n\n\n\nThis class inherits from simpy.Resource and overrides the request and release methods to allow for custom handling of the id_attribute. The actual implementation of ID assignment or reset logic should be added by the user as needed.\n\n\n\nenv = simpy.Environment()\ncustom_resource = CustomResource(env, capacity=1, id_attribute=\"Resource_1\")\ndef process(env, resource):\n    with resource.request() as req:\n        yield req\n        print(f\"Using resource with ID: {resource.id_attribute}\")\n        yield env.timeout(1)\nenv.process(process(env, custom_resource))\nenv.run()\nUsing resource with ID: Resource_1\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nrelease\nRelease the resource.\n\n\nrequest\nRequest the resource.\n\n\n\n\n\nutils.CustomResource.release(*args, **kwargs)\nRelease the resource.\nThis method can be customized to handle the ID attribute when a release is made. Currently, it simply calls the parent class’s release method.\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nNone\n\n\n\n\n\n\n\n\nutils.CustomResource.request(*args, **kwargs)\nRequest the resource.\nThis method can be customized to handle the ID attribute when a request is made. Currently, it simply calls the parent class’s request method.\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nsimpy.events.Request\nA SimPy request event.",
    "crumbs": [
      "Reference",
      "Simpy Utility Functions and Classes",
      "utils.CustomResource"
    ]
  },
  {
    "objectID": "reference/utils.CustomResource.html#parameters",
    "href": "reference/utils.CustomResource.html#parameters",
    "title": "utils.CustomResource",
    "section": "",
    "text": "Name\nType\nDescription\nDefault\n\n\n\n\nenv\nsimpy.Environment\nThe SimPy environment in which this resource exists.\nrequired\n\n\ncapacity\nint\nThe capacity of the resource (how many units can be in use simultaneously).\nrequired\n\n\nid_attribute\nany\nAn identifier for the resource (default is None).\nNone",
    "crumbs": [
      "Reference",
      "Simpy Utility Functions and Classes",
      "utils.CustomResource"
    ]
  },
  {
    "objectID": "reference/utils.CustomResource.html#attributes",
    "href": "reference/utils.CustomResource.html#attributes",
    "title": "utils.CustomResource",
    "section": "",
    "text": "Name\nType\nDescription\n\n\n\n\nid_attribute\nany\nAn identifier for the resource, which can be used for custom tracking or logic.",
    "crumbs": [
      "Reference",
      "Simpy Utility Functions and Classes",
      "utils.CustomResource"
    ]
  },
  {
    "objectID": "reference/utils.CustomResource.html#notes",
    "href": "reference/utils.CustomResource.html#notes",
    "title": "utils.CustomResource",
    "section": "",
    "text": "This class inherits from simpy.Resource and overrides the request and release methods to allow for custom handling of the id_attribute. The actual implementation of ID assignment or reset logic should be added by the user as needed.",
    "crumbs": [
      "Reference",
      "Simpy Utility Functions and Classes",
      "utils.CustomResource"
    ]
  },
  {
    "objectID": "reference/utils.CustomResource.html#examples",
    "href": "reference/utils.CustomResource.html#examples",
    "title": "utils.CustomResource",
    "section": "",
    "text": "env = simpy.Environment()\ncustom_resource = CustomResource(env, capacity=1, id_attribute=\"Resource_1\")\ndef process(env, resource):\n    with resource.request() as req:\n        yield req\n        print(f\"Using resource with ID: {resource.id_attribute}\")\n        yield env.timeout(1)\nenv.process(process(env, custom_resource))\nenv.run()\nUsing resource with ID: Resource_1",
    "crumbs": [
      "Reference",
      "Simpy Utility Functions and Classes",
      "utils.CustomResource"
    ]
  },
  {
    "objectID": "reference/utils.CustomResource.html#methods",
    "href": "reference/utils.CustomResource.html#methods",
    "title": "utils.CustomResource",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nrelease\nRelease the resource.\n\n\nrequest\nRequest the resource.\n\n\n\n\n\nutils.CustomResource.release(*args, **kwargs)\nRelease the resource.\nThis method can be customized to handle the ID attribute when a release is made. Currently, it simply calls the parent class’s release method.\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nNone\n\n\n\n\n\n\n\n\nutils.CustomResource.request(*args, **kwargs)\nRequest the resource.\nThis method can be customized to handle the ID attribute when a request is made. Currently, it simply calls the parent class’s request method.\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nsimpy.events.Request\nA SimPy request event.",
    "crumbs": [
      "Reference",
      "Simpy Utility Functions and Classes",
      "utils.CustomResource"
    ]
  },
  {
    "objectID": "reference/prep.generate_animation_df.html",
    "href": "reference/prep.generate_animation_df.html",
    "title": "prep.generate_animation_df",
    "section": "",
    "text": "prep.generate_animation_df(\n    full_patient_df,\n    event_position_df,\n    wrap_queues_at=20,\n    wrap_resources_at=20,\n    step_snapshot_max=50,\n    gap_between_entities=10,\n    gap_between_resources=10,\n    gap_between_rows=30,\n    debug_mode=False,\n    custom_entity_icon_list=None,\n)\nGenerate a DataFrame for animation purposes by adding position information to patient data.\nThis function takes patient event data and adds positional information for visualization, handling both queuing and resource use events.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nfull_patient_df\npd.DataFrame\nOutput of reshape_for_animation(), containing patient event data.\nrequired\n\n\nevent_position_df\npd.DataFrame\nDataFrame with columns ‘event’, ‘x’, and ‘y’, specifying initial positions for each event type.\nrequired\n\n\nwrap_queues_at\nint\nNumber of entities in a queue before wrapping to a new row (default is 20).\n20\n\n\nwrap_resources_at\nint\nNumber of resources to show before wrapping to a new row (default is 20).\n20\n\n\nstep_snapshot_max\nint\nMaximum number of patients to show in each snapshot (default is 50).\n50\n\n\ngap_between_entities\nint\nHorizontal spacing between entities in pixels (default is 10).\n10\n\n\ngap_between_resources\nint\nHorizontal spacing between resources in pixels (default is 10).\n10\n\n\ngap_between_rows\nint\nVertical spacing between rows in pixels (default is 30).\n30\n\n\ndebug_mode\nbool\nIf True, print debug information during processing (default is False).\nFalse\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\npd.DataFrame\nA DataFrame with added columns for x and y positions, and icons for each patient.\n\n\n\n\n\n\n\nThe function handles both queuing and resource use events differently.\nIt assigns unique icons to patients for visualization.\nQueues can be wrapped to multiple rows if they exceed a specified length.\nThe function adds a visual indicator for additional patients when exceeding the snapshot limit.\n\n\n\n\n\nWrite a test to ensure that no patient ID appears in multiple places at a single minute.",
    "crumbs": [
      "Reference",
      "Step-By-Step Functions",
      "prep.generate_animation_df"
    ]
  },
  {
    "objectID": "reference/prep.generate_animation_df.html#parameters",
    "href": "reference/prep.generate_animation_df.html#parameters",
    "title": "prep.generate_animation_df",
    "section": "",
    "text": "Name\nType\nDescription\nDefault\n\n\n\n\nfull_patient_df\npd.DataFrame\nOutput of reshape_for_animation(), containing patient event data.\nrequired\n\n\nevent_position_df\npd.DataFrame\nDataFrame with columns ‘event’, ‘x’, and ‘y’, specifying initial positions for each event type.\nrequired\n\n\nwrap_queues_at\nint\nNumber of entities in a queue before wrapping to a new row (default is 20).\n20\n\n\nwrap_resources_at\nint\nNumber of resources to show before wrapping to a new row (default is 20).\n20\n\n\nstep_snapshot_max\nint\nMaximum number of patients to show in each snapshot (default is 50).\n50\n\n\ngap_between_entities\nint\nHorizontal spacing between entities in pixels (default is 10).\n10\n\n\ngap_between_resources\nint\nHorizontal spacing between resources in pixels (default is 10).\n10\n\n\ngap_between_rows\nint\nVertical spacing between rows in pixels (default is 30).\n30\n\n\ndebug_mode\nbool\nIf True, print debug information during processing (default is False).\nFalse",
    "crumbs": [
      "Reference",
      "Step-By-Step Functions",
      "prep.generate_animation_df"
    ]
  },
  {
    "objectID": "reference/prep.generate_animation_df.html#returns",
    "href": "reference/prep.generate_animation_df.html#returns",
    "title": "prep.generate_animation_df",
    "section": "",
    "text": "Name\nType\nDescription\n\n\n\n\n\npd.DataFrame\nA DataFrame with added columns for x and y positions, and icons for each patient.",
    "crumbs": [
      "Reference",
      "Step-By-Step Functions",
      "prep.generate_animation_df"
    ]
  },
  {
    "objectID": "reference/prep.generate_animation_df.html#notes",
    "href": "reference/prep.generate_animation_df.html#notes",
    "title": "prep.generate_animation_df",
    "section": "",
    "text": "The function handles both queuing and resource use events differently.\nIt assigns unique icons to patients for visualization.\nQueues can be wrapped to multiple rows if they exceed a specified length.\nThe function adds a visual indicator for additional patients when exceeding the snapshot limit.",
    "crumbs": [
      "Reference",
      "Step-By-Step Functions",
      "prep.generate_animation_df"
    ]
  },
  {
    "objectID": "reference/prep.generate_animation_df.html#todo",
    "href": "reference/prep.generate_animation_df.html#todo",
    "title": "prep.generate_animation_df",
    "section": "",
    "text": "Write a test to ensure that no patient ID appears in multiple places at a single minute.",
    "crumbs": [
      "Reference",
      "Step-By-Step Functions",
      "prep.generate_animation_df"
    ]
  },
  {
    "objectID": "reference/animation.generate_animation.html",
    "href": "reference/animation.generate_animation.html",
    "title": "animation.generate_animation",
    "section": "",
    "text": "animation.generate_animation(\n    full_patient_df_plus_pos,\n    event_position_df,\n    scenario=None,\n    plotly_height=900,\n    plotly_width=None,\n    include_play_button=True,\n    add_background_image=None,\n    display_stage_labels=True,\n    icon_and_text_size=24,\n    override_x_max=None,\n    override_y_max=None,\n    time_display_units=None,\n    start_date=None,\n    resource_opacity=0.8,\n    custom_resource_icon=None,\n    wrap_resources_at=20,\n    gap_between_resources=10,\n    gap_between_rows=30,\n    setup_mode=False,\n    frame_duration=400,\n    frame_transition_duration=600,\n    debug_mode=False,\n)\nGenerate an animated visualization of patient flow through a system.\nThis function creates an interactive Plotly animation based on patient data and event positions.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nfull_patient_df_plus_pos\npd.DataFrame\nDataFrame containing patient data with position information. This will be the output of passing an event log through the reshape_for_animations() and generate_animation_df() functions\nrequired\n\n\nevent_position_df\npd.DataFrame\nDataFrame specifying the positions of different events.\nrequired\n\n\nscenario\nobject\nObject containing attributes for resource counts at different steps.\nNone\n\n\nplotly_height\nint\nHeight of the Plotly figure in pixels (default is 900).\n900\n\n\nplotly_width\nint\nWidth of the Plotly figure in pixels (default is None).\nNone\n\n\ninclude_play_button\nbool\nWhether to include a play button in the animation (default is True).\nTrue\n\n\nadd_background_image\nstr\nPath to a background image file to add to the animation (default is None).\nNone\n\n\ndisplay_stage_labels\nbool\nWhether to display labels for each stage (default is True).\nTrue\n\n\nicon_and_text_size\nint\nSize of icons and text in the animation (default is 24).\n24\n\n\noverride_x_max\nint\nOverride the maximum x-coordinate (default is None).\nNone\n\n\noverride_y_max\nint\nOverride the maximum y-coordinate (default is None).\nNone\n\n\ntime_display_units\nstr\nUnits for displaying time. Options are ‘dhm’ (days, hours, minutes), ‘d’ (days), or None (default).\nNone\n\n\nstart_date\nstr\nStart date for the animation in ‘YYYY-MM-DD’ format. Only used when time_display_units is ‘d’ (default is None).\nNone\n\n\nresource_opacity\nfloat\nOpacity of resource icons (default is 0.8).\n0.8\n\n\ncustom_resource_icon\nstr\nCustom icon to use for resources (default is None).\nNone\n\n\nwrap_resources_at\nint\nNumber of resources to show before wrapping to a new row (default is 20). If this has been set elsewhere, it is also important to set it in this function to ensure the visual indicators of the resources wrap in the same way the entities using those resources do.\n20\n\n\ngap_between_resources\nint\nSpacing between resources in pixels (default is 10).\n10\n\n\ngap_between_rows\nint\nVertical spacing between rows in pixels (default is 30).\n30\n\n\nsetup_mode\nbool\nWhether to run in setup mode, showing grid and tick marks (default is False).\nFalse\n\n\nframe_duration\nint\nDuration of each frame in milliseconds (default is 400).\n400\n\n\nframe_transition_duration\nint\nDuration of transition between frames in milliseconds (default is 600).\n600\n\n\ndebug_mode\nbool\nWhether to run in debug mode with additional output (default is False).\nFalse\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nplotly.graph_objs._figure.Figure\nAn animated Plotly figure object representing the patient flow.\n\n\n\n\n\n\n\nThe function uses Plotly Express to create an animated scatter plot.\nTime can be displayed as actual dates or as model time units.\nThe animation supports customization of icon sizes, resource representation, and animation speed.\nA background image can be added to provide context for the patient flow.\n\n\n\n\n&gt;&gt;&gt; animation = generate_animation(patient_df, event_positions, scenario,\n...                                time_display_units='dhm',\n...                                add_background_image='path/to/image.png')\n&gt;&gt;&gt; animation.show()",
    "crumbs": [
      "Reference",
      "Step-By-Step Functions",
      "animation.generate_animation"
    ]
  },
  {
    "objectID": "reference/animation.generate_animation.html#parameters",
    "href": "reference/animation.generate_animation.html#parameters",
    "title": "animation.generate_animation",
    "section": "",
    "text": "Name\nType\nDescription\nDefault\n\n\n\n\nfull_patient_df_plus_pos\npd.DataFrame\nDataFrame containing patient data with position information. This will be the output of passing an event log through the reshape_for_animations() and generate_animation_df() functions\nrequired\n\n\nevent_position_df\npd.DataFrame\nDataFrame specifying the positions of different events.\nrequired\n\n\nscenario\nobject\nObject containing attributes for resource counts at different steps.\nNone\n\n\nplotly_height\nint\nHeight of the Plotly figure in pixels (default is 900).\n900\n\n\nplotly_width\nint\nWidth of the Plotly figure in pixels (default is None).\nNone\n\n\ninclude_play_button\nbool\nWhether to include a play button in the animation (default is True).\nTrue\n\n\nadd_background_image\nstr\nPath to a background image file to add to the animation (default is None).\nNone\n\n\ndisplay_stage_labels\nbool\nWhether to display labels for each stage (default is True).\nTrue\n\n\nicon_and_text_size\nint\nSize of icons and text in the animation (default is 24).\n24\n\n\noverride_x_max\nint\nOverride the maximum x-coordinate (default is None).\nNone\n\n\noverride_y_max\nint\nOverride the maximum y-coordinate (default is None).\nNone\n\n\ntime_display_units\nstr\nUnits for displaying time. Options are ‘dhm’ (days, hours, minutes), ‘d’ (days), or None (default).\nNone\n\n\nstart_date\nstr\nStart date for the animation in ‘YYYY-MM-DD’ format. Only used when time_display_units is ‘d’ (default is None).\nNone\n\n\nresource_opacity\nfloat\nOpacity of resource icons (default is 0.8).\n0.8\n\n\ncustom_resource_icon\nstr\nCustom icon to use for resources (default is None).\nNone\n\n\nwrap_resources_at\nint\nNumber of resources to show before wrapping to a new row (default is 20). If this has been set elsewhere, it is also important to set it in this function to ensure the visual indicators of the resources wrap in the same way the entities using those resources do.\n20\n\n\ngap_between_resources\nint\nSpacing between resources in pixels (default is 10).\n10\n\n\ngap_between_rows\nint\nVertical spacing between rows in pixels (default is 30).\n30\n\n\nsetup_mode\nbool\nWhether to run in setup mode, showing grid and tick marks (default is False).\nFalse\n\n\nframe_duration\nint\nDuration of each frame in milliseconds (default is 400).\n400\n\n\nframe_transition_duration\nint\nDuration of transition between frames in milliseconds (default is 600).\n600\n\n\ndebug_mode\nbool\nWhether to run in debug mode with additional output (default is False).\nFalse",
    "crumbs": [
      "Reference",
      "Step-By-Step Functions",
      "animation.generate_animation"
    ]
  },
  {
    "objectID": "reference/animation.generate_animation.html#returns",
    "href": "reference/animation.generate_animation.html#returns",
    "title": "animation.generate_animation",
    "section": "",
    "text": "Name\nType\nDescription\n\n\n\n\n\nplotly.graph_objs._figure.Figure\nAn animated Plotly figure object representing the patient flow.",
    "crumbs": [
      "Reference",
      "Step-By-Step Functions",
      "animation.generate_animation"
    ]
  },
  {
    "objectID": "reference/animation.generate_animation.html#notes",
    "href": "reference/animation.generate_animation.html#notes",
    "title": "animation.generate_animation",
    "section": "",
    "text": "The function uses Plotly Express to create an animated scatter plot.\nTime can be displayed as actual dates or as model time units.\nThe animation supports customization of icon sizes, resource representation, and animation speed.\nA background image can be added to provide context for the patient flow.",
    "crumbs": [
      "Reference",
      "Step-By-Step Functions",
      "animation.generate_animation"
    ]
  },
  {
    "objectID": "reference/animation.generate_animation.html#examples",
    "href": "reference/animation.generate_animation.html#examples",
    "title": "animation.generate_animation",
    "section": "",
    "text": "&gt;&gt;&gt; animation = generate_animation(patient_df, event_positions, scenario,\n...                                time_display_units='dhm',\n...                                add_background_image='path/to/image.png')\n&gt;&gt;&gt; animation.show()",
    "crumbs": [
      "Reference",
      "Step-By-Step Functions",
      "animation.generate_animation"
    ]
  },
  {
    "objectID": "notes.html",
    "href": "notes.html",
    "title": "4. Iterating through the logs to make a minute-by-minute picture of the position of every patient (or any desired interval)",
    "section": "",
    "text": "Current mechanism\nIn short, the final plot is an animated plotly scatterplot.\nIn theory, there’s nothing to stop it using an alternative mode of action (e.g. svg), but one benefit of plotly is that it nicely deals with the intermediate paths of patients. It is also available in both Python and R with minimal changes and has extensive compatability with other tools - e.g. Streamlit, Dash.\nThere are a couple of key steps to setting up the visualisation 1. Adding logging steps to the model 2. Swapping the use of resources for simpy stores containing resources 3. Creating an object that stores resources - a ‘scenario’ object - which then informs the number of resources displayed 4. Iterating through the logs to make a minute-by-minute picture of the position of every patient (or any desired interval) 5. Using Plotly to display these logs"
  },
  {
    "objectID": "notes.html#adding-logging-steps-to-the-model",
    "href": "notes.html#adding-logging-steps-to-the-model",
    "title": "4. Iterating through the logs to make a minute-by-minute picture of the position of every patient (or any desired interval)",
    "section": "1. Adding logging steps to the model",
    "text": "1. Adding logging steps to the model\nFive key classes of events need to be logged for every patient: - arrival - queue - resource use start - resource use end (could possibly be removed) - depart\nSimple improvements required include applying consistency to naming (e.g. arrival and departure, arrive and depart, not a mixture of the two)\nAt present, five to six things are recorded per log. ‘Pathway’ could potentially be removed.\nThis whole structure could be rewritten to be significantly less verbose. It is written like this at present because of the ease of transforming this structure of dictionary to a dataframe and the flexibility of the structure, but exploring alternatives like key:value pairs of event:time could be explored.\nCurrenly, the key logs take the following format\nArrival:\nself.full_event_log.append({\n    'patient': self.identifier,\n    'pathway': 'Simplest',\n    'event_type': 'arrival_departure',\n    'event': 'arrival',\n    'time': self.env.now\n})\nQueueing:\nself.full_event_log.append({\n    'patient': self.identifier,\n    'pathway': 'Simplest',\n    'event': 'treatment_wait_begins',\n    'event_type': 'queue',\n    'time': self.env.now\n})\nResource Use Start:\nself.full_event_log.append({\n    'patient': self.identifier,\n    'pathway': 'Simplest',\n    'event': 'treatment_begins',\n    'event_type': 'resource_use',\n    'time': self.env.now,\n    'resource_id': treatment_resource.id_attribute\n})\nResource Use End:\nself.full_event_log.append({\n    'patient': self.identifier,\n    'pathway': 'Simplest',\n    'event': 'treatment_complete',\n    'event_type': 'resource_use_end',\n    'time': self.env.now,\n    'resource_id': treatment_resource.id_attribute\n})\nDeparture:\nself.full_event_log.append({\n    'patient': self.identifier,\n    'pathway': 'Simplest',\n    'event': 'depart',\n    'event_type': 'arrival_departure',\n    'time': self.env.now\n})"
  },
  {
    "objectID": "notes.html#swapping-the-use-of-resources-for-simpy-stores-containing-resources",
    "href": "notes.html#swapping-the-use-of-resources-for-simpy-stores-containing-resources",
    "title": "4. Iterating through the logs to make a minute-by-minute picture of the position of every patient (or any desired interval)",
    "section": "2. Swapping the use of resources for simpy stores containing resources",
    "text": "2. Swapping the use of resources for simpy stores containing resources\nWhen a resource is in use, we need to be able to show a single entity consistently hogging the same resource throughout the full time they are using it.\nSimpy resources do not inherently have any ID attribute. After exploring options like monkey patching the resource class, a better alternative seemed to be using a simpy store - which does have an ID - instead of a straight resource.\nWithout this ID attribute, the default logic used to move entities through the steps results in them visually behaving like a queue, which makes it hard to understand how long someone has been using a resource for and is visually confusing.\nFortunately the code changes required are minimal. We initialise the store, then use a loop to create as many resources within that store as required.\ndef init_resources(self):\n    '''\n    Init the number of resources\n    and store in the arguments container object\n\n    Resource list:\n        1. Nurses/treatment bays (same thing in this model)\n\n    '''\n    self.args.treatment = simpy.Store(self.env)\n\n    for i in range(self.args.n_cubicles_1):\n        self.args.treatment.put(\n            CustomResource(\n                self.env,\n                capacity=1,\n                id_attribute = i+1)\n            )\nUse of the resource then becomes\n# Seize a treatment resource when available\ntreatment_resource = yield self.args.treatment.get()\nWhen the timeout has elapsed, we then use the following code.\n# Resource is no longer in use, so put it back in\nself.args.treatment.put(treatment_resource)\nThis has additional benefits of making it easier to monitor the use of individual resources.\nOne thing that has been noticed is that the resources seem to be cycled through in order. For example, if you have 4 resources and all are available, but the last resource to be in use was resource 2, resource 3 will be seized the next time someone requires a resource. This may not be entirely realistic, and code to ‘shake up’ the resources after use may be worth exploring."
  },
  {
    "objectID": "notes.html#creating-an-object-that-stores-resources---a-scenario-object---which-then-informs-the-number-of-resources-displayed",
    "href": "notes.html#creating-an-object-that-stores-resources---a-scenario-object---which-then-informs-the-number-of-resources-displayed",
    "title": "4. Iterating through the logs to make a minute-by-minute picture of the position of every patient (or any desired interval)",
    "section": "3. Creating an object that stores resources - a ‘scenario’ object - which then informs the number of resources displayed",
    "text": "3. Creating an object that stores resources - a ‘scenario’ object - which then informs the number of resources displayed\nAt present this part of the code expects a scenario object. This could be changed to - expect a dictionary instead - work with either a scenario or dictionary object (maybe if the route of expanding TM’s approach to simpy modelling into an opinionated framework)\nIf going with the first option, the scenario class used in TM’s work routinely could be expanded to include a method to export the required data to a dictionary format.\n\nevents_with_resources = event_position_df[event_position_df['resource'].notnull()].copy()\nevents_with_resources['resource_count'] = events_with_resources['resource'].apply(lambda x: getattr(scenario, x))\n\nevents_with_resources = events_with_resources.join(events_with_resources.apply(\n    lambda r: pd.Series({'x_final': [r['x']-(10*(i+1)) for i in range(r['resource_count'])]}), axis=1).explode('x_final'),\n    how='right')\n\nfig.add_trace(go.Scatter(\n    x=events_with_resources['x_final'].to_list(),\n    # Place these slightly below the y position for each entity\n    # that will be using the resource\n    y=[i-10 for i in events_with_resources['y'].to_list()],\n    mode=\"markers\",\n    # Define what the marker will look like\n    marker=dict(\n        color='LightSkyBlue',\n        size=15),\n    opacity=0.8,\n    hoverinfo='none'\n))\n\nThe function reshape_for_animations()"
  },
  {
    "objectID": "notes.html#using-plotly-to-display-these-logs",
    "href": "notes.html#using-plotly-to-display-these-logs",
    "title": "4. Iterating through the logs to make a minute-by-minute picture of the position of every patient (or any desired interval)",
    "section": "5. Using Plotly to display these logs",
    "text": "5. Using Plotly to display these logs\nThe function animate_activity_log currently takes 3 mandatory parameters: - full_patient_df - event_position_df - scenario\nfull_patient_df is the output of the function reshape_for_animations\nThe graph is a plotly scatterplot. The initial animated plot is created using plotly express, with additional static layers added afterwards.\nEach individual is a scatter point. The actual points are fully transparent, and what we see is a text label - the emoji.\nA list of any length of emojis is required. This will then be joined with a distinct patient table to provide a list of patients."
  },
  {
    "objectID": "notes.html#already-created",
    "href": "notes.html#already-created",
    "title": "4. Iterating through the logs to make a minute-by-minute picture of the position of every patient (or any desired interval)",
    "section": "Already created",
    "text": "Already created\n\nSimple pathway (units: minutes)\nPathway with branching and optional steps (units: weeks)"
  },
  {
    "objectID": "notes.html#not-yet-created---additional-features-possibly-required",
    "href": "notes.html#not-yet-created---additional-features-possibly-required",
    "title": "4. Iterating through the logs to make a minute-by-minute picture of the position of every patient (or any desired interval)",
    "section": "Not yet created - additional features possibly required",
    "text": "Not yet created - additional features possibly required\n\nSimple pathway (units: days, weeks)\nResource numbers that change at different points of the day\nPrioritised queueing\nShared resources\nMultiple resources required for a step (e.g. doctor + cubicle - how to display this?)\nReneging\nJockeying\nBalking"
  },
  {
    "objectID": "notes.html#known-areas-for-attention",
    "href": "notes.html#known-areas-for-attention",
    "title": "4. Iterating through the logs to make a minute-by-minute picture of the position of every patient (or any desired interval)",
    "section": "Known areas for attention",
    "text": "Known areas for attention\n\nThe code is not written in an object oriented manner.\nThere’s a bug in the wrapping code that results in queues building out in a diagonal manner (shifted 1 to the left) from the 3rd row onwards (2nd row counts to 11 instead of 10, and then subsequent rows correctly include 10 but start too far over)"
  },
  {
    "objectID": "notes.html#required-enhancements",
    "href": "notes.html#required-enhancements",
    "title": "4. Iterating through the logs to make a minute-by-minute picture of the position of every patient (or any desired interval)",
    "section": "Required enhancements",
    "text": "Required enhancements\n\nAt present, the queue of users will continue to grow indefinitely until it leaves the boundary."
  },
  {
    "objectID": "notes.html#friction-points",
    "href": "notes.html#friction-points",
    "title": "4. Iterating through the logs to make a minute-by-minute picture of the position of every patient (or any desired interval)",
    "section": "Friction points",
    "text": "Friction points\n\nSetting up the background image can be a fiddly process"
  },
  {
    "objectID": "notes.html#other-limitations",
    "href": "notes.html#other-limitations",
    "title": "4. Iterating through the logs to make a minute-by-minute picture of the position of every patient (or any desired interval)",
    "section": "Other limitations",
    "text": "Other limitations\n\nBy avoiding emojis that were released after v12.0 of the emoji standard (released in early 2019), we can ensure compatability with most major OSs. Windows 10 has not been updated past this point. However, due to the nature of emojis, we cannot absolutely ensure full compatability across all systems."
  },
  {
    "objectID": "notes.html#concerns",
    "href": "notes.html#concerns",
    "title": "4. Iterating through the logs to make a minute-by-minute picture of the position of every patient (or any desired interval)",
    "section": "Concerns",
    "text": "Concerns\n\nCurrently, logging can cope with ~5 minute snapshots for 5 days of logs in a system that has ~10-60 people in the system at any given point in time. This results in a self-contained plot of ~20mb when exported (for comparison, a self-contained line chart with some additional rectangles is &lt;20kb).\n\n5 days was chosen as a good limit for the streamlit teaching app as it offered a good balance between speed and minimized the risk of crashing across different choices of parameters.\n\nIf significantly too few resources are provided at a given step, the size of the animation dataframe quickly gets out of hand (as people aren’t getting through the system so the number of people in the system at each snapshot is very large)\n\nWorking on a way of displaying queues after a threshold number of people is reached will help significantly"
  },
  {
    "objectID": "examples/example_4_ciw/notes.html",
    "href": "examples/example_4_ciw/notes.html",
    "title": "vidigi",
    "section": "",
    "text": "This is adapted from the following repository: Monks, T., Harper, A., & Heather, A. (2023). Towards Sharing Tools, Artefacts, and Reproducible Simulation: a ciw model example (v1.0.1). Zenodo. https://doi.org/10.5281/zenodo.10051494\nSee here for the adaptation embedded within that repo: https://github.com/Bergam0t/ciw-example-animation/tree/main\nPlease also note this model runs ciw 2.x\nIt will not run with 3.x - but could theoretically be adapted to do so"
  },
  {
    "objectID": "examples/example_3_simplest_case_priority_resource/ex_3_simplest_case_priority_resource.html",
    "href": "examples/example_3_simplest_case_priority_resource/ex_3_simplest_case_priority_resource.html",
    "title": "Example 3: Simplest Case - with a Priority Resource",
    "section": "",
    "text": "from examples.example_3_simplest_case_priority_resource.ex_3_model_classes import Trial, g\nfrom vidigi.prep import reshape_for_animations, generate_animation_df\nfrom vidigi.animation import generate_animation\nfrom vidigi.animation import animate_activity_log\nimport pandas as pd\nimport plotly.io as pio\npio.renderers.default = \"notebook\"\nimport os\n\n\n\n\n\n\n\nView Imported Code, which has had logging steps added at the appropriate points in the ‘model’ class\n\n\n\n\n\nimport random\nimport numpy as np\nimport pandas as pd\nimport simpy\nfrom sim_tools.distributions import Exponential, Lognormal\nfrom vidigi.utils import populate_store, VidigiPriorityStore\n\nclass g:\n    '''\n    Create a scenario to parameterise the simulation model\n\n    Parameters:\n    -----------\n    random_number_set: int, optional (default=DEFAULT_RNG_SET)\n        Set to control the initial seeds of each stream of pseudo\n        random numbers used in the model.\n\n    n_cubicles: int\n        The number of treatment cubicles\n\n    trauma_treat_mean: float\n        Mean of the trauma cubicle treatment distribution (Lognormal)\n\n    trauma_treat_var: float\n        Variance of the trauma cubicle treatment distribution (Lognormal)\n\n        arrival_rate: float\n        Set the mean of the exponential distribution that is used to sample the\n        inter-arrival time of patients\n\n    '''\n    random_number_set = 42\n\n    n_cubicles = 4\n    trauma_treat_mean = 40\n    trauma_treat_var = 5\n\n    arrival_rate = 5\n    sim_duration = 600\n    number_of_runs = 100\n\nclass Patient:\n    '''\n    Class defining details for a patient entity\n    '''\n    def __init__(self, p_id):\n        '''\n        Constructor method\n\n        Params:\n        -----\n        identifier: int\n            a numeric identifier for the patient.\n        '''\n        self.identifier = p_id\n        self.arrival = -np.inf\n        self.wait_treat = -np.inf\n        self.total_time = -np.inf\n        self.treat_duration = -np.inf\n\n        # Randomly initialise a patient priority value\n        # Lower values will be prioritised - so priority 1 will be seen before priority 2\n        if random.uniform(0, 1) &lt; 0.2:\n            self.priority = 1\n        else:\n            self.priority = 2\n\nclass Model:\n    '''\n    Simulates the simplest minor treatment process for a patient\n\n    1. Arrive\n    2. Examined/treated by nurse when one available\n    3. Discharged\n    '''\n    # Constructor to set up the model for a run.  We pass in a run number when\n    # we create a new model.\n    def __init__(self, run_number):\n        # Create a SimPy environment in which everything will live\n        self.env = simpy.Environment()\n\n        self.event_log = []\n\n        # Create a patient counter (which we'll use as a patient ID)\n        self.patient_counter = 0\n\n        self.patients = []\n\n        # Create our resources\n        self.init_resources()\n\n        # Store the passed in run number\n        self.run_number = run_number\n\n        # Create a new Pandas DataFrame that will store some results against\n        # the patient ID (which we'll use as the index).\n        self.results_df = pd.DataFrame()\n        self.results_df[\"Patient ID\"] = [1]\n        self.results_df[\"Queue Time Cubicle\"] = [0.0]\n        self.results_df[\"Time with Nurse\"] = [0.0]\n        self.results_df.set_index(\"Patient ID\", inplace=True)\n\n        # Create an attribute to store the mean queuing times across this run of\n        # the model\n        self.mean_q_time_cubicle = 0\n\n        self.patient_inter_arrival_dist = Exponential(mean = g.arrival_rate,\n                                                      random_seed = self.run_number*g.random_number_set)\n        self.treat_dist = Lognormal(mean = g.trauma_treat_mean,\n                                    stdev = g.trauma_treat_var,\n                                    random_seed = self.run_number*g.random_number_set)\n\n    def init_resources(self):\n        '''\n        Init the number of resources\n        and store in the arguments container object\n\n        Resource list:\n            1. Nurses/treatment bays (same thing in this model)\n\n        '''\n        self.treatment_cubicles = VidigiPriorityStore(self.env)\n\n        populate_store(num_resources=g.n_cubicles,\n                       simpy_store=self.treatment_cubicles,\n                       sim_env=self.env)\n\n        # for i in range(g.n_cubicles):\n        #     self.treatment_cubicles.put(\n        #         CustomResource(\n        #             self.env,\n        #             capacity=1,\n        #             id_attribute = i+1)\n        #         )\n\n    # A generator function that represents the DES generator for patient arrivals\n    def generator_patient_arrivals(self):\n        # Use an infinite loop here to keep doing this indefinitely while the simulation runs\n        while True:\n            # Increment the patient counter by 1 (first patient will have an ID of 1)\n            self.patient_counter += 1\n\n            p = Patient(self.patient_counter)\n\n            # Store patient in list for later easy access\n            self.patients.append(p)\n\n            # Tell SimPy to start up the attend_clinic generator function with this patient\n            # (the generator function that will model the patient's journey through the system)\n            self.env.process(self.attend_clinic(p))\n\n            # Randomly sample the time to the next patient arriving\n            sampled_inter = self.patient_inter_arrival_dist.sample()\n\n            # Freeze this instance of this function in place until the inter-arrival time\n            # sampled above has elapsed\n            yield self.env.timeout(sampled_inter)\n\n    def attend_clinic(self, patient):\n        \"\"\"\n        A generator function that represents the pathway for a patient going through the clinic.\n\n        The patient object is passed in to the generator function so we can extract information\n        from / record information to it\n        \"\"\"\n        self.arrival = self.env.now\n\n        # ===== LOGGING FOR VIDIGI ANIMATION  ===== #\n        self.event_log.append(\n            {'patient': patient.identifier,\n             'pathway': patient.priority,\n             'event_type': 'arrival_departure',\n             'event': 'arrival',\n             'time': self.env.now}\n        )\n        # ========================================= #\n\n        # request examination resource\n        start_wait = self.env.now\n\n        # ===== LOGGING FOR VIDIGI ANIMATION  ===== #\n        self.event_log.append(\n            {'patient': patient.identifier,\n             'pathway': patient.priority,\n             'event': 'treatment_wait_begins',\n             'event_type': 'queue',\n             'time': self.env.now}\n        )\n        # ========================================= #\n\n        # Seize a treatment resource when available\n        # Note that we must pass in the patient priority\n        treatment_resource = yield self.treatment_cubicles.get(priority=patient.priority)\n\n        # record the waiting time for registration\n        self.wait_treat = self.env.now - start_wait\n\n        # ===== LOGGING FOR VIDIGI ANIMATION  ===== #\n        self.event_log.append(\n            {'patient': patient.identifier,\n                'pathway': patient.priority,\n                'event': 'treatment_begins',\n                'event_type': 'resource_use',\n                'time': self.env.now,\n                'resource_id': treatment_resource.id_attribute\n                }\n        )\n        # ========================================= #\n\n        # sample treatment duration\n        self.treat_duration = self.treat_dist.sample()\n        yield self.env.timeout(self.treat_duration)\n\n        # ===== LOGGING FOR VIDIGI ANIMATION  ===== #\n        self.event_log.append(\n            {'patient': patient.identifier,\n                'pathway': patient.priority,\n                'event': 'treatment_complete',\n                'event_type': 'resource_use_end',\n                'time': self.env.now,\n                'resource_id': treatment_resource.id_attribute}\n        )\n        # ========================================= #\n\n        # Resource is no longer in use, so put it back in\n        self.treatment_cubicles.put(treatment_resource)\n\n        # total time in system\n        self.total_time = self.env.now - self.arrival\n\n        # ===== LOGGING FOR VIDIGI ANIMATION  ===== #\n        self.event_log.append(\n            {'patient': patient.identifier,\n            'pathway': patient.priority,\n            'event': 'depart',\n            'event_type': 'arrival_departure',\n            'time': self.env.now}\n        )\n        # ========================================= #\n\n\n    # This method calculates results over a single run.  Here we just calculate\n    # a mean, but in real world models you'd probably want to calculate more.\n    def calculate_run_results(self):\n        # Take the mean of the queuing times across patients in this run of the\n        # model.\n        self.mean_q_time_cubicle = self.results_df[\"Queue Time Cubicle\"].mean()\n\n    # The run method starts up the DES entity generators, runs the simulation,\n    # and in turns calls anything we need to generate results for the run\n    def run(self):\n        # Start up our DES entity generators that create new patients.  We've\n        # only got one in this model, but we'd need to do this for each one if\n        # we had multiple generators.\n        self.env.process(self.generator_patient_arrivals())\n\n        # Run the model for the duration specified in g class\n        self.env.run(until=g.sim_duration)\n\n        # Now the simulation run has finished, call the method that calculates\n        # run results\n        self.calculate_run_results()\n\n        self.event_log = pd.DataFrame(self.event_log)\n\n        self.event_log[\"run\"] = self.run_number\n\n        return {'results': self.results_df, 'event_log': self.event_log}\n\n# Class representing a Trial for our simulation - a batch of simulation runs.\nclass Trial:\n    # The constructor sets up a pandas dataframe that will store the key\n    # results from each run against run number, with run number as the index.\n    def  __init__(self):\n        self.df_trial_results = pd.DataFrame()\n        self.df_trial_results[\"Run Number\"] = [0]\n        self.df_trial_results[\"Arrivals\"] = [0]\n        self.df_trial_results[\"Mean Queue Time Cubicle\"] = [0.0]\n        self.df_trial_results.set_index(\"Run Number\", inplace=True)\n\n        self.all_event_logs = []\n\n    # Method to run a trial\n    def run_trial(self):\n        print(f\"{g.n_cubicles} nurses\")\n        print(\"\") ## Print a blank line\n\n        # Run the simulation for the number of runs specified in g class.\n        # For each run, we create a new instance of the Model class and call its\n        # run method, which sets everything else in motion.  Once the run has\n        # completed, we grab out the stored run results (just mean queuing time\n        # here) and store it against the run number in the trial results\n        # dataframe.\n        for run in range(g.number_of_runs):\n            random.seed(run)\n\n            my_model = Model(run)\n            model_outputs = my_model.run()\n            patient_level_results = model_outputs[\"results\"]\n            event_log = model_outputs[\"event_log\"]\n\n            self.df_trial_results.loc[run] = [\n                len(patient_level_results),\n                my_model.mean_q_time_cubicle,\n            ]\n\n            # print(event_log)\n\n            self.all_event_logs.append(event_log)\n\n        self.all_event_logs = pd.concat(self.all_event_logs)\n\n\n\n\nmy_trial = Trial()\n\nmy_trial.run_trial()\n\n4 nurses\n\n\n\n\nmy_trial.all_event_logs.head(50)\n\n\n\n\n\n\n\n\npatient\npathway\nevent_type\nevent\ntime\nresource_id\nrun\n\n\n\n\n0\n1\n2\narrival_departure\narrival\n0.000000\nNaN\n0\n\n\n1\n1\n2\nqueue\ntreatment_wait_begins\n0.000000\nNaN\n0\n\n\n2\n1\n2\nresource_use\ntreatment_begins\n0.000000\n1.0\n0\n\n\n3\n2\n2\narrival_departure\narrival\n3.399660\nNaN\n0\n\n\n4\n2\n2\nqueue\ntreatment_wait_begins\n3.399660\nNaN\n0\n\n\n5\n2\n2\nresource_use\ntreatment_begins\n3.399660\n2.0\n0\n\n\n6\n3\n2\narrival_departure\narrival\n8.497645\nNaN\n0\n\n\n7\n3\n2\nqueue\ntreatment_wait_begins\n8.497645\nNaN\n0\n\n\n8\n3\n2\nresource_use\ntreatment_begins\n8.497645\n3.0\n0\n\n\n9\n4\n2\narrival_departure\narrival\n8.596678\nNaN\n0\n\n\n10\n4\n2\nqueue\ntreatment_wait_begins\n8.596678\nNaN\n0\n\n\n11\n4\n2\nresource_use\ntreatment_begins\n8.596678\n4.0\n0\n\n\n12\n5\n2\narrival_departure\narrival\n8.608025\nNaN\n0\n\n\n13\n5\n2\nqueue\ntreatment_wait_begins\n8.608025\nNaN\n0\n\n\n14\n6\n2\narrival_departure\narrival\n11.359739\nNaN\n0\n\n\n15\n6\n2\nqueue\ntreatment_wait_begins\n11.359739\nNaN\n0\n\n\n16\n7\n2\narrival_departure\narrival\n19.509442\nNaN\n0\n\n\n17\n7\n2\nqueue\ntreatment_wait_begins\n19.509442\nNaN\n0\n\n\n18\n8\n2\narrival_departure\narrival\n22.877356\nNaN\n0\n\n\n19\n8\n2\nqueue\ntreatment_wait_begins\n22.877356\nNaN\n0\n\n\n20\n9\n2\narrival_departure\narrival\n26.653863\nNaN\n0\n\n\n21\n9\n2\nqueue\ntreatment_wait_begins\n26.653863\nNaN\n0\n\n\n22\n1\n2\nresource_use_end\ntreatment_complete\n40.317385\n1.0\n0\n\n\n23\n1\n2\narrival_departure\ndepart\n40.317385\nNaN\n0\n\n\n24\n5\n2\nresource_use\ntreatment_begins\n40.317385\n1.0\n0\n\n\n25\n10\n2\narrival_departure\narrival\n40.737793\nNaN\n0\n\n\n26\n10\n2\nqueue\ntreatment_wait_begins\n40.737793\nNaN\n0\n\n\n27\n2\n2\nresource_use_end\ntreatment_complete\n42.443230\n2.0\n0\n\n\n28\n2\n2\narrival_departure\ndepart\n42.443230\nNaN\n0\n\n\n29\n6\n2\nresource_use\ntreatment_begins\n42.443230\n2.0\n0\n\n\n30\n4\n2\nresource_use_end\ntreatment_complete\n48.809628\n4.0\n0\n\n\n31\n4\n2\narrival_departure\ndepart\n48.809628\nNaN\n0\n\n\n32\n7\n2\nresource_use\ntreatment_begins\n48.809628\n4.0\n0\n\n\n33\n3\n2\nresource_use_end\ntreatment_complete\n51.483457\n3.0\n0\n\n\n34\n3\n2\narrival_departure\ndepart\n51.483457\nNaN\n0\n\n\n35\n8\n2\nresource_use\ntreatment_begins\n51.483457\n3.0\n0\n\n\n36\n11\n2\narrival_departure\narrival\n71.026558\nNaN\n0\n\n\n37\n11\n2\nqueue\ntreatment_wait_begins\n71.026558\nNaN\n0\n\n\n38\n5\n2\nresource_use_end\ntreatment_complete\n77.447488\n1.0\n0\n\n\n39\n5\n2\narrival_departure\ndepart\n77.447488\nNaN\n0\n\n\n40\n9\n2\nresource_use\ntreatment_begins\n77.447488\n1.0\n0\n\n\n41\n6\n2\nresource_use_end\ntreatment_complete\n83.962251\n2.0\n0\n\n\n42\n6\n2\narrival_departure\ndepart\n83.962251\nNaN\n0\n\n\n43\n10\n2\nresource_use\ntreatment_begins\n83.962251\n2.0\n0\n\n\n44\n12\n2\narrival_departure\narrival\n87.458700\nNaN\n0\n\n\n45\n12\n2\nqueue\ntreatment_wait_begins\n87.458700\nNaN\n0\n\n\n46\n13\n2\narrival_departure\narrival\n87.465138\nNaN\n0\n\n\n47\n13\n2\nqueue\ntreatment_wait_begins\n87.465138\nNaN\n0\n\n\n48\n7\n2\nresource_use_end\ntreatment_complete\n95.498040\n4.0\n0\n\n\n49\n7\n2\narrival_departure\ndepart\n95.498040\nNaN\n0\n\n\n\n\n\n\n\n\nSTEP_SNAPSHOT_MAX = 45\nLIMIT_DURATION = g.sim_duration\nWRAP_QUEUES_AT = 15\n\n\nfull_patient_df = reshape_for_animations(\n    event_log=my_trial.all_event_logs[my_trial.all_event_logs['run']==1],\n    every_x_time_units=2,\n    step_snapshot_max=STEP_SNAPSHOT_MAX,\n    limit_duration=LIMIT_DURATION,\n    debug_mode=True\n    )\n\nfull_patient_df.head(15)\n\nIteration through minute-by-minute logs complete 00:34:23\nSnapshot df concatenation complete at 00:34:23\n\n\n\n\n\n\n\n\n\nindex\npatient\npathway\nevent_type\nevent\ntime\nresource_id\nrun\nrank\nminute\nadditional\n\n\n\n\n0\n2\n1\n1\nresource_use\ntreatment_begins\n0.000000\n1.0\n1\n1.0\n0\nNaN\n\n\n1\n2\n1\n1\nresource_use\ntreatment_begins\n0.000000\n1.0\n1\n1.0\n2\nNaN\n\n\n2\n2\n1\n1\nresource_use\ntreatment_begins\n0.000000\n1.0\n1\n1.0\n4\nNaN\n\n\n3\n2\n1\n1\nresource_use\ntreatment_begins\n0.000000\n1.0\n1\n1.0\n6\nNaN\n\n\n4\n2\n1\n1\nresource_use\ntreatment_begins\n0.000000\n1.0\n1\n1.0\n8\nNaN\n\n\n5\n2\n1\n1\nresource_use\ntreatment_begins\n0.000000\n1.0\n1\n1.0\n10\nNaN\n\n\n6\n2\n1\n1\nresource_use\ntreatment_begins\n0.000000\n1.0\n1\n1.0\n12\nNaN\n\n\n7\n2\n1\n1\nresource_use\ntreatment_begins\n0.000000\n1.0\n1\n1.0\n14\nNaN\n\n\n8\n5\n2\n2\nresource_use\ntreatment_begins\n12.021043\n2.0\n1\n2.0\n14\nNaN\n\n\n9\n2\n1\n1\nresource_use\ntreatment_begins\n0.000000\n1.0\n1\n1.0\n16\nNaN\n\n\n10\n5\n2\n2\nresource_use\ntreatment_begins\n12.021043\n2.0\n1\n2.0\n16\nNaN\n\n\n11\n2\n1\n1\nresource_use\ntreatment_begins\n0.000000\n1.0\n1\n1.0\n18\nNaN\n\n\n12\n5\n2\n2\nresource_use\ntreatment_begins\n12.021043\n2.0\n1\n2.0\n18\nNaN\n\n\n13\n2\n1\n1\nresource_use\ntreatment_begins\n0.000000\n1.0\n1\n1.0\n20\nNaN\n\n\n14\n5\n2\n2\nresource_use\ntreatment_begins\n12.021043\n2.0\n1\n2.0\n20\nNaN\n\n\n\n\n\n\n\n\nevent_position_df = pd.DataFrame([\n                    {'event': 'arrival',\n                     'x':  50, 'y': 300,\n                     'label': \"Arrival\" },\n\n                    # Triage - minor and trauma\n                    {'event': 'treatment_wait_begins',\n                     'x':  205, 'y': 275,\n                     'label': \"Waiting for Treatment\"},\n\n                    {'event': 'treatment_begins',\n                     'x':  205, 'y': 175,\n                     'resource':'n_cubicles',\n                     'label': \"Being Treated\"},\n\n                    {'event': 'exit',\n                     'x':  270, 'y': 70,\n                     'label': \"Exit\"}\n\n                ])\n\n\nGenerate animation using the step-by-step functions\nUsing the three step-by-step functions allows us to intervene in the produced dataframe and manually take control of the icons in use.\nThis will allow us to show the high-priority patients with a unique icon so we can see their frequency and how they are handled in the final model.\n\nfull_patient_df_plus_pos = generate_animation_df(full_patient_df=full_patient_df,\n                                                 event_position_df=event_position_df,\n                                                 wrap_queues_at=WRAP_QUEUES_AT,\n                                                 step_snapshot_max=STEP_SNAPSHOT_MAX,\n                                                 gap_between_entities=10,\n                                                 gap_between_resources=10,\n                                                 gap_between_rows=30,\n                                                 debug_mode=True\n                                                 )\n\nfull_patient_df_plus_pos.sort_values(['patient', 'minute']).head(15)\n\nPlacement dataframe finished construction at 00:34:23\n\n\n\n\n\n\n\n\n\nindex\npatient\npathway\nevent_type\nevent\ntime\nresource_id\nrun\nrank\nminute\nadditional\nx\ny_final\nlabel\nresource\nx_final\nrow\nicon\n\n\n\n\n10186\n2\n1\n1\nresource_use\ntreatment_begins\n0.0\n1.0\n1\n1.0\n0\nNaN\n205\n175.0\nBeing Treated\nn_cubicles\n205.0\n0.0\n🧔🏼\n\n\n10187\n2\n1\n1\nresource_use\ntreatment_begins\n0.0\n1.0\n1\n1.0\n2\nNaN\n205\n175.0\nBeing Treated\nn_cubicles\n205.0\n0.0\n🧔🏼\n\n\n10188\n2\n1\n1\nresource_use\ntreatment_begins\n0.0\n1.0\n1\n1.0\n4\nNaN\n205\n175.0\nBeing Treated\nn_cubicles\n205.0\n0.0\n🧔🏼\n\n\n10189\n2\n1\n1\nresource_use\ntreatment_begins\n0.0\n1.0\n1\n1.0\n6\nNaN\n205\n175.0\nBeing Treated\nn_cubicles\n205.0\n0.0\n🧔🏼\n\n\n10190\n2\n1\n1\nresource_use\ntreatment_begins\n0.0\n1.0\n1\n1.0\n8\nNaN\n205\n175.0\nBeing Treated\nn_cubicles\n205.0\n0.0\n🧔🏼\n\n\n10191\n2\n1\n1\nresource_use\ntreatment_begins\n0.0\n1.0\n1\n1.0\n10\nNaN\n205\n175.0\nBeing Treated\nn_cubicles\n205.0\n0.0\n🧔🏼\n\n\n10192\n2\n1\n1\nresource_use\ntreatment_begins\n0.0\n1.0\n1\n1.0\n12\nNaN\n205\n175.0\nBeing Treated\nn_cubicles\n205.0\n0.0\n🧔🏼\n\n\n10193\n2\n1\n1\nresource_use\ntreatment_begins\n0.0\n1.0\n1\n1.0\n14\nNaN\n205\n175.0\nBeing Treated\nn_cubicles\n205.0\n0.0\n🧔🏼\n\n\n10194\n2\n1\n1\nresource_use\ntreatment_begins\n0.0\n1.0\n1\n1.0\n16\nNaN\n205\n175.0\nBeing Treated\nn_cubicles\n205.0\n0.0\n🧔🏼\n\n\n10195\n2\n1\n1\nresource_use\ntreatment_begins\n0.0\n1.0\n1\n1.0\n18\nNaN\n205\n175.0\nBeing Treated\nn_cubicles\n205.0\n0.0\n🧔🏼\n\n\n10196\n2\n1\n1\nresource_use\ntreatment_begins\n0.0\n1.0\n1\n1.0\n20\nNaN\n205\n175.0\nBeing Treated\nn_cubicles\n205.0\n0.0\n🧔🏼\n\n\n10197\n2\n1\n1\nresource_use\ntreatment_begins\n0.0\n1.0\n1\n1.0\n22\nNaN\n205\n175.0\nBeing Treated\nn_cubicles\n205.0\n0.0\n🧔🏼\n\n\n10198\n2\n1\n1\nresource_use\ntreatment_begins\n0.0\n1.0\n1\n1.0\n24\nNaN\n205\n175.0\nBeing Treated\nn_cubicles\n205.0\n0.0\n🧔🏼\n\n\n10199\n2\n1\n1\nresource_use\ntreatment_begins\n0.0\n1.0\n1\n1.0\n26\nNaN\n205\n175.0\nBeing Treated\nn_cubicles\n205.0\n0.0\n🧔🏼\n\n\n10200\n2\n1\n1\nresource_use\ntreatment_begins\n0.0\n1.0\n1\n1.0\n28\nNaN\n205\n175.0\nBeing Treated\nn_cubicles\n205.0\n0.0\n🧔🏼\n\n\n\n\n\n\n\n\ndef show_priority_icon(row):\n            if \"more\" not in row[\"icon\"]:\n                if row[\"pathway\"] == 1:\n                        return \"🚨\"\n                else:\n                    return row[\"icon\"]\n            else:\n                return row[\"icon\"]\n\n\nfull_patient_df_plus_pos = full_patient_df_plus_pos.assign(\n            icon=full_patient_df_plus_pos.apply(show_priority_icon, axis=1)\n            )\n\n\nfull_patient_df_plus_pos.head(15)\n\n\n\n\n\n\n\n\nindex\npatient\npathway\nevent_type\nevent\ntime\nresource_id\nrun\nrank\nminute\nadditional\nx\ny_final\nlabel\nresource\nx_final\nrow\nicon\n\n\n\n\n0\n155\n49\n2\nqueue\nexit\n206.540636\nNaN\n1\n3.0\n600\nNaN\n270\n70.0\nExit\nNaN\n250.0\n0.0\n🧕🏾\n\n\n1\n155\n49\n2\nqueue\ntreatment_wait_begins\n206.540636\nNaN\n1\n27.0\n208\nNaN\n205\n305.0\nWaiting for Treatment\nNaN\n95.0\n1.0\n🧕🏾\n\n\n2\n155\n49\n2\nqueue\ntreatment_wait_begins\n206.540636\nNaN\n1\n27.0\n210\nNaN\n205\n305.0\nWaiting for Treatment\nNaN\n95.0\n1.0\n🧕🏾\n\n\n3\n155\n49\n2\nqueue\ntreatment_wait_begins\n206.540636\nNaN\n1\n27.0\n212\nNaN\n205\n305.0\nWaiting for Treatment\nNaN\n95.0\n1.0\n🧕🏾\n\n\n4\n155\n49\n2\nqueue\ntreatment_wait_begins\n206.540636\nNaN\n1\n27.0\n214\nNaN\n205\n305.0\nWaiting for Treatment\nNaN\n95.0\n1.0\n🧕🏾\n\n\n5\n155\n49\n2\nqueue\ntreatment_wait_begins\n206.540636\nNaN\n1\n27.0\n216\nNaN\n205\n305.0\nWaiting for Treatment\nNaN\n95.0\n1.0\n🧕🏾\n\n\n6\n155\n49\n2\nqueue\ntreatment_wait_begins\n206.540636\nNaN\n1\n27.0\n218\nNaN\n205\n305.0\nWaiting for Treatment\nNaN\n95.0\n1.0\n🧕🏾\n\n\n7\n155\n49\n2\nqueue\ntreatment_wait_begins\n206.540636\nNaN\n1\n27.0\n220\nNaN\n205\n305.0\nWaiting for Treatment\nNaN\n95.0\n1.0\n🧕🏾\n\n\n8\n155\n49\n2\nqueue\ntreatment_wait_begins\n206.540636\nNaN\n1\n27.0\n222\nNaN\n205\n305.0\nWaiting for Treatment\nNaN\n95.0\n1.0\n🧕🏾\n\n\n9\n155\n49\n2\nqueue\ntreatment_wait_begins\n206.540636\nNaN\n1\n27.0\n224\nNaN\n205\n305.0\nWaiting for Treatment\nNaN\n95.0\n1.0\n🧕🏾\n\n\n10\n155\n49\n2\nqueue\ntreatment_wait_begins\n206.540636\nNaN\n1\n27.0\n226\nNaN\n205\n305.0\nWaiting for Treatment\nNaN\n95.0\n1.0\n🧕🏾\n\n\n11\n155\n49\n2\nqueue\ntreatment_wait_begins\n206.540636\nNaN\n1\n27.0\n228\nNaN\n205\n305.0\nWaiting for Treatment\nNaN\n95.0\n1.0\n🧕🏾\n\n\n12\n155\n49\n2\nqueue\ntreatment_wait_begins\n206.540636\nNaN\n1\n27.0\n230\nNaN\n205\n305.0\nWaiting for Treatment\nNaN\n95.0\n1.0\n🧕🏾\n\n\n13\n155\n49\n2\nqueue\ntreatment_wait_begins\n206.540636\nNaN\n1\n27.0\n232\nNaN\n205\n305.0\nWaiting for Treatment\nNaN\n95.0\n1.0\n🧕🏾\n\n\n14\n155\n49\n2\nqueue\ntreatment_wait_begins\n206.540636\nNaN\n1\n26.0\n234\nNaN\n205\n305.0\nWaiting for Treatment\nNaN\n105.0\n1.0\n🧕🏾\n\n\n\n\n\n\n\n\ngenerate_animation(\n        full_patient_df_plus_pos=full_patient_df_plus_pos.sort_values(['patient', 'minute']),\n        event_position_df= event_position_df,\n        scenario=g(),\n        debug_mode=True,\n        setup_mode=False,\n        include_play_button=True,\n        icon_and_text_size=20,\n        plotly_height=700,\n        frame_duration=800,\n        frame_transition_duration=200,\n        plotly_width=1200,\n        override_x_max=300,\n        override_y_max=500,\n        time_display_units=\"dhm\",\n        display_stage_labels=False,\n        add_background_image=\"https://raw.githubusercontent.com/Bergam0t/vidigi/refs/heads/main/examples/example_1_simplest_case/Simplest%20Model%20Background%20Image%20-%20Horizontal%20Layout.drawio.png\",\n    )\n\nOutput animation generation complete at 00:34:27\n\n\n                                                \n\n\n\n\nRerun, but using the all-in-one animation function (which will not show different priority icons)\n\nanimate_activity_log(\n        event_log=my_trial.all_event_logs[my_trial.all_event_logs['run']==1],\n        event_position_df= event_position_df,\n        scenario=g(),\n        debug_mode=True,\n        setup_mode=False,\n        every_x_time_units=1,\n        include_play_button=True,\n        icon_and_text_size=20,\n        gap_between_entities=6,\n        gap_between_rows=25,\n        plotly_height=700,\n        frame_duration=200,\n        plotly_width=1200,\n        override_x_max=300,\n        override_y_max=500,\n        limit_duration=g.sim_duration,\n        wrap_queues_at=25,\n        step_snapshot_max=125,\n        time_display_units=\"dhm\",\n        display_stage_labels=False,\n        add_background_image=\"https://raw.githubusercontent.com/Bergam0t/vidigi/refs/heads/main/examples/example_1_simplest_case/Simplest%20Model%20Background%20Image%20-%20Horizontal%20Layout.drawio.png\",\n    )\n\nAnimation function called at 00:34:28\nIteration through minute-by-minute logs complete 00:34:32\nSnapshot df concatenation complete at 00:34:32\nReshaped animation dataframe finished construction at 00:34:32\nPlacement dataframe finished construction at 00:34:32\nOutput animation generation complete at 00:34:35\nTotal Time Elapsed: 6.68 seconds",
    "crumbs": [
      "Examples",
      "Example 3: Simplest Case - with a Priority Resource"
    ]
  },
  {
    "objectID": "examples/example_1_simplest_case/ex_1_simplest_case.html",
    "href": "examples/example_1_simplest_case/ex_1_simplest_case.html",
    "title": "Example 1: Simplest Case",
    "section": "",
    "text": "from examples.example_1_simplest_case.ex_1_model_classes_with_vidigi_logging import Trial, g\nfrom vidigi.animation import animate_activity_log\nimport pandas as pd\nimport plotly.io as pio\npio.renderers.default = \"notebook\"\nimport os\n\n\n\n\n\n\n\nView Imported Code, which has had logging steps added at the appropriate points in the ‘model’ class\n\n\n\n\n\nimport random\nimport numpy as np\nimport pandas as pd\nimport simpy\nfrom sim_tools.distributions import Exponential, Lognormal\nfrom vidigi.utils import populate_store\n\n\n# Class to store global parameter values.  We don't create an instance of this\n# class - we just refer to the class blueprint itself to access the numbers\n# inside.\nclass g:\n    '''\n    Create a scenario to parameterise the simulation model\n\n    Parameters:\n    -----------\n    random_number_set: int, optional (default=DEFAULT_RNG_SET)\n        Set to control the initial seeds of each stream of pseudo\n        random numbers used in the model.\n\n    n_cubicles: int\n        The number of treatment cubicles\n\n    trauma_treat_mean: float\n        Mean of the trauma cubicle treatment distribution (Lognormal)\n\n    trauma_treat_var: float\n        Variance of the trauma cubicle treatment distribution (Lognormal)\n\n    arrival_rate: float\n        Set the mean of the exponential distribution that is used to sample the\n        inter-arrival time of patients\n\n    sim_duration: int\n        The number of time units the simulation will run for\n\n    number_of_runs: int\n        The number of times the simulation will be run with different random number streams\n\n    '''\n    random_number_set = 42\n\n    n_cubicles = 4\n    trauma_treat_mean = 40\n    trauma_treat_var = 5\n\n    arrival_rate = 5\n\n    sim_duration = 600\n    number_of_runs = 100\n\n# Class representing patients coming in to the clinic.\nclass Patient:\n    '''\n    Class defining details for a patient entity\n    '''\n    def __init__(self, p_id):\n        '''\n        Constructor method\n\n        Params:\n        -----\n        identifier: int\n            a numeric identifier for the patient.\n        '''\n        self.identifier = p_id\n        self.arrival = -np.inf\n        self.wait_treat = -np.inf\n        self.total_time = -np.inf\n        self.treat_duration = -np.inf\n\n# Class representing our model of the clinic.\nclass Model:\n    '''\n    Simulates the simplest minor treatment process for a patient\n\n    1. Arrive\n    2. Examined/treated by nurse when one available\n    3. Discharged\n    '''\n    # Constructor to set up the model for a run.  We pass in a run number when\n    # we create a new model.\n    def __init__(self, run_number):\n        # Create a SimPy environment in which everything will live\n        self.env = simpy.Environment()\n\n        self.event_log = []\n\n        # Create a patient counter (which we'll use as a patient ID)\n        self.patient_counter = 0\n\n        self.patients = []\n\n        # Create our resources\n        self.init_resources()\n\n        # Store the passed in run number\n        self.run_number = run_number\n\n        # Create a new Pandas DataFrame that will store some results against\n        # the patient ID (which we'll use as the index).\n        self.results_df = pd.DataFrame()\n        self.results_df[\"Patient ID\"] = [1]\n        self.results_df[\"Queue Time Cubicle\"] = [0.0]\n        self.results_df[\"Time with Nurse\"] = [0.0]\n        self.results_df.set_index(\"Patient ID\", inplace=True)\n\n        # Create an attribute to store the mean queuing times across this run of\n        # the model\n        self.mean_q_time_cubicle = 0\n\n        self.patient_inter_arrival_dist = Exponential(mean = g.arrival_rate,\n                                                      random_seed = self.run_number*g.random_number_set)\n        self.treat_dist = Lognormal(mean = g.trauma_treat_mean,\n                                    stdev = g.trauma_treat_var,\n                                    random_seed = self.run_number*g.random_number_set)\n\n    def init_resources(self):\n        '''\n        Init the number of resources\n        and store in the arguments container object\n\n        Resource list:\n            1. Nurses/treatment bays (same thing in this model)\n\n        '''\n        self.treatment_cubicles = simpy.Store(self.env)\n\n        populate_store(num_resources=g.n_cubicles,\n                       simpy_store=self.treatment_cubicles,\n                       sim_env=self.env)\n\n        # for i in range(g.n_cubicles):\n        #     self.treatment_cubicles.put(\n        #         CustomResource(\n        #             self.env,\n        #             capacity=1,\n        #             id_attribute = i+1)\n        #         )\n\n    # A generator function that represents the DES generator for patient\n    # arrivals\n    def generator_patient_arrivals(self):\n        # We use an infinite loop here to keep doing this indefinitely whilst\n        # the simulation runs\n        while True:\n            # Increment the patient counter by 1 (this means our first patient\n            # will have an ID of 1)\n            self.patient_counter += 1\n\n            # Create a new patient - an instance of the Patient Class we\n            # defined above.  Remember, we pass in the ID when creating a\n            # patient - so here we pass the patient counter to use as the ID.\n            p = Patient(self.patient_counter)\n\n            # Store patient in list for later easy access\n            self.patients.append(p)\n\n            # Tell SimPy to start up the attend_clinic generator function with\n            # this patient (the generator function that will model the\n            # patient's journey through the system)\n            self.env.process(self.attend_clinic(p))\n\n            # Randomly sample the time to the next patient arriving.  Here, we\n            # sample from an exponential distribution (common for inter-arrival\n            # times), and pass in a lambda value of 1 / mean.  The mean\n            # inter-arrival time is stored in the g class.\n            sampled_inter = self.patient_inter_arrival_dist.sample()\n\n            # Freeze this instance of this function in place until the\n            # inter-arrival time we sampled above has elapsed.  Note - time in\n            # SimPy progresses in \"Time Units\", which can represent anything\n            # you like (just make sure you're consistent within the model)\n            yield self.env.timeout(sampled_inter)\n\n    # A generator function that represents the pathway for a patient going\n    # through the clinic.\n    # The patient object is passed in to the generator function so we can\n    # extract information from / record information to it\n    def attend_clinic(self, patient):\n        self.arrival = self.env.now\n        self.event_log.append(\n            {'patient': patient.identifier,\n             'pathway': 'Simplest',\n             'event_type': 'arrival_departure',\n             'event': 'arrival',\n             'time': self.env.now}\n        )\n\n        # request examination resource\n        start_wait = self.env.now\n        self.event_log.append(\n            {'patient': patient.identifier,\n             'pathway': 'Simplest',\n             'event': 'treatment_wait_begins',\n             'event_type': 'queue',\n             'time': self.env.now}\n        )\n\n        # Seize a treatment resource when available\n        treatment_resource = yield self.treatment_cubicles.get()\n\n        # record the waiting time for registration\n        self.wait_treat = self.env.now - start_wait\n        self.event_log.append(\n            {'patient': patient.identifier,\n                'pathway': 'Simplest',\n                'event': 'treatment_begins',\n                'event_type': 'resource_use',\n                'time': self.env.now,\n                'resource_id': treatment_resource.id_attribute\n                }\n        )\n\n        # sample treatment duration\n        self.treat_duration = self.treat_dist.sample()\n        yield self.env.timeout(self.treat_duration)\n\n        self.event_log.append(\n            {'patient': patient.identifier,\n                'pathway': 'Simplest',\n                'event': 'treatment_complete',\n                'event_type': 'resource_use_end',\n                'time': self.env.now,\n                'resource_id': treatment_resource.id_attribute}\n        )\n\n        # Resource is no longer in use, so put it back in\n        self.treatment_cubicles.put(treatment_resource)\n\n        # total time in system\n        self.total_time = self.env.now - self.arrival\n        self.event_log.append(\n            {'patient': patient.identifier,\n            'pathway': 'Simplest',\n            'event': 'depart',\n            'event_type': 'arrival_departure',\n            'time': self.env.now}\n        )\n\n\n    # This method calculates results over a single run.  Here we just calculate\n    # a mean, but in real world models you'd probably want to calculate more.\n    def calculate_run_results(self):\n        # Take the mean of the queuing times across patients in this run of the\n        # model.\n        self.mean_q_time_cubicle = self.results_df[\"Queue Time Cubicle\"].mean()\n\n    # The run method starts up the DES entity generators, runs the simulation,\n    # and in turns calls anything we need to generate results for the run\n    def run(self):\n        # Start up our DES entity generators that create new patients.  We've\n        # only got one in this model, but we'd need to do this for each one if\n        # we had multiple generators.\n        self.env.process(self.generator_patient_arrivals())\n\n        # Run the model for the duration specified in g class\n        self.env.run(until=g.sim_duration)\n\n        # Now the simulation run has finished, call the method that calculates\n        # run results\n        self.calculate_run_results()\n\n        self.event_log = pd.DataFrame(self.event_log)\n\n        self.event_log[\"run\"] = self.run_number\n\n        return {'results': self.results_df, 'event_log': self.event_log}\n\n# Class representing a Trial for our simulation - a batch of simulation runs.\nclass Trial:\n    # The constructor sets up a pandas dataframe that will store the key\n    # results from each run against run number, with run number as the index.\n    def  __init__(self):\n        self.df_trial_results = pd.DataFrame()\n        self.df_trial_results[\"Run Number\"] = [0]\n        self.df_trial_results[\"Arrivals\"] = [0]\n        self.df_trial_results[\"Mean Queue Time Cubicle\"] = [0.0]\n        self.df_trial_results.set_index(\"Run Number\", inplace=True)\n\n        self.all_event_logs = []\n\n    # Method to run a trial\n    def run_trial(self):\n        print(f\"{g.n_cubicles} nurses\")\n        print(\"\") ## Print a blank line\n\n        # Run the simulation for the number of runs specified in g class.\n        # For each run, we create a new instance of the Model class and call its\n        # run method, which sets everything else in motion.  Once the run has\n        # completed, we grab out the stored run results (just mean queuing time\n        # here) and store it against the run number in the trial results\n        # dataframe.\n        for run in range(g.number_of_runs):\n            random.seed(run)\n\n            my_model = Model(run)\n            model_outputs = my_model.run()\n            patient_level_results = model_outputs[\"results\"]\n            event_log = model_outputs[\"event_log\"]\n\n            self.df_trial_results.loc[run] = [\n                len(patient_level_results),\n                my_model.mean_q_time_cubicle,\n            ]\n\n            # print(event_log)\n\n            self.all_event_logs.append(event_log)\n\n        self.all_event_logs = pd.concat(self.all_event_logs)\n\n\n\n\nmy_trial = Trial()\n\nmy_trial.run_trial()\n\n4 nurses\n\n\n\n\nmy_trial.all_event_logs.head(50)\n\n\n\n\n\n\n\n\npatient\npathway\nevent_type\nevent\ntime\nresource_id\nrun\n\n\n\n\n0\n1\nSimplest\narrival_departure\narrival\n0.000000\nNaN\n0\n\n\n1\n1\nSimplest\nqueue\ntreatment_wait_begins\n0.000000\nNaN\n0\n\n\n2\n1\nSimplest\nresource_use\ntreatment_begins\n0.000000\n1.0\n0\n\n\n3\n2\nSimplest\narrival_departure\narrival\n3.399660\nNaN\n0\n\n\n4\n2\nSimplest\nqueue\ntreatment_wait_begins\n3.399660\nNaN\n0\n\n\n5\n2\nSimplest\nresource_use\ntreatment_begins\n3.399660\n2.0\n0\n\n\n6\n3\nSimplest\narrival_departure\narrival\n8.497645\nNaN\n0\n\n\n7\n3\nSimplest\nqueue\ntreatment_wait_begins\n8.497645\nNaN\n0\n\n\n8\n3\nSimplest\nresource_use\ntreatment_begins\n8.497645\n3.0\n0\n\n\n9\n4\nSimplest\narrival_departure\narrival\n8.596678\nNaN\n0\n\n\n10\n4\nSimplest\nqueue\ntreatment_wait_begins\n8.596678\nNaN\n0\n\n\n11\n4\nSimplest\nresource_use\ntreatment_begins\n8.596678\n4.0\n0\n\n\n12\n5\nSimplest\narrival_departure\narrival\n8.608025\nNaN\n0\n\n\n13\n5\nSimplest\nqueue\ntreatment_wait_begins\n8.608025\nNaN\n0\n\n\n14\n6\nSimplest\narrival_departure\narrival\n11.359739\nNaN\n0\n\n\n15\n6\nSimplest\nqueue\ntreatment_wait_begins\n11.359739\nNaN\n0\n\n\n16\n7\nSimplest\narrival_departure\narrival\n19.509442\nNaN\n0\n\n\n17\n7\nSimplest\nqueue\ntreatment_wait_begins\n19.509442\nNaN\n0\n\n\n18\n8\nSimplest\narrival_departure\narrival\n22.877356\nNaN\n0\n\n\n19\n8\nSimplest\nqueue\ntreatment_wait_begins\n22.877356\nNaN\n0\n\n\n20\n9\nSimplest\narrival_departure\narrival\n26.653863\nNaN\n0\n\n\n21\n9\nSimplest\nqueue\ntreatment_wait_begins\n26.653863\nNaN\n0\n\n\n22\n1\nSimplest\nresource_use_end\ntreatment_complete\n40.317385\n1.0\n0\n\n\n23\n1\nSimplest\narrival_departure\ndepart\n40.317385\nNaN\n0\n\n\n24\n5\nSimplest\nresource_use\ntreatment_begins\n40.317385\n1.0\n0\n\n\n25\n10\nSimplest\narrival_departure\narrival\n40.737793\nNaN\n0\n\n\n26\n10\nSimplest\nqueue\ntreatment_wait_begins\n40.737793\nNaN\n0\n\n\n27\n2\nSimplest\nresource_use_end\ntreatment_complete\n42.443230\n2.0\n0\n\n\n28\n2\nSimplest\narrival_departure\ndepart\n42.443230\nNaN\n0\n\n\n29\n6\nSimplest\nresource_use\ntreatment_begins\n42.443230\n2.0\n0\n\n\n30\n4\nSimplest\nresource_use_end\ntreatment_complete\n48.809628\n4.0\n0\n\n\n31\n4\nSimplest\narrival_departure\ndepart\n48.809628\nNaN\n0\n\n\n32\n7\nSimplest\nresource_use\ntreatment_begins\n48.809628\n4.0\n0\n\n\n33\n3\nSimplest\nresource_use_end\ntreatment_complete\n51.483457\n3.0\n0\n\n\n34\n3\nSimplest\narrival_departure\ndepart\n51.483457\nNaN\n0\n\n\n35\n8\nSimplest\nresource_use\ntreatment_begins\n51.483457\n3.0\n0\n\n\n36\n11\nSimplest\narrival_departure\narrival\n71.026558\nNaN\n0\n\n\n37\n11\nSimplest\nqueue\ntreatment_wait_begins\n71.026558\nNaN\n0\n\n\n38\n5\nSimplest\nresource_use_end\ntreatment_complete\n77.447488\n1.0\n0\n\n\n39\n5\nSimplest\narrival_departure\ndepart\n77.447488\nNaN\n0\n\n\n40\n9\nSimplest\nresource_use\ntreatment_begins\n77.447488\n1.0\n0\n\n\n41\n6\nSimplest\nresource_use_end\ntreatment_complete\n83.962251\n2.0\n0\n\n\n42\n6\nSimplest\narrival_departure\ndepart\n83.962251\nNaN\n0\n\n\n43\n10\nSimplest\nresource_use\ntreatment_begins\n83.962251\n2.0\n0\n\n\n44\n12\nSimplest\narrival_departure\narrival\n87.458700\nNaN\n0\n\n\n45\n12\nSimplest\nqueue\ntreatment_wait_begins\n87.458700\nNaN\n0\n\n\n46\n13\nSimplest\narrival_departure\narrival\n87.465138\nNaN\n0\n\n\n47\n13\nSimplest\nqueue\ntreatment_wait_begins\n87.465138\nNaN\n0\n\n\n48\n7\nSimplest\nresource_use_end\ntreatment_complete\n95.498040\n4.0\n0\n\n\n49\n7\nSimplest\narrival_departure\ndepart\n95.498040\nNaN\n0\n\n\n\n\n\n\n\n\nevent_position_df = pd.DataFrame([\n                    {'event': 'arrival',\n                     'x':  50, 'y': 300,\n                     'label': \"Arrival\" },\n\n                    # Triage - minor and trauma\n                    {'event': 'treatment_wait_begins',\n                     'x':  205, 'y': 275,\n                     'label': \"Waiting for Treatment\"},\n\n                    {'event': 'treatment_begins',\n                     'x':  205, 'y': 175,\n                     'resource':'n_cubicles',\n                     'label': \"Being Treated\"},\n\n                    {'event': 'exit',\n                     'x':  270, 'y': 70,\n                     'label': \"Exit\"}\n\n                ])\n\n\nanimate_activity_log(\n        event_log=my_trial.all_event_logs[my_trial.all_event_logs['run']==1],\n        event_position_df= event_position_df,\n        scenario=g(),\n        debug_mode=True,\n        setup_mode=False,\n        every_x_time_units=1,\n        include_play_button=True,\n        icon_and_text_size=20,\n        gap_between_entities=6,\n        gap_between_rows=25,\n        plotly_height=700,\n        frame_duration=200,\n        plotly_width=1200,\n        override_x_max=300,\n        override_y_max=500,\n        limit_duration=g.sim_duration,\n        wrap_queues_at=25,\n        step_snapshot_max=125,\n        time_display_units=\"dhm\",\n        display_stage_labels=False,\n        add_background_image=\"https://raw.githubusercontent.com/Bergam0t/vidigi/refs/heads/main/examples/example_1_simplest_case/Simplest%20Model%20Background%20Image%20-%20Horizontal%20Layout.drawio.png\",\n    )\n\nAnimation function called at 00:39:50\nIteration through minute-by-minute logs complete 00:39:54\nSnapshot df concatenation complete at 00:39:54\nReshaped animation dataframe finished construction at 00:39:54\nPlacement dataframe finished construction at 00:39:54\nOutput animation generation complete at 00:39:57\nTotal Time Elapsed: 7.31 seconds",
    "crumbs": [
      "Examples",
      "Example 1: Simplest Case"
    ]
  },
  {
    "objectID": "examples/example_2_branching_multistep/ex_2_branching_multistep_case.html",
    "href": "examples/example_2_branching_multistep/ex_2_branching_multistep_case.html",
    "title": "Example 2: Branching + Multi-step Case",
    "section": "",
    "text": "from examples.example_2_branching_multistep.ex_2_model_classes import Trial, g\nfrom vidigi.animation import animate_activity_log\nimport pandas as pd\nimport plotly.io as pio\npio.renderers.default = \"notebook\"\nimport os\n\n\n\n\n\n\n\nView Imported Code, which has had logging steps added at the appropriate points in the ‘model’ class\n\n\n\n\n\nimport random\nimport numpy as np\nimport pandas as pd\nimport simpy\nfrom sim_tools.distributions import Exponential, Lognormal, Uniform, Normal, Bernoulli\nfrom vidigi.utils import populate_store\nfrom examples.simulation_utility_functions import trace\n\n\n# Class to store global parameter values.  We don't create an instance of this\n# class - we just refer to the class blueprint itself to access the numbers\n# inside.\nclass g:\n    '''\n    Create a scenario to parameterise the simulation model\n\n    Parameters:\n    -----------\n    random_number_set: int, optional (default=DEFAULT_RNG_SET)\n        Set to control the initial seeds of each stream of pseudo\n        random numbers used in the model.\n\n    n_triage: int\n        The number of triage cubicles\n\n    n_reg: int\n        The number of registration clerks\n\n    n_exam: int\n        The number of examination rooms\n\n    n_trauma: int\n        The number of trauma bays for stablisation\n\n    n_cubicles_non_trauma_treat: int\n        The number of non-trauma treatment cubicles\n\n    n_cubicles_trauma_treat: int\n        The number of trauma treatment cubicles\n\n    triage_mean: float\n        Mean duration of the triage distribution (Exponential)\n\n    reg_mean: float\n        Mean duration of the registration distribution (Lognormal)\n\n    reg_var: float\n        Variance of the registration distribution (Lognormal)\n\n    exam_mean: float\n        Mean of the examination distribution (Normal)\n\n    exam_var: float\n        Variance of the examination distribution (Normal)\n\n    trauma_mean: float\n        Mean of the trauma stabilisation distribution (Exponential)\n\n    trauma_treat_mean: float\n        Mean of the trauma cubicle treatment distribution (Lognormal)\n\n    trauma_treat_var: float\n        Variance of the trauma cubicle treatment distribution (Lognormal)\n\n    non_trauma_treat_mean: float\n        Mean of the non trauma treatment distribution\n\n    non_trauma_treat_var: float\n        Variance of the non trauma treatment distribution\n\n    non_trauma_treat_p: float\n        Probability non trauma patient requires treatment\n\n    prob_trauma: float\n        probability that a new arrival is a trauma patient.\n    '''\n    random_number_set = 42\n\n    n_triage=2\n    n_reg=2\n    n_exam=3\n    n_trauma=4\n    n_cubicles_non_trauma_treat=4\n    n_cubicles_trauma_treat=5\n\n    triage_mean=6\n    reg_mean=8\n    reg_var=2\n    exam_mean=16\n    exam_var=3\n    trauma_mean=90\n    trauma_treat_mean=30\n    trauma_treat_var=4\n    non_trauma_treat_mean=13.3\n    non_trauma_treat_var=2\n\n    non_trauma_treat_p=0.6\n    prob_trauma=0.12\n\n    arrival_df=\"ed_arrivals.csv\"\n\n    sim_duration = 600\n    number_of_runs = 100\n\n# Class representing patients coming in to the clinic.\nclass Patient:\n    '''\n    Class defining details for a patient entity\n    '''\n    def __init__(self, p_id):\n        '''\n        Constructor method\n\n        Params:\n        -----\n        identifier: int\n            a numeric identifier for the patient.\n        '''\n        self.identifier = p_id\n\n        # Time of arrival in model/at centre\n        self.arrival = -np.inf\n        # Total time in pathway\n        self.total_time = -np.inf\n\n        # Shared waits\n        self.wait_triage = -np.inf\n        self.wait_reg = -np.inf\n        self.wait_treat = -np.inf\n        # Non-trauma pathway - examination wait\n        self.wait_exam = -np.inf\n        # Trauma pathway - stabilisation wait\n        self.wait_trauma = -np.inf\n\n        # Shared durations\n        self.triage_duration = -np.inf\n        self.reg_duration = -np.inf\n        self.treat_duration = -np.inf\n\n        # Non-trauma pathway - examination duration\n        self.exam_duration = -np.inf\n        # Trauma pathway - stabilisation duration\n        self.trauma_duration = -np.inf\n\n\n# Class representing our model of the clinic.\nclass Model:\n    '''\n    Simulates the simplest minor treatment process for a patient\n\n    1. Arrive\n    2. Examined/treated by nurse when one available\n    3. Discharged\n    '''\n    # Constructor to set up the model for a run.  We pass in a run number when\n    # we create a new model.\n    def __init__(self, run_number):\n        # Create a SimPy environment in which everything will live\n        self.env = simpy.Environment()\n\n        self.event_log = []\n\n        # Create a patient counter (which we'll use as a patient ID)\n        self.patient_counter = 0\n\n        self.trauma_patients = []\n        self.non_trauma_patients = []\n\n        # Create our resources\n        self.init_resources()\n\n        # Store the passed in run number\n        self.run_number = run_number\n\n        # Create a new Pandas DataFrame that will store some results against\n        # the patient ID (which we'll use as the index).\n        self.results_df = pd.DataFrame()\n        self.results_df[\"Patient ID\"] = [1]\n        self.results_df[\"Queue Time Cubicle\"] = [0.0]\n        self.results_df[\"Time with Nurse\"] = [0.0]\n        self.results_df.set_index(\"Patient ID\", inplace=True)\n\n        # Create an attribute to store the mean queuing times across this run of\n        # the model\n        self.mean_q_time_cubicle = 0\n\n        # create distributions\n\n        # Triage duration\n        self.triage_dist = Exponential(g.triage_mean,\n                                       random_seed=self.run_number*g.random_number_set)\n\n        # Registration duration (non-trauma only)\n        self.reg_dist = Lognormal(g.reg_mean,\n                                  np.sqrt(g.reg_var),\n                                  random_seed=self.run_number*g.random_number_set)\n\n        # Evaluation (non-trauma only)\n        self.exam_dist = Normal(g.exam_mean,\n                                np.sqrt(g.exam_var),\n                                random_seed=self.run_number*g.random_number_set)\n\n        # Trauma/stablisation duration (trauma only)\n        self.trauma_dist = Exponential(g.trauma_mean,\n                                       random_seed=self.run_number*g.random_number_set)\n\n        # Non-trauma treatment\n        self.nt_treat_dist = Lognormal(g.non_trauma_treat_mean,\n                                       np.sqrt(g.non_trauma_treat_var),\n                                       random_seed=self.run_number*g.random_number_set)\n\n        # treatment of trauma patients\n        self.treat_dist = Lognormal(g.trauma_treat_mean,\n                                    np.sqrt(g.non_trauma_treat_var),\n                                    random_seed=self.run_number*g.random_number_set)\n\n        # probability of non-trauma patient requiring treatment\n        self.nt_p_treat_dist = Bernoulli(g.non_trauma_treat_p,\n                                         random_seed=self.run_number*g.random_number_set)\n\n        # probability of non-trauma versus trauma patient\n        self.p_trauma_dist = Bernoulli(g.prob_trauma,\n                                       random_seed=self.run_number*g.random_number_set)\n\n        # init sampling for non-stationary poisson process\n        self.init_nspp()\n\n    def init_nspp(self):\n\n        # read arrival profile\n        self.arrivals = pd.read_csv(g.arrival_df)  # pylint: disable=attribute-defined-outside-init\n        self.arrivals['mean_iat'] = 60 / self.arrivals['arrival_rate']\n\n        # maximum arrival rate (smallest time between arrivals)\n        self.lambda_max = self.arrivals['arrival_rate'].max()  # pylint: disable=attribute-defined-outside-init\n\n        # thinning exponential\n        self.arrival_dist = Exponential(60.0 / self.lambda_max,  # pylint: disable=attribute-defined-outside-init\n                                            random_seed=self.run_number*g.random_number_set)\n\n        # thinning uniform rng\n        self.thinning_rng = Uniform(low=0.0, high=1.0,  # pylint: disable=attribute-defined-outside-init\n                                    random_seed=self.run_number*g.random_number_set)\n\n\n    def init_resources(self):\n        '''\n        Init the number of resources\n        and store in the arguments container object\n\n        Resource list:\n            1. Nurses/treatment bays (same thing in this model)\n\n        '''\n        # Shared Resources\n        self.triage_cubicles = simpy.Store(self.env)\n        populate_store(num_resources=g.n_triage,\n                simpy_store=self.triage_cubicles,\n                sim_env=self.env)\n\n        self.registration_cubicles = simpy.Store(self.env)\n        populate_store(num_resources=g.n_reg,\n                       simpy_store=self.registration_cubicles,\n                       sim_env=self.env)\n\n        # Non-trauma\n        self.exam_cubicles = simpy.Store(self.env)\n        populate_store(num_resources=g.n_exam,\n                       simpy_store=self.exam_cubicles,\n                       sim_env=self.env)\n\n        self.non_trauma_treatment_cubicles = simpy.Store(self.env)\n        populate_store(num_resources=g.n_cubicles_non_trauma_treat,\n                       simpy_store=self.non_trauma_treatment_cubicles,\n                       sim_env=self.env)\n\n        # Trauma\n        self.trauma_stabilisation_bays = simpy.Store(self.env)\n        populate_store(num_resources=g.n_trauma,\n                       simpy_store=self.trauma_stabilisation_bays,\n                       sim_env=self.env)\n\n        self.trauma_treatment_cubicles = simpy.Store(self.env)\n        populate_store(num_resources=g.n_cubicles_trauma_treat,\n                       simpy_store=self.trauma_treatment_cubicles,\n                       sim_env=self.env)\n\n    # A generator function that represents the DES generator for patient\n    # arrivals\n    def generator_patient_arrivals(self):\n        # We use an infinite loop here to keep doing this indefinitely whilst\n        # the simulation runs\n        while True:\n            t = int(self.env.now // 60) % self.arrivals.shape[0]\n            lambda_t = self.arrivals['arrival_rate'].iloc[t]\n\n            # set to a large number so that at least 1 sample taken!\n            u = np.Inf\n\n            interarrival_time = 0.0\n            # reject samples if u &gt;= lambda_t / lambda_max\n            while u &gt;= (lambda_t / self.lambda_max):\n                interarrival_time += self.arrival_dist.sample()\n                u = self.thinning_rng.sample()\n\n            # Freeze this instance of this function in place until the\n            # inter-arrival time we sampled above has elapsed.  Note - time in\n            # SimPy progresses in \"Time Units\", which can represent anything\n            # you like (just make sure you're consistent within the model)\n            yield self.env.timeout(interarrival_time)\n\n            # Increment the patient counter by 1 (this means our first patient\n            # will have an ID of 1)\n            self.patient_counter += 1\n\n            # Create a new patient - an instance of the Patient Class we\n            # defined above.  Remember, we pass in the ID when creating a\n            # patient - so here we pass the patient counter to use as the ID.\n            p = Patient(self.patient_counter)\n\n            trace(f'patient {self.patient_counter} arrives at: {self.env.now:.3f}')\n            self.event_log.append(\n                {'patient': self.patient_counter,\n                 'pathway': 'Shared',\n                 'event': 'arrival',\n                 'event_type': 'arrival_departure',\n                 'time': self.env.now}\n            )\n\n            # sample if the patient is trauma or non-trauma\n            trauma = self.p_trauma_dist.sample()\n\n            # Tell SimPy to start up the attend_clinic generator function with\n            # this patient (the generator function that will model the\n            # patient's journey through the system)\n            # and store patient in list for later easy access\n            if trauma:\n                # create and store a trauma patient to update KPIs.\n                self.trauma_patients.append(p)\n                self.env.process(self.attend_trauma_pathway(p))\n\n            else:\n                # create and store a non-trauma patient to update KPIs.\n                self.non_trauma_patients.append(p)\n                self.env.process(self.attend_non_trauma_pathway(p))\n\n    # A generator function that represents the pathway for a patient going\n    # through the clinic.\n    # The patient object is passed in to the generator function so we can\n    # extract information from / record information to it\n    def attend_non_trauma_pathway(self, patient):\n        '''\n        simulates the non-trauma/minor treatment process for a patient\n\n        1. request and wait for sign-in/triage\n        2. patient registration\n        3. examination\n        4a. percentage discharged\n        4b. remaining percentage treatment then discharge\n        '''\n        # record the time of arrival and entered the triage queue\n        patient.arrival = self.env.now\n        self.event_log.append(\n            {'patient': patient.identifier,\n             'pathway': 'Non-Trauma',\n             'event_type': 'queue',\n             'event': 'triage_wait_begins',\n             'time': self.env.now}\n        )\n\n        ###################################################\n        # request sign-in/triage\n        triage_resource = yield self.triage_cubicles.get()\n\n        # record the waiting time for triage\n        patient.wait_triage = self.env.now - patient.arrival\n        trace(f'patient {patient.identifier} triaged to minors '\n                f'{self.env.now:.3f}')\n        self.event_log.append(\n            {'patient': patient.identifier,\n                'pathway': 'Non-Trauma',\n                'event_type': 'resource_use',\n                'event': 'triage_begins',\n                'time': self.env.now,\n                'resource_id': triage_resource.id_attribute\n                }\n        )\n\n        # sample triage duration.\n        patient.triage_duration = self.triage_dist.sample()\n        yield self.env.timeout(patient.triage_duration)\n\n        trace(f'triage {patient.identifier} complete {self.env.now:.3f}; '\n                f'waiting time was {patient.wait_triage:.3f}')\n        self.event_log.append(\n            {'patient': patient.identifier,\n                'pathway': 'Non-Trauma',\n                'event_type': 'resource_use_end',\n                'event': 'triage_complete',\n                'time': self.env.now,\n                'resource_id': triage_resource.id_attribute}\n        )\n\n        # Resource is no longer in use, so put it back in the store\n        self.triage_cubicles.put(triage_resource)\n        #########################################################\n\n        # record the time that entered the registration queue\n        start_wait = self.env.now\n        self.event_log.append(\n            {'patient': patient.identifier,\n             'pathway': 'Non-Trauma',\n             'event_type': 'queue',\n             'event': 'MINORS_registration_wait_begins',\n             'time': self.env.now}\n        )\n\n        #########################################################\n        # request registration clerk\n        registration_resource = yield self.registration_cubicles.get()\n\n        # record the waiting time for registration\n        patient.wait_reg = self.env.now - start_wait\n        trace(f'registration of patient {patient.identifier} at '\n                f'{self.env.now:.3f}')\n        self.event_log.append(\n            {'patient': patient.identifier,\n                'pathway': 'Non-Trauma',\n                'event_type': 'resource_use',\n                'event': 'MINORS_registration_begins',\n                'time': self.env.now,\n                'resource_id': registration_resource.id_attribute\n                }\n        )\n\n        # sample registration duration.\n        patient.reg_duration = self.reg_dist.sample()\n        yield self.env.timeout(patient.reg_duration)\n\n        trace(f'patient {patient.identifier} registered at'\n                f'{self.env.now:.3f}; '\n                f'waiting time was {patient.wait_reg:.3f}')\n        self.event_log.append(\n            {'patient': patient.identifier,\n                'pathway': 'Non-Trauma',\n                'event': 'MINORS_registration_complete',\n                'event_type': 'resource_use_end',\n                'time': self.env.now,\n                'resource_id': registration_resource.id_attribute}\n        )\n        # Resource is no longer in use, so put it back in the store\n        self.registration_cubicles.put(registration_resource)\n        ########################################################\n\n        # record the time that entered the evaluation queue\n        start_wait = self.env.now\n\n        self.event_log.append(\n            {'patient': patient.identifier,\n             'pathway': 'Non-Trauma',\n             'event': 'MINORS_examination_wait_begins',\n             'event_type': 'queue',\n             'time': self.env.now}\n        )\n\n        #########################################################\n        # request examination resource\n        examination_resource = yield self.exam_cubicles.get()\n\n        # record the waiting time for examination to begin\n        patient.wait_exam = self.env.now - start_wait\n        trace(f'examination of patient {patient.identifier} begins '\n                f'{self.env.now:.3f}')\n        self.event_log.append(\n            {'patient': patient.identifier,\n                'pathway': 'Non-Trauma',\n                'event': 'MINORS_examination_begins',\n                'event_type': 'resource_use',\n                'time': self.env.now,\n                'resource_id': examination_resource.id_attribute\n                }\n        )\n\n        # sample examination duration.\n        patient.exam_duration = self.exam_dist.sample()\n        yield self.env.timeout(patient.exam_duration)\n\n        trace(f'patient {patient.identifier} examination complete '\n                f'at {self.env.now:.3f};'\n                f'waiting time was {patient.wait_exam:.3f}')\n        self.event_log.append(\n            {'patient': patient.identifier,\n                'pathway': 'Non-Trauma',\n                'event': 'MINORS_examination_complete',\n                'event_type': 'resource_use_end',\n                'time': self.env.now,\n                'resource_id': examination_resource.id_attribute}\n        )\n        # Resource is no longer in use, so put it back in\n        self.exam_cubicles.put(examination_resource)\n        ############################################################################\n\n        # sample if patient requires treatment?\n        patient.require_treat = self.nt_p_treat_dist.sample()  #pylint: disable=attribute-defined-outside-init\n\n        if patient.require_treat:\n\n            self.event_log.append(\n                {'patient': patient.identifier,\n                 'pathway': 'Non-Trauma',\n                 'event': 'requires_treatment',\n                 'event_type': 'attribute_assigned',\n                 'time': self.env.now}\n            )\n\n            # record the time that entered the treatment queue\n            start_wait = self.env.now\n            self.event_log.append(\n                {'patient': patient.identifier,\n                 'pathway': 'Non-Trauma',\n                 'event': 'MINORS_treatment_wait_begins',\n                 'event_type': 'queue',\n                 'time': self.env.now}\n            )\n            ###################################################\n            # request treatment cubicle\n\n            non_trauma_treatment_resource = yield self.non_trauma_treatment_cubicles.get()\n\n            # record the waiting time for treatment\n            patient.wait_treat = self.env.now - start_wait\n            trace(f'treatment of patient {patient.identifier} begins '\n                    f'{self.env.now:.3f}')\n            self.event_log.append(\n                {'patient': patient.identifier,\n                    'pathway': 'Non-Trauma',\n                    'event': 'MINORS_treatment_begins',\n                    'event_type': 'resource_use',\n                    'time': self.env.now,\n                    'resource_id': non_trauma_treatment_resource.id_attribute\n                }\n            )\n\n            # sample treatment duration.\n            patient.treat_duration = self.nt_treat_dist.sample()\n            yield self.env.timeout(patient.treat_duration)\n\n            trace(f'patient {patient.identifier} treatment complete '\n                    f'at {self.env.now:.3f};'\n                    f'waiting time was {patient.wait_treat:.3f}')\n            self.event_log.append(\n                {'patient': patient.identifier,\n                    'pathway': 'Non-Trauma',\n                    'event': 'MINORS_treatment_ends',\n                    'event_type': 'resource_use_end',\n                    'time': self.env.now,\n                    'resource_id': non_trauma_treatment_resource.id_attribute}\n            )\n\n            # Resource is no longer in use, so put it back in the store\n            self.non_trauma_treatment_cubicles.put(non_trauma_treatment_resource)\n        ##########################################################################\n\n        # Return to what happens to all patients, regardless of whether they were sampled as needing treatment\n        self.event_log.append(\n            {'patient': patient.identifier,\n            'pathway': 'Shared',\n            'event': 'depart',\n            'event_type': 'arrival_departure',\n            'time': self.env.now}\n        )\n\n        # total time in system\n        patient.total_time = self.env.now - patient.arrival\n\n    def attend_trauma_pathway(self, patient):\n        '''\n        simulates the major treatment process for a patient\n\n        1. request and wait for sign-in/triage\n        2. trauma\n        3. treatment\n        '''\n        # record the time of arrival and entered the triage queue\n        patient.arrival = self.env.now\n        self.event_log.append(\n            {'patient': patient.identifier,\n             'pathway': 'Trauma',\n             'event_type': 'queue',\n             'event': 'triage_wait_begins',\n             'time': self.env.now}\n        )\n\n        ###################################################\n        # request sign-in/triage\n        triage_resource = yield self.triage_cubicles.get()\n\n        # record the waiting time for triage\n        patient.wait_triage = self.env.now - patient.arrival\n\n        trace(f'patient {patient.identifier} triaged to trauma '\n                f'{self.env.now:.3f}')\n        self.event_log.append(\n            {'patient': patient.identifier,\n             'pathway': 'Trauma',\n             'event_type': 'resource_use',\n             'event': 'triage_begins',\n             'time': self.env.now,\n             'resource_id': triage_resource.id_attribute\n            }\n        )\n\n        # sample triage duration.\n        patient.triage_duration = self.triage_dist.sample()\n        yield self.env.timeout(patient.triage_duration)\n\n        trace(f'triage {patient.identifier} complete {self.env.now:.3f}; '\n              f'waiting time was {patient.wait_triage:.3f}')\n        self.event_log.append(\n            {'patient': patient.identifier,\n             'pathway': 'Trauma',\n             'event_type': 'resource_use_end',\n             'event': 'triage_complete',\n             'time': self.env.now,\n             'resource_id': triage_resource.id_attribute}\n        )\n\n        # Resource is no longer in use, so put it back in the store\n        self.triage_cubicles.put(triage_resource)\n        ###################################################\n\n        # record the time that entered the trauma queue\n        start_wait = self.env.now\n        self.event_log.append(\n            {'patient': patient.identifier,\n             'pathway': 'Trauma',\n             'event_type': 'queue',\n             'event': 'TRAUMA_stabilisation_wait_begins',\n             'time': self.env.now}\n        )\n\n        ###################################################\n        # request trauma room\n        trauma_resource = yield self.trauma_stabilisation_bays.get()\n\n        self.event_log.append(\n            {'patient': patient.identifier,\n                'pathway': 'Trauma',\n                'event_type': 'resource_use',\n                'event': 'TRAUMA_stabilisation_begins',\n                'time': self.env.now,\n                'resource_id': trauma_resource.id_attribute\n                }\n        )\n\n        # record the waiting time for trauma\n        patient.wait_trauma = self.env.now - start_wait\n\n        # sample stablisation duration.\n        patient.trauma_duration = self.trauma_dist.sample()\n        yield self.env.timeout(patient.trauma_duration)\n\n        trace(f'stabilisation of patient {patient.identifier} at '\n              f'{self.env.now:.3f}')\n        self.event_log.append(\n            {'patient': patient.identifier,\n             'pathway': 'Trauma',\n             'event_type': 'resource_use_end',\n             'event': 'TRAUMA_stabilisation_complete',\n             'time': self.env.now,\n             'resource_id': trauma_resource.id_attribute\n            }\n        )\n        # Resource is no longer in use, so put it back in the store\n        self.trauma_stabilisation_bays.put(trauma_resource)\n\n        #######################################################\n\n        # record the time that patient entered the treatment queue\n        start_wait = self.env.now\n        self.event_log.append(\n            {'patient': patient.identifier,\n             'pathway': 'Trauma',\n             'event_type': 'queue',\n             'event': 'TRAUMA_treatment_wait_begins',\n             'time': self.env.now}\n        )\n\n        ########################################################\n        # request treatment cubicle\n        trauma_treatment_resource = yield self.trauma_treatment_cubicles.get()\n\n        # record the waiting time for trauma\n        patient.wait_treat = self.env.now - start_wait\n        trace(f'treatment of patient {patient.identifier} at '\n                f'{self.env.now:.3f}')\n        self.event_log.append(\n            {'patient': patient.identifier,\n                'pathway': 'Trauma',\n                'event_type': 'resource_use',\n                'event': 'TRAUMA_treatment_begins',\n                'time': self.env.now,\n                'resource_id': trauma_treatment_resource.id_attribute\n                }\n        )\n\n        # sample treatment duration.\n        patient.treat_duration = self.trauma_dist.sample()\n        yield self.env.timeout(patient.treat_duration)\n\n        trace(f'patient {patient.identifier} treatment complete {self.env.now:.3f}; '\n              f'waiting time was {patient.wait_treat:.3f}')\n        self.event_log.append(\n            {'patient': patient.identifier,\n             'pathway': 'Trauma',\n             'event_type': 'resource_use_end',\n             'event': 'TRAUMA_treatment_complete',\n             'time': self.env.now,\n             'resource_id': trauma_treatment_resource.id_attribute}\n        )\n        self.event_log.append(\n            {'patient': patient.identifier,\n            'pathway': 'Shared',\n            'event': 'depart',\n            'event_type': 'arrival_departure',\n            'time': self.env.now}\n        )\n\n        # Resource is no longer in use, so put it back in the store\n        self.trauma_treatment_cubicles.put(trauma_treatment_resource)\n\n        #########################################################\n\n        # total time in system\n        patient.total_time = self.env.now - patient.arrival\n\n\n    # This method calculates results over a single run.  Here we just calculate\n    # a mean, but in real world models you'd probably want to calculate more.\n    def calculate_run_results(self):\n        # Take the mean of the queuing times across patients in this run of the\n        # model.\n        self.mean_q_time_cubicle = self.results_df[\"Queue Time Cubicle\"].mean()\n\n    # The run method starts up the DES entity generators, runs the simulation,\n    # and in turns calls anything we need to generate results for the run\n    def run(self):\n        # Start up our DES entity generators that create new patients.  We've\n        # only got one in this model, but we'd need to do this for each one if\n        # we had multiple generators.\n        self.env.process(self.generator_patient_arrivals())\n\n        # Run the model for the duration specified in g class\n        self.env.run(until=g.sim_duration)\n\n        # Now the simulation run has finished, call the method that calculates\n        # run results\n        self.calculate_run_results()\n\n        self.event_log = pd.DataFrame(self.event_log)\n\n        self.event_log[\"run\"] = self.run_number\n\n        return {'results': self.results_df, 'event_log': self.event_log}\n\n# Class representing a Trial for our simulation - a batch of simulation runs.\nclass Trial:\n    # The constructor sets up a pandas dataframe that will store the key\n    # results from each run against run number, with run number as the index.\n    def  __init__(self):\n        self.df_trial_results = pd.DataFrame()\n        self.df_trial_results[\"Run Number\"] = [0]\n        self.df_trial_results[\"Arrivals\"] = [0]\n        self.df_trial_results[\"Mean Queue Time Cubicle\"] = [0.0]\n        self.df_trial_results.set_index(\"Run Number\", inplace=True)\n\n        self.all_event_logs = []\n\n    # Method to run a trial\n    def run_trial(self):\n        # Run the simulation for the number of runs specified in g class.\n        # For each run, we create a new instance of the Model class and call its\n        # run method, which sets everything else in motion.  Once the run has\n        # completed, we grab out the stored run results (just mean queuing time\n        # here) and store it against the run number in the trial results\n        # dataframe.\n        for run in range(g.number_of_runs):\n            random.seed(run)\n\n            my_model = Model(run)\n            model_outputs = my_model.run()\n            patient_level_results = model_outputs[\"results\"]\n            event_log = model_outputs[\"event_log\"]\n\n            self.df_trial_results.loc[run] = [\n                len(patient_level_results),\n                my_model.mean_q_time_cubicle,\n            ]\n\n            # print(event_log)\n\n            self.all_event_logs.append(event_log)\n\n        self.all_event_logs = pd.concat(self.all_event_logs)\n\n\n\n\nmy_trial = Trial()\n\nmy_trial.run_trial()\n\n\nmy_trial.all_event_logs.head(50)\n\n\n\n\n\n\n\n\npatient\npathway\nevent\nevent_type\ntime\nresource_id\nrun\n\n\n\n\n0\n1\nShared\narrival\narrival_departure\n3.285355\nNaN\n0\n\n\n1\n1\nNon-Trauma\ntriage_wait_begins\nqueue\n3.285355\nNaN\n0\n\n\n2\n1\nNon-Trauma\ntriage_begins\nresource_use\n3.285355\n1.0\n0\n\n\n3\n2\nShared\narrival\narrival_departure\n3.289691\nNaN\n0\n\n\n4\n2\nNon-Trauma\ntriage_wait_begins\nqueue\n3.289691\nNaN\n0\n\n\n5\n2\nNon-Trauma\ntriage_begins\nresource_use\n3.289691\n2.0\n0\n\n\n6\n1\nNon-Trauma\ntriage_complete\nresource_use_end\n7.364946\n1.0\n0\n\n\n7\n1\nNon-Trauma\nMINORS_registration_wait_begins\nqueue\n7.364946\nNaN\n0\n\n\n8\n1\nNon-Trauma\nMINORS_registration_begins\nresource_use\n7.364946\n1.0\n0\n\n\n9\n2\nNon-Trauma\ntriage_complete\nresource_use_end\n9.407274\n2.0\n0\n\n\n10\n2\nNon-Trauma\nMINORS_registration_wait_begins\nqueue\n9.407274\nNaN\n0\n\n\n11\n2\nNon-Trauma\nMINORS_registration_begins\nresource_use\n9.407274\n2.0\n0\n\n\n12\n1\nNon-Trauma\nMINORS_registration_complete\nresource_use_end\n15.418481\n1.0\n0\n\n\n13\n1\nNon-Trauma\nMINORS_examination_wait_begins\nqueue\n15.418481\nNaN\n0\n\n\n14\n1\nNon-Trauma\nMINORS_examination_begins\nresource_use\n15.418481\n1.0\n0\n\n\n15\n2\nNon-Trauma\nMINORS_registration_complete\nresource_use_end\n17.104670\n2.0\n0\n\n\n16\n2\nNon-Trauma\nMINORS_examination_wait_begins\nqueue\n17.104670\nNaN\n0\n\n\n17\n2\nNon-Trauma\nMINORS_examination_begins\nresource_use\n17.104670\n2.0\n0\n\n\n18\n1\nNon-Trauma\nMINORS_examination_complete\nresource_use_end\n31.636252\n1.0\n0\n\n\n19\n1\nShared\ndepart\narrival_departure\n31.636252\nNaN\n0\n\n\n20\n2\nNon-Trauma\nMINORS_examination_complete\nresource_use_end\n32.875857\n2.0\n0\n\n\n21\n2\nNon-Trauma\nrequires_treatment\nattribute_assigned\n32.875857\nNaN\n0\n\n\n22\n2\nNon-Trauma\nMINORS_treatment_wait_begins\nqueue\n32.875857\nNaN\n0\n\n\n23\n2\nNon-Trauma\nMINORS_treatment_begins\nresource_use\n32.875857\n1.0\n0\n\n\n24\n3\nShared\narrival\narrival_departure\n33.426168\nNaN\n0\n\n\n25\n3\nNon-Trauma\ntriage_wait_begins\nqueue\n33.426168\nNaN\n0\n\n\n26\n3\nNon-Trauma\ntriage_begins\nresource_use\n33.426168\n1.0\n0\n\n\n27\n3\nNon-Trauma\ntriage_complete\nresource_use_end\n33.545008\n1.0\n0\n\n\n28\n3\nNon-Trauma\nMINORS_registration_wait_begins\nqueue\n33.545008\nNaN\n0\n\n\n29\n3\nNon-Trauma\nMINORS_registration_begins\nresource_use\n33.545008\n1.0\n0\n\n\n30\n4\nShared\narrival\narrival_departure\n37.900548\nNaN\n0\n\n\n31\n4\nNon-Trauma\ntriage_wait_begins\nqueue\n37.900548\nNaN\n0\n\n\n32\n4\nNon-Trauma\ntriage_begins\nresource_use\n37.900548\n2.0\n0\n\n\n33\n4\nNon-Trauma\ntriage_complete\nresource_use_end\n37.914164\n2.0\n0\n\n\n34\n4\nNon-Trauma\nMINORS_registration_wait_begins\nqueue\n37.914164\nNaN\n0\n\n\n35\n4\nNon-Trauma\nMINORS_registration_begins\nresource_use\n37.914164\n2.0\n0\n\n\n36\n3\nNon-Trauma\nMINORS_registration_complete\nresource_use_end\n42.359504\n1.0\n0\n\n\n37\n3\nNon-Trauma\nMINORS_examination_wait_begins\nqueue\n42.359504\nNaN\n0\n\n\n38\n3\nNon-Trauma\nMINORS_examination_begins\nresource_use\n42.359504\n3.0\n0\n\n\n39\n4\nNon-Trauma\nMINORS_registration_complete\nresource_use_end\n45.938325\n2.0\n0\n\n\n40\n4\nNon-Trauma\nMINORS_examination_wait_begins\nqueue\n45.938325\nNaN\n0\n\n\n41\n4\nNon-Trauma\nMINORS_examination_begins\nresource_use\n45.938325\n1.0\n0\n\n\n42\n2\nNon-Trauma\nMINORS_treatment_ends\nresource_use_end\n46.278797\n1.0\n0\n\n\n43\n2\nShared\ndepart\narrival_departure\n46.278797\nNaN\n0\n\n\n44\n5\nShared\narrival\narrival_departure\n51.770459\nNaN\n0\n\n\n45\n5\nNon-Trauma\ntriage_wait_begins\nqueue\n51.770459\nNaN\n0\n\n\n46\n5\nNon-Trauma\ntriage_begins\nresource_use\n51.770459\n1.0\n0\n\n\n47\n5\nNon-Trauma\ntriage_complete\nresource_use_end\n55.072516\n1.0\n0\n\n\n48\n5\nNon-Trauma\nMINORS_registration_wait_begins\nqueue\n55.072516\nNaN\n0\n\n\n49\n5\nNon-Trauma\nMINORS_registration_begins\nresource_use\n55.072516\n1.0\n0\n\n\n\n\n\n\n\n\nevent_position_df = pd.DataFrame([\n                # {'event': 'arrival', 'x':  10, 'y': 250, 'label': \"Arrival\" },\n\n                # Triage - minor and trauma\n                {'event': 'triage_wait_begins',\n                 'x':  160, 'y': 375, 'label': \"Waiting for&lt;br&gt;Triage\"  },\n                {'event': 'triage_begins',\n                 'x':  160, 'y': 315, 'resource':'n_triage', 'label': \"Being Triaged\" },\n\n                # Minors (non-trauma) pathway\n                {'event': 'MINORS_registration_wait_begins',\n                 'x':  300, 'y': 145, 'label': \"Waiting for&lt;br&gt;Registration\"  },\n                {'event': 'MINORS_registration_begins',\n                 'x':  300, 'y': 85, 'resource':'n_reg', 'label':'Being&lt;br&gt;Registered'  },\n\n                {'event': 'MINORS_examination_wait_begins',\n                 'x':  465, 'y': 145, 'label': \"Waiting for&lt;br&gt;Examination\"  },\n                {'event': 'MINORS_examination_begins',\n                 'x':  465, 'y': 85, 'resource':'n_exam', 'label': \"Being&lt;br&gt;Examined\" },\n\n                {'event': 'MINORS_treatment_wait_begins',\n                 'x':  630, 'y': 145, 'label': \"Waiting for&lt;br&gt;Treatment\"  },\n                {'event': 'MINORS_treatment_begins',\n                 'x':  630, 'y': 85, 'resource':'n_cubicles_non_trauma_treat', 'label': \"Being&lt;br&gt;Treated\" },\n\n                # Trauma pathway\n                {'event': 'TRAUMA_stabilisation_wait_begins',\n                 'x': 300, 'y': 560, 'label': \"Waiting for&lt;br&gt;Stabilisation\" },\n                {'event': 'TRAUMA_stabilisation_begins',\n                 'x': 300, 'y': 490, 'resource':'n_trauma', 'label': \"Being&lt;br&gt;Stabilised\" },\n\n                {'event': 'TRAUMA_treatment_wait_begins',\n                 'x': 630, 'y': 560, 'label': \"Waiting for&lt;br&gt;Treatment\" },\n                {'event': 'TRAUMA_treatment_begins',\n                 'x': 630, 'y': 490, 'resource':'n_cubicles_trauma_treat', 'label': \"Being&lt;br&gt;Treated\" },\n\n                 {'event': 'exit',\n                 'x':  670, 'y': 330, 'label': \"Exit\"}\n            ])\n\n\nanimate_activity_log(\n        event_log=my_trial.all_event_logs[my_trial.all_event_logs['run']==1],\n        event_position_df= event_position_df,\n        scenario=g(),\n        debug_mode=True,\n        setup_mode=True,\n        every_x_time_units=5,\n        include_play_button=True,\n        gap_between_entities=10,\n        gap_between_rows=20,\n        plotly_height=900,\n        plotly_width=1600,\n        override_x_max=700,\n        override_y_max=675,\n        icon_and_text_size=20,\n        wrap_queues_at=10,\n        step_snapshot_max=50,\n        limit_duration=g.sim_duration,\n        time_display_units=\"dhm\",\n        display_stage_labels=False,\n        add_background_image=\"https://raw.githubusercontent.com/Bergam0t/vidigi/refs/heads/main/examples/example_2_branching_multistep/Full%20Model%20Background%20Image%20-%20Horizontal%20Layout.drawio.png\",\n    )\n\nAnimation function called at 00:26:00\nIteration through minute-by-minute logs complete 00:26:00\nSnapshot df concatenation complete at 00:26:00\nReshaped animation dataframe finished construction at 00:26:01\nPlacement dataframe finished construction at 00:26:01\nOutput animation generation complete at 00:26:02\nTotal Time Elapsed: 2.07 seconds",
    "crumbs": [
      "Examples",
      "Example 2: Branching + Multi-step Case"
    ]
  },
  {
    "objectID": "examples/example_4_ciw/ex_4_ciw.html",
    "href": "examples/example_4_ciw/ex_4_ciw.html",
    "title": "Example 4: A ciw Model",
    "section": "",
    "text": "Note that this example is written using ciw 2.x\nIt will not run with 3.x - but could theoretically be adapted to do so\nThe ‘logs’ object is the result of running\nsim_engine.get_all_records()\nHowever, note that while we run multiple replications, we only pass the records for a single replication to the event_log_from_ciw_recs function.\n\nThe underlying model code is from Monks, T., Harper, A., & Heather, A. (2023). Towards Sharing Tools, Artefacts, and Reproducible Simulation: a ciw model example (v1.0.1). Zenodo. https://doi.org/10.5281/zenodo.10051494\nSee here for the adaptation embedded within that repo: https://github.com/Bergam0t/ciw-example-animation/tree/main\n\n\nimport pandas as pd\n# Import the wrapper objects for model interaction.\nfrom examples.example_4_ciw.ex_4_ciw_model import Experiment, multiple_replications\nfrom vidigi.utils import event_log_from_ciw_recs\nfrom vidigi.animation import animate_activity_log\nimport plotly.io as pio\npio.renderers.default = \"notebook\"\nimport os\n\n\n\n\n\n\n\nView Imported Code for the ciw model\n\n\n\n\n\n'''\nCiW Implementation of the 111 call centre\n\nTime units of the simulation model are in minutes.\n'''\n# Imports\n\nimport numpy as np\nimport pandas as pd\nimport ciw\n\n# Module level variables, constants, and default values\n\n# default resources\nN_OPERATORS = 13\n\n# number of nurses available\nN_NURSES = 9\n\n# default lambda for arrival distribution\nMEAN_IAT = 100.0 / 60.0\n\n## default service time parameters (triangular)\nCALL_LOW = 5.0\nCALL_MODE = 7.0\nCALL_HIGH = 10.0\n\n# nurse distribution parameters\nNURSE_CALL_LOW = 10.0\nNURSE_CALL_HIGH = 20.0\n\nCHANCE_CALLBACK = 0.4\n\n# run variables\nRESULTS_COLLECTION_PERIOD = 1000\n\n\n# Experiment class\nclass Experiment:\n    '''\n    Parameter class for 111 simulation model\n    '''\n    def __init__(self, n_operators=N_OPERATORS, n_nurses=N_NURSES,\n                 mean_iat=MEAN_IAT, call_low=CALL_LOW,\n                 call_mode=CALL_MODE, call_high=CALL_HIGH,\n                 chance_callback=CHANCE_CALLBACK,\n                 nurse_call_low=NURSE_CALL_LOW,\n                 nurse_call_high=NURSE_CALL_HIGH,\n                 random_seed=None):\n        '''\n        The init method sets up our defaults.\n        '''\n        self.n_operators = n_operators\n\n        # store the number of nurses in the experiment\n        self.n_nurses = n_nurses\n\n        # arrival distribution\n        self.arrival_dist = ciw.dists.Exponential(mean_iat)\n\n        # call duration\n        self.call_dist = ciw.dists.Triangular(call_low,\n                                              call_mode, call_high)\n\n        # duration of call with nurse\n        self.nurse_dist = ciw.dists.Uniform(nurse_call_low,\n                                            nurse_call_high)\n\n        # prob of call back\n        self.chance_callback = chance_callback\n\n        # initialise results to zero\n        self.init_results_variables()\n\n    def init_results_variables(self):\n        '''\n        Initialise all of the experiment variables used in results\n        collection.  This method is called at the start of each run\n        of the model\n        '''\n        # variable used to store results of experiment\n        self.results = {}\n        self.results['waiting_times'] = []\n\n        # total operator usage time for utilisation calculation.\n        self.results['total_call_duration'] = 0.0\n\n        # nurse sub process results collection\n        self.results['nurse_waiting_times'] = []\n        self.results['total_nurse_call_duration'] = 0.0\n\n\n# Model code\n\ndef get_model(args):\n    '''\n    Build a CiW model using the arguments provided.\n\n    Params:\n    -----\n    args: Experiment\n        container class for Experiment. Contains the model inputs/params\n\n    Returns:\n    --------\n    ciw.network.Network\n    '''\n    model = ciw.create_network(arrival_distributions=[args.arrival_dist,\n                                                      ciw.dists.NoArrivals()],\n                               service_distributions=[args.call_dist,\n                                                      args.nurse_dist],\n                               routing=[[0.0, args.chance_callback],\n                                        [0.0, 0.0]],\n                               number_of_servers=[args.n_operators,\n                                                  args.n_nurses])\n    return model\n\n\n# Model wrapper functions\n\ndef single_run(experiment,\n               rc_period=RESULTS_COLLECTION_PERIOD,\n               random_seed=None):\n    '''\n    Conduct a single run of the simulation model.\n\n    Params:\n    ------\n    args: Scenario\n        Parameter container\n\n    random_seed: int\n        Random seed to control simulation run.\n    '''\n\n    # results dictionary.  Each KPI is a new entry.\n    run_results = {}\n\n    # random seed\n    ciw.seed(random_seed)\n\n    # parameterise model\n    model = get_model(experiment)\n\n    # simulation engine\n    sim_engine = ciw.Simulation(model)\n\n    # run the model\n    sim_engine.simulate_until_max_time(rc_period)\n\n    # return processed results for run.\n\n    # get all results\n    recs = sim_engine.get_all_records()\n\n    # operator service times\n    op_servicetimes = [r.service_time for r in recs if r.node==1]\n    # nurse service times\n    nurse_servicetimes = [r.service_time for r in recs if r.node==2]\n\n    # operator and nurse waiting times\n    op_waits = [r.waiting_time for r in recs if r.node==1]\n    nurse_waits = [r.waiting_time for r in recs if r.node==2]\n\n    # mean measures\n    run_results['01_mean_waiting_time'] = np.mean(op_waits)\n\n    # end of run results: calculate mean operator utilisation\n    run_results['02_operator_util'] = \\\n        (sum(op_servicetimes) / (rc_period * experiment.n_operators)) * 100.0\n\n    # end of run results: nurse waiting time\n    run_results['03_mean_nurse_waiting_time'] = np.mean(nurse_waits)\n\n    # end of run results: calculate mean nurse utilisation\n    run_results['04_nurse_util'] = \\\n        (sum(nurse_servicetimes) / (rc_period * experiment.n_nurses)) * 100.0\n\n    # return the results from the run of the model\n    return run_results, recs\n\ndef multiple_replications(experiment,\n                          rc_period=RESULTS_COLLECTION_PERIOD,\n                          n_reps=5):\n    '''\n    Perform multiple replications of the model.\n\n    Params:\n    ------\n    experiment: Experiment\n        The experiment/paramaters to use with model\n\n    rc_period: float, optional (default=DEFAULT_RESULTS_COLLECTION_PERIOD)\n        results collection period.\n        the number of minutes to run the model to collect results\n\n    n_reps: int, optional (default=5)\n        Number of independent replications to run.\n\n    Returns:\n    --------\n    pandas.DataFrame\n    '''\n\n    # loop over single run to generate results dicts in a python list.\n    results = [single_run(experiment, rc_period)[0] for rep in range(n_reps)]\n    logs = [single_run(experiment, rc_period)[1] for rep in range(n_reps)]\n\n    # format and return results in a dataframe\n    df_results = pd.DataFrame(results)\n    df_results.index = np.arange(1, len(df_results)+1)\n    df_results.index.name = 'rep'\n    return df_results, logs\n\n\n\n\nN_OPERATORS = 18\nN_NURSES = 9\nRESULTS_COLLECTION_PERIOD = 1000\n\nuser_experiment = Experiment(n_operators=N_OPERATORS,\n                             n_nurses=N_NURSES,\n                             chance_callback=0.4)\n\n# run multiple replications\nresults, logs = multiple_replications(user_experiment, n_reps=10)\n\nWhile we’ve done multiple replications, for the purpose of the animation we want only a single set of logs, so we will extract those from the logs variable we created.\n\n# the 'logs' object contains a list, where each entry is the recs object for that run\nlogs_run_1 = logs[0]\n\nprint(len(logs_run_1))\n\n2248\n\n\n\n# let's print all of the outputs for a single individual\n[print(log) for log in logs_run_1 if log.id_number==500]\n\nRecord(id_number=500, customer_class=0, original_customer_class=0, node=1, arrival_date=297.2080070711834, waiting_time=0.0, service_start_date=297.2080070711834, service_time=6.854649823920681, service_end_date=304.06265689510406, time_blocked=0.0, exit_date=304.06265689510406, destination=-1, queue_size_at_arrival=11, queue_size_at_departure=13, server_id=10, record_type='service')\n\n\n[None]\n\n\nUnlike SimPy, where we have to manually add our event logs at various points, we instead can make use of the event_log_from_ciw_recs helper function from vidigi.utils to automatically reshape ciw logs into the correct format for vidigi to work with.\nFor each node, we pass in an appropriate name. Vidigi will use these and append ’_begins’ and ’_ends’, as well as calculating arrivals and departures from the model and creating resource IDs to allow it to correctly show the utilisation of a resource at each step.\n\n# let's now try turning this into an event log\nevent_log_test = event_log_from_ciw_recs(logs_run_1, node_name_list=[\"operator\", \"nurse\"])\n\nevent_log_test.head(25)\n\n\n\n\n\n\n\n\npatient\npathway\nevent_type\nevent\ntime\nresource_id\n\n\n\n\n0\n1\nModel\narrival_departure\narrival\n0.301004\nNaN\n\n\n1\n1\nModel\nqueue\noperator_wait_begins\n0.301004\nNaN\n\n\n2\n1\nModel\nresource_use\noperator_begins\n0.301004\n1.0\n\n\n3\n1\nModel\nresource_use\noperator_ends\n7.691679\n1.0\n\n\n4\n1\nModel\nqueue\nnurse_wait_begins\n7.691679\nNaN\n\n\n5\n1\nModel\nresource_use\nnurse_begins\n7.691679\n1.0\n\n\n6\n1\nModel\nresource_use\nnurse_ends\n26.900932\n1.0\n\n\n7\n1\nModel\narrival_departure\ndepart\n26.900932\nNaN\n\n\n8\n2\nModel\narrival_departure\narrival\n1.712850\nNaN\n\n\n9\n2\nModel\nqueue\noperator_wait_begins\n1.712850\nNaN\n\n\n10\n2\nModel\nresource_use\noperator_begins\n1.712850\n2.0\n\n\n11\n2\nModel\nresource_use\noperator_ends\n8.540378\n2.0\n\n\n12\n2\nModel\narrival_departure\ndepart\n8.540378\nNaN\n\n\n13\n3\nModel\narrival_departure\narrival\n2.222167\nNaN\n\n\n14\n3\nModel\nqueue\noperator_wait_begins\n2.222167\nNaN\n\n\n15\n3\nModel\nresource_use\noperator_begins\n2.222167\n3.0\n\n\n16\n3\nModel\nresource_use\noperator_ends\n10.025845\n3.0\n\n\n17\n3\nModel\narrival_departure\ndepart\n10.025845\nNaN\n\n\n18\n4\nModel\narrival_departure\narrival\n2.398089\nNaN\n\n\n19\n4\nModel\nqueue\noperator_wait_begins\n2.398089\nNaN\n\n\n20\n4\nModel\nresource_use\noperator_begins\n2.398089\n4.0\n\n\n21\n4\nModel\nresource_use\noperator_ends\n8.974532\n4.0\n\n\n22\n4\nModel\narrival_departure\ndepart\n8.974532\nNaN\n\n\n23\n5\nModel\narrival_departure\narrival\n3.028583\nNaN\n\n\n24\n5\nModel\nqueue\noperator_wait_begins\n3.028583\nNaN\n\n\n\n\n\n\n\nNow we need to create a suitable class to pass in the resource numbers to the animation function.\n\n# Create a suitable class to pass in the resource numbers to the animation function\nclass model_params():\n    def __init__(self):\n        self.n_operators = N_OPERATORS\n        self.n_nurses = N_NURSES\n\nparams = model_params()\n\nprint(f\"Number of operators: {params.n_operators}\")\nprint(f\"Number of nurses: {params.n_nurses}\")\n\nNumber of operators: 18\nNumber of nurses: 9\n\n\nLike with SimPy, we need to tell vidigi where to put each step on our plot. We will refer to the names we used - so as we named our nodes ‘operator’ and ‘nurse’, we will want\n\narrival\noperator_wait_begins (to show queueing for the operator)\noperator_begins (to show resource use of the operator)\nnurse_wait_begins (to show queuing for the nurse after finishing being seen by the operator)\nnurse_begins (to show resource use of the nurse)\n\nFor the _begins steps, which relat to resource use, we will also pass in a name that relates to the number of resources we need, which we defined in our model_params class above.\nSo, for the operator_begins step, for example, we tell t to look for n_operators, whch is one of the parameters in our model_params class. We pass the params class into the animation function.\n\n# Create required event_position_df for vidigi animation\nevent_position_df = pd.DataFrame([\n                    {'event': 'arrival',\n                     'x':  30, 'y': 350,\n                     'label': \"Arrival\"},\n\n                    {'event': 'operator_wait_begins',\n                     'x':  205, 'y': 270,\n                     'label': \"Waiting for Operator\"},\n\n                    {'event': 'operator_begins',\n                     'x':  210, 'y': 210,\n                     'resource':'n_operators',\n                     'label': \"Speaking to operator\"},\n\n                    {'event': 'nurse_wait_begins',\n                     'x':  205, 'y': 110,\n                     'label': \"Waiting for Nurse\"},\n\n                    {'event': 'nurse_begins',\n                     'x':  210, 'y': 50,\n                     'resource':'n_nurses',\n                     'label': \"Speaking to Nurse\"},\n\n                    {'event': 'exit',\n                     'x':  270, 'y': 10,\n                     'label': \"Exit\"}\n\n                ])\n\nevent_position_df\n\n\n\n\n\n\n\n\nevent\nx\ny\nlabel\nresource\n\n\n\n\n0\narrival\n30\n350\nArrival\nNaN\n\n\n1\noperator_wait_begins\n205\n270\nWaiting for Operator\nNaN\n\n\n2\noperator_begins\n210\n210\nSpeaking to operator\nn_operators\n\n\n3\nnurse_wait_begins\n205\n110\nWaiting for Nurse\nNaN\n\n\n4\nnurse_begins\n210\n50\nSpeaking to Nurse\nn_nurses\n\n\n5\nexit\n270\n10\nExit\nNaN\n\n\n\n\n\n\n\nFinally, we can create the animation.\n\n# Create animation\nparams = model_params()\n\nanimate_activity_log(\n        event_log=event_log_test,\n        event_position_df= event_position_df,\n        scenario=model_params(),\n        debug_mode=True,\n        setup_mode=False,\n        every_x_time_units=1,\n        include_play_button=True,\n        icon_and_text_size=20,\n        gap_between_entities=8,\n        gap_between_rows=25,\n        plotly_height=700,\n        frame_duration=200,\n        plotly_width=1200,\n        override_x_max=300,\n        override_y_max=300,\n        limit_duration=RESULTS_COLLECTION_PERIOD,\n        wrap_queues_at=25,\n        wrap_resources_at=50,\n        step_snapshot_max=75,\n        time_display_units=\"dhm\",\n        display_stage_labels=True,\n    )\n\nAnimation function called at 00:25:28\nIteration through minute-by-minute logs complete 00:25:33\nSnapshot df concatenation complete at 00:25:33\nReshaped animation dataframe finished construction at 00:25:33\nPlacement dataframe finished construction at 00:25:34\nOutput animation generation complete at 00:25:39\nTotal Time Elapsed: 11.07 seconds",
    "crumbs": [
      "Examples",
      "Example 4: A ciw Model"
    ]
  },
  {
    "objectID": "examples/example_5_simplest_case_wrapped_resources/ex_5_simplest_case_wrapped_resource.html",
    "href": "examples/example_5_simplest_case_wrapped_resources/ex_5_simplest_case_wrapped_resource.html",
    "title": "Example 5: Simplest Case with Higher Number of Resources - Resource Wrapping Demonstration",
    "section": "",
    "text": "from examples.example_1_simplest_case.ex_1_model_classes_with_vidigi_logging import Trial, g\nfrom vidigi.animation import animate_activity_log\nimport pandas as pd\nimport plotly.io as pio\npio.renderers.default = \"notebook\"\nimport os",
    "crumbs": [
      "Examples",
      "Example 5: Simplest Case with Higher Number of Resources - Resource Wrapping Demonstration"
    ]
  },
  {
    "objectID": "examples/example_5_simplest_case_wrapped_resources/ex_5_simplest_case_wrapped_resource.html#demonstrate-issues-with-wrapping-not-implemented",
    "href": "examples/example_5_simplest_case_wrapped_resources/ex_5_simplest_case_wrapped_resource.html#demonstrate-issues-with-wrapping-not-implemented",
    "title": "Example 5: Simplest Case with Higher Number of Resources - Resource Wrapping Demonstration",
    "section": "Demonstrate issues with wrapping not implemented",
    "text": "Demonstrate issues with wrapping not implemented\n\ng.n_cubicles = 30\ng.trauma_treat_mean = 120\ng.trauma_treat_var = 20\ng.arrival_rate = 3\n\n\nmy_trial = Trial()\n\nmy_trial.run_trial()\n\n30 nurses\n\n\n\n\nmy_trial.all_event_logs.head(20)\n\n\n\n\n\n\n\n\npatient\npathway\nevent_type\nevent\ntime\nresource_id\nrun\n\n\n\n\n0\n1\nSimplest\narrival_departure\narrival\n0.000000\nNaN\n0\n\n\n1\n1\nSimplest\nqueue\ntreatment_wait_begins\n0.000000\nNaN\n0\n\n\n2\n1\nSimplest\nresource_use\ntreatment_begins\n0.000000\n1.0\n0\n\n\n3\n2\nSimplest\narrival_departure\narrival\n2.039796\nNaN\n0\n\n\n4\n2\nSimplest\nqueue\ntreatment_wait_begins\n2.039796\nNaN\n0\n\n\n5\n2\nSimplest\nresource_use\ntreatment_begins\n2.039796\n2.0\n0\n\n\n6\n3\nSimplest\narrival_departure\narrival\n5.098587\nNaN\n0\n\n\n7\n3\nSimplest\nqueue\ntreatment_wait_begins\n5.098587\nNaN\n0\n\n\n8\n3\nSimplest\nresource_use\ntreatment_begins\n5.098587\n3.0\n0\n\n\n9\n4\nSimplest\narrival_departure\narrival\n5.158007\nNaN\n0\n\n\n10\n4\nSimplest\nqueue\ntreatment_wait_begins\n5.158007\nNaN\n0\n\n\n11\n4\nSimplest\nresource_use\ntreatment_begins\n5.158007\n4.0\n0\n\n\n12\n5\nSimplest\narrival_departure\narrival\n5.164815\nNaN\n0\n\n\n13\n5\nSimplest\nqueue\ntreatment_wait_begins\n5.164815\nNaN\n0\n\n\n14\n5\nSimplest\nresource_use\ntreatment_begins\n5.164815\n5.0\n0\n\n\n15\n6\nSimplest\narrival_departure\narrival\n6.815844\nNaN\n0\n\n\n16\n6\nSimplest\nqueue\ntreatment_wait_begins\n6.815844\nNaN\n0\n\n\n17\n6\nSimplest\nresource_use\ntreatment_begins\n6.815844\n6.0\n0\n\n\n18\n7\nSimplest\narrival_departure\narrival\n11.705665\nNaN\n0\n\n\n19\n7\nSimplest\nqueue\ntreatment_wait_begins\n11.705665\nNaN\n0\n\n\n\n\n\n\n\n\nevent_position_df = pd.DataFrame([\n                    {'event': 'arrival',\n                     'x':  50, 'y': 300,\n                     'label': \"Arrival\" },\n\n                    # Triage - minor and trauma\n                    {'event': 'treatment_wait_begins',\n                     'x':  205, 'y': 275,\n                     'label': \"Waiting for Treatment\"},\n\n                    {'event': 'treatment_begins',\n                     'x':  205, 'y': 175,\n                     'resource':'n_cubicles',\n                     'label': \"Being Treated\"},\n\n                    {'event': 'exit',\n                     'x':  270, 'y': 70,\n                     'label': \"Exit\"}\n\n                ])\n\n\nanimate_activity_log(\n        event_log=my_trial.all_event_logs[my_trial.all_event_logs['run']==1],\n        event_position_df= event_position_df,\n        scenario=g(),\n        debug_mode=True,\n        setup_mode=False,\n        every_x_time_units=1,\n        include_play_button=True,\n        icon_and_text_size=20,\n        gap_between_entities=6,\n        gap_between_rows=25,\n        plotly_height=700,\n        frame_duration=200,\n        plotly_width=1200,\n        override_x_max=300,\n        override_y_max=500,\n        limit_duration=g.sim_duration,\n        wrap_queues_at=25,\n        wrap_resources_at=None,\n        step_snapshot_max=125,\n        time_display_units=\"dhm\",\n        display_stage_labels=False,\n        add_background_image=\"https://raw.githubusercontent.com/Bergam0t/vidigi/refs/heads/main/examples/example_1_simplest_case/Simplest%20Model%20Background%20Image%20-%20Horizontal%20Layout.drawio.png\",\n    )\n\nAnimation function called at 01:03:57\nIteration through minute-by-minute logs complete 01:04:01\nSnapshot df concatenation complete at 01:04:01\nReshaped animation dataframe finished construction at 01:04:02\nPlacement dataframe finished construction at 01:04:02\nOutput animation generation complete at 01:04:05\nTotal Time Elapsed: 7.40 seconds",
    "crumbs": [
      "Examples",
      "Example 5: Simplest Case with Higher Number of Resources - Resource Wrapping Demonstration"
    ]
  },
  {
    "objectID": "examples/example_5_simplest_case_wrapped_resources/ex_5_simplest_case_wrapped_resource.html#rerun-with-wrapped-resources",
    "href": "examples/example_5_simplest_case_wrapped_resources/ex_5_simplest_case_wrapped_resource.html#rerun-with-wrapped-resources",
    "title": "Example 5: Simplest Case with Higher Number of Resources - Resource Wrapping Demonstration",
    "section": "Rerun with wrapped resources",
    "text": "Rerun with wrapped resources\n\nanimate_activity_log(\n        event_log=my_trial.all_event_logs[my_trial.all_event_logs['run']==1],\n        event_position_df= event_position_df,\n        scenario=g(),\n        debug_mode=True,\n        setup_mode=False,\n        every_x_time_units=1,\n        include_play_button=True,\n        icon_and_text_size=20,\n        gap_between_entities=6,\n        gap_between_rows=25,\n        plotly_height=700,\n        frame_duration=200,\n        plotly_width=1200,\n        override_x_max=300,\n        override_y_max=500,\n        limit_duration=g.sim_duration,\n        wrap_queues_at=25,\n        wrap_resources_at=15,\n        step_snapshot_max=125,\n        time_display_units=\"dhm\",\n        display_stage_labels=False,\n        add_background_image=\"https://raw.githubusercontent.com/Bergam0t/vidigi/refs/heads/main/examples/example_1_simplest_case/Simplest%20Model%20Background%20Image%20-%20Horizontal%20Layout.drawio.png\",\n    )\n\nAnimation function called at 01:04:06\nIteration through minute-by-minute logs complete 01:04:09\nSnapshot df concatenation complete at 01:04:09\nReshaped animation dataframe finished construction at 01:04:09\nPlacement dataframe finished construction at 01:04:09\nOutput animation generation complete at 01:04:12\nTotal Time Elapsed: 6.40 seconds",
    "crumbs": [
      "Examples",
      "Example 5: Simplest Case with Higher Number of Resources - Resource Wrapping Demonstration"
    ]
  },
  {
    "objectID": "examples/example_5_simplest_case_wrapped_resources/ex_5_simplest_case_wrapped_resource.html#running-this-with-a-much-larger-number-of-resources",
    "href": "examples/example_5_simplest_case_wrapped_resources/ex_5_simplest_case_wrapped_resource.html#running-this-with-a-much-larger-number-of-resources",
    "title": "Example 5: Simplest Case with Higher Number of Resources - Resource Wrapping Demonstration",
    "section": "Running this with a much larger number of resources",
    "text": "Running this with a much larger number of resources\nThis demonstrates that vidigi can cope with relatively high numbers of resources being tracked.\nLet’s envisage the bays as beds instead, and do a bit of a rough tweak to our existing model parameters to pretend that this is playing out over a period of days instead of minutes.\n\ng.n_cubicles = 200\ng.trauma_treat_mean = 3*24\ng.trauma_treat_var = 10*24\ng.arrival_rate = 0.2\n\n\nmy_trial = Trial()\n\nmy_trial.run_trial()\n\n200 nurses\n\n\n\n\nevent_position_df = pd.DataFrame([\n                    {'event': 'arrival',\n                     'x':  5, 'y': 1250,\n                     'label': \"Arrival\" },\n\n                    # Triage - minor and trauma\n                    {'event': 'treatment_wait_begins',\n                     'x':  285, 'y': 790,\n                     'label': \"Waiting for\\nBed\"},\n\n                    {'event': 'treatment_begins',\n                     'x':  285, 'y': 130,\n                     'resource':'n_cubicles',\n                     'label': \"In a Bed\"},\n\n                    {'event': 'exit',\n                     'x':  320, 'y': 30,\n                     'label': \"Exit\"}\n\n                ])\n\n\nanimate_activity_log(\n        event_log=my_trial.all_event_logs[my_trial.all_event_logs['run']==1],\n        event_position_df= event_position_df,\n        scenario=g(),\n        debug_mode=True,\n        setup_mode=True,\n        every_x_time_units=1,\n        include_play_button=True,\n        icon_and_text_size=16,\n        gap_between_entities=10,\n        gap_between_resources=12,\n        gap_between_rows=50,\n        plotly_height=700,\n        frame_duration=500,\n        plotly_width=1200,\n        override_x_max=350,\n        override_y_max=1350,\n        limit_duration=g.sim_duration,\n        wrap_queues_at=25,\n        wrap_resources_at=20,\n        step_snapshot_max=250,\n        time_display_units=\"d\",\n        display_stage_labels=True,\n        custom_resource_icon=\"🛏️\"\n    )\n\nAnimation function called at 01:04:26\nIteration through minute-by-minute logs complete 01:04:31\nSnapshot df concatenation complete at 01:04:31\nReshaped animation dataframe finished construction at 01:04:31\nPlacement dataframe finished construction at 01:04:32\nOutput animation generation complete at 01:04:39\nTotal Time Elapsed: 13.00 seconds\n\n\n                                                \n\n\n\nIncrease the number of beds and rerun\n\ng.n_cubicles = 300\ng.trauma_treat_mean = 5*24\ng.trauma_treat_var = 10*24\ng.arrival_rate = 0.2\n\n\nmy_trial = Trial()\n\nmy_trial.run_trial()\n\n300 nurses\n\n\n\n\nevent_position_df = pd.DataFrame([\n                    {'event': 'arrival',\n                     'x':  5, 'y': 1900,\n                     'label': \"Arrival\" },\n\n                    # Triage - minor and trauma\n                    {'event': 'treatment_wait_begins',\n                     'x':  285, 'y': 1300,\n                     'label': \"Waiting for\\nBed\"},\n\n                    {'event': 'treatment_begins',\n                     'x':  285, 'y': 130,\n                     'resource':'n_cubicles',\n                     'label': \"In a Bed\"},\n\n                    {'event': 'exit',\n                     'x':  320, 'y': 30,\n                     'label': \"Exit\"}\n\n                ])\n\n\nanimate_activity_log(\n        event_log=my_trial.all_event_logs[my_trial.all_event_logs['run']==1],\n        event_position_df= event_position_df,\n        scenario=g(),\n        debug_mode=True,\n        setup_mode=False,\n        every_x_time_units=1,\n        include_play_button=True,\n        icon_and_text_size=14,\n        gap_between_entities=10,\n        gap_between_resources=13,\n        gap_between_rows=70,\n        plotly_height=850,\n        frame_duration=500,\n        plotly_width=1200,\n        override_x_max=350,\n        override_y_max=2650,\n        limit_duration=g.sim_duration,\n        wrap_queues_at=25,\n        wrap_resources_at=20,\n        step_snapshot_max=425, # Make sure this is larger than the number of resources you have!\n        time_display_units=\"d\",\n        display_stage_labels=True,\n        custom_resource_icon=\"🛏️\"\n    )\n\nAnimation function called at 01:04:55\nIteration through minute-by-minute logs complete 01:05:00\nSnapshot df concatenation complete at 01:05:01\nReshaped animation dataframe finished construction at 01:05:01\nPlacement dataframe finished construction at 01:05:02\nOutput animation generation complete at 01:05:10\nTotal Time Elapsed: 15.16 seconds\n\n\n                                                \n\n\nWe can see that even with this many resources displayed at once, performance in this simple model is acceptable.",
    "crumbs": [
      "Examples",
      "Example 5: Simplest Case with Higher Number of Resources - Resource Wrapping Demonstration"
    ]
  },
  {
    "objectID": "reference/animation.animate_activity_log.html",
    "href": "reference/animation.animate_activity_log.html",
    "title": "animation.animate_activity_log",
    "section": "",
    "text": "animation.animate_activity_log(\n    event_log,\n    event_position_df,\n    scenario=None,\n    every_x_time_units=10,\n    wrap_queues_at=20,\n    wrap_resources_at=20,\n    step_snapshot_max=50,\n    limit_duration=10 * 60 * 24,\n    plotly_height=900,\n    plotly_width=None,\n    include_play_button=True,\n    add_background_image=None,\n    display_stage_labels=True,\n    icon_and_text_size=24,\n    gap_between_entities=10,\n    gap_between_rows=30,\n    gap_between_resources=10,\n    resource_opacity=0.8,\n    custom_resource_icon=None,\n    override_x_max=None,\n    override_y_max=None,\n    time_display_units=None,\n    setup_mode=False,\n    frame_duration=400,\n    frame_transition_duration=600,\n    debug_mode=False,\n    custom_entity_icon_list=None,\n)\nGenerate an animated visualization of patient flow through a system.\nThis function processes event log data, adds positional information, and creates an interactive Plotly animation representing patient movement through various stages.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nevent_log\npd.DataFrame\nThe log of events to be animated, containing patient activities.\nrequired\n\n\nevent_position_df\npd.DataFrame\nDataFrame specifying the positions of different events, with columns ‘event’, ‘x’, and ‘y’.\nrequired\n\n\nscenario\nobject\nAn object containing attributes for resource counts at different steps.\nNone\n\n\nevery_x_time_units\nint\nTime interval between animation frames in minutes (default is 10).\n10\n\n\nwrap_queues_at\nint\nMaximum number of entities to display in a queue before wrapping to a new row (default is 20).\n20\n\n\nwrap_resources_at\nint\nNumber of resources to show before wrapping to a new row (default is 20).\n20\n\n\nstep_snapshot_max\nint\nMaximum number of patients to show in each snapshot per event (default is 50).\n50\n\n\nlimit_duration\nint\nMaximum duration to animate in minutes (default is 10 days or 14400 minutes).\n10 * 60 * 24\n\n\nplotly_height\nint\nHeight of the Plotly figure in pixels (default is 900).\n900\n\n\nplotly_width\nint\nWidth of the Plotly figure in pixels (default is None, which auto-adjusts).\nNone\n\n\ninclude_play_button\nbool\nWhether to include a play button in the animation (default is True).\nTrue\n\n\nadd_background_image\nstr\nPath to a background image file to add to the animation (default is None).\nNone\n\n\ndisplay_stage_labels\nbool\nWhether to display labels for each stage (default is True).\nTrue\n\n\nicon_and_text_size\nint\nSize of icons and text in the animation (default is 24).\n24\n\n\ngap_between_entities\nint\nHorizontal spacing between entities in pixels (default is 10).\n10\n\n\ngap_between_rows\nint\nVertical spacing between rows in pixels (default is 30).\n30\n\n\ngap_between_resources\nint\nHorizontal spacing between resources in pixels (default is 10).\n10\n\n\nresource_opacity\nfloat\nOpacity of resource icons (default is 0.8).\n0.8\n\n\ncustom_resource_icon\nstr\nCustom icon to use for resources (default is None).\nNone\n\n\noverride_x_max\nint\nOverride the maximum x-coordinate of the plot (default is None).\nNone\n\n\noverride_y_max\nint\nOverride the maximum y-coordinate of the plot (default is None).\nNone\n\n\ntime_display_units\nstr\nUnits for displaying time. Options are ‘dhm’ (days, hours, minutes), ‘d’ (days), or None (default).\nNone\n\n\nsetup_mode\nbool\nIf True, display grid and tick marks for initial setup (default is False).\nFalse\n\n\nframe_duration\nint\nDuration of each frame in milliseconds (default is 400).\n400\n\n\nframe_transition_duration\nint\nDuration of transition between frames in milliseconds (default is 600).\n600\n\n\ndebug_mode\nbool\nIf True, print debug information during processing (default is False).\nFalse\n\n\ncustom_entity_icon_list\n\nIf given, overrides the default list of emojis used to represent entities\nNone\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nplotly.graph_objs._figure.Figure\nAn animated Plotly figure object representing the patient flow.\n\n\n\n\n\n\n\nThis function uses helper functions: reshape_for_animations, generate_animation_df, and generate_animation.\nThe animation supports customization of icon sizes, resource representation, and animation speed.\nTime can be displayed as actual dates or as model time units.\nA background image can be added to provide context for the patient flow.\nThe function handles both queuing and resource use events.\n\n\n\n\n&gt;&gt;&gt; animation = animate_activity_log(event_log, event_positions, scenario,\n...                                  time_display_units='dhm',\n...                                  add_background_image='path/to/image.png')\n&gt;&gt;&gt; animation.show()",
    "crumbs": [
      "Reference",
      "All-In-One Animation Functions",
      "animation.animate_activity_log"
    ]
  },
  {
    "objectID": "reference/animation.animate_activity_log.html#parameters",
    "href": "reference/animation.animate_activity_log.html#parameters",
    "title": "animation.animate_activity_log",
    "section": "",
    "text": "Name\nType\nDescription\nDefault\n\n\n\n\nevent_log\npd.DataFrame\nThe log of events to be animated, containing patient activities.\nrequired\n\n\nevent_position_df\npd.DataFrame\nDataFrame specifying the positions of different events, with columns ‘event’, ‘x’, and ‘y’.\nrequired\n\n\nscenario\nobject\nAn object containing attributes for resource counts at different steps.\nNone\n\n\nevery_x_time_units\nint\nTime interval between animation frames in minutes (default is 10).\n10\n\n\nwrap_queues_at\nint\nMaximum number of entities to display in a queue before wrapping to a new row (default is 20).\n20\n\n\nwrap_resources_at\nint\nNumber of resources to show before wrapping to a new row (default is 20).\n20\n\n\nstep_snapshot_max\nint\nMaximum number of patients to show in each snapshot per event (default is 50).\n50\n\n\nlimit_duration\nint\nMaximum duration to animate in minutes (default is 10 days or 14400 minutes).\n10 * 60 * 24\n\n\nplotly_height\nint\nHeight of the Plotly figure in pixels (default is 900).\n900\n\n\nplotly_width\nint\nWidth of the Plotly figure in pixels (default is None, which auto-adjusts).\nNone\n\n\ninclude_play_button\nbool\nWhether to include a play button in the animation (default is True).\nTrue\n\n\nadd_background_image\nstr\nPath to a background image file to add to the animation (default is None).\nNone\n\n\ndisplay_stage_labels\nbool\nWhether to display labels for each stage (default is True).\nTrue\n\n\nicon_and_text_size\nint\nSize of icons and text in the animation (default is 24).\n24\n\n\ngap_between_entities\nint\nHorizontal spacing between entities in pixels (default is 10).\n10\n\n\ngap_between_rows\nint\nVertical spacing between rows in pixels (default is 30).\n30\n\n\ngap_between_resources\nint\nHorizontal spacing between resources in pixels (default is 10).\n10\n\n\nresource_opacity\nfloat\nOpacity of resource icons (default is 0.8).\n0.8\n\n\ncustom_resource_icon\nstr\nCustom icon to use for resources (default is None).\nNone\n\n\noverride_x_max\nint\nOverride the maximum x-coordinate of the plot (default is None).\nNone\n\n\noverride_y_max\nint\nOverride the maximum y-coordinate of the plot (default is None).\nNone\n\n\ntime_display_units\nstr\nUnits for displaying time. Options are ‘dhm’ (days, hours, minutes), ‘d’ (days), or None (default).\nNone\n\n\nsetup_mode\nbool\nIf True, display grid and tick marks for initial setup (default is False).\nFalse\n\n\nframe_duration\nint\nDuration of each frame in milliseconds (default is 400).\n400\n\n\nframe_transition_duration\nint\nDuration of transition between frames in milliseconds (default is 600).\n600\n\n\ndebug_mode\nbool\nIf True, print debug information during processing (default is False).\nFalse\n\n\ncustom_entity_icon_list\n\nIf given, overrides the default list of emojis used to represent entities\nNone",
    "crumbs": [
      "Reference",
      "All-In-One Animation Functions",
      "animation.animate_activity_log"
    ]
  },
  {
    "objectID": "reference/animation.animate_activity_log.html#returns",
    "href": "reference/animation.animate_activity_log.html#returns",
    "title": "animation.animate_activity_log",
    "section": "",
    "text": "Name\nType\nDescription\n\n\n\n\n\nplotly.graph_objs._figure.Figure\nAn animated Plotly figure object representing the patient flow.",
    "crumbs": [
      "Reference",
      "All-In-One Animation Functions",
      "animation.animate_activity_log"
    ]
  },
  {
    "objectID": "reference/animation.animate_activity_log.html#notes",
    "href": "reference/animation.animate_activity_log.html#notes",
    "title": "animation.animate_activity_log",
    "section": "",
    "text": "This function uses helper functions: reshape_for_animations, generate_animation_df, and generate_animation.\nThe animation supports customization of icon sizes, resource representation, and animation speed.\nTime can be displayed as actual dates or as model time units.\nA background image can be added to provide context for the patient flow.\nThe function handles both queuing and resource use events.",
    "crumbs": [
      "Reference",
      "All-In-One Animation Functions",
      "animation.animate_activity_log"
    ]
  },
  {
    "objectID": "reference/animation.animate_activity_log.html#examples",
    "href": "reference/animation.animate_activity_log.html#examples",
    "title": "animation.animate_activity_log",
    "section": "",
    "text": "&gt;&gt;&gt; animation = animate_activity_log(event_log, event_positions, scenario,\n...                                  time_display_units='dhm',\n...                                  add_background_image='path/to/image.png')\n&gt;&gt;&gt; animation.show()",
    "crumbs": [
      "Reference",
      "All-In-One Animation Functions",
      "animation.animate_activity_log"
    ]
  },
  {
    "objectID": "reference/index.html#all-in-one-animation-functions",
    "href": "reference/index.html#all-in-one-animation-functions",
    "title": "All Functions",
    "section": "All-In-One Animation Functions",
    "text": "All-In-One Animation Functions\n\n\n\nanimation.animate_activity_log\nGenerate an animated visualization of patient flow through a system.",
    "crumbs": [
      "Reference",
      "All Functions"
    ]
  },
  {
    "objectID": "reference/index.html#step-by-step-functions",
    "href": "reference/index.html#step-by-step-functions",
    "title": "All Functions",
    "section": "Step-By-Step Functions",
    "text": "Step-By-Step Functions\n\n\n\nprep.reshape_for_animations\nReshape event log data for animation purposes.\n\n\nprep.generate_animation_df\nGenerate a DataFrame for animation purposes by adding position information to patient data.\n\n\nanimation.generate_animation\nGenerate an animated visualization of patient flow through a system.",
    "crumbs": [
      "Reference",
      "All Functions"
    ]
  },
  {
    "objectID": "reference/index.html#simpy-utility-functions-and-classes",
    "href": "reference/index.html#simpy-utility-functions-and-classes",
    "title": "All Functions",
    "section": "Simpy Utility Functions and Classes",
    "text": "Simpy Utility Functions and Classes\n\n\n\nutils.populate_store\nPopulate a SimPy Store (or VidigiPriorityStore) with CustomResource objects.\n\n\nutils.CustomResource\nA custom resource class that extends simpy.Resource with an additional ID attribute.\n\n\nutils.VidigiPriorityStore\nA SimPy store that processes requests with priority.",
    "crumbs": [
      "Reference",
      "All Functions"
    ]
  },
  {
    "objectID": "reference/index.html#ciw-utility-functions",
    "href": "reference/index.html#ciw-utility-functions",
    "title": "All Functions",
    "section": "ciw Utility Functions",
    "text": "ciw Utility Functions\n\n\n\nutils.event_log_from_ciw_recs\nGiven the ciw recs object, return a dataframe in the format expected by the vidigi",
    "crumbs": [
      "Reference",
      "All Functions"
    ]
  },
  {
    "objectID": "reference/prep.reshape_for_animations.html",
    "href": "reference/prep.reshape_for_animations.html",
    "title": "prep.reshape_for_animations",
    "section": "",
    "text": "prep.reshape_for_animations(\n    event_log,\n    every_x_time_units=10,\n    limit_duration=10 * 60 * 24,\n    step_snapshot_max=50,\n    debug_mode=False,\n)\nReshape event log data for animation purposes.\nThis function processes an event log to create a series of snapshots at regular time intervals, suitable for creating animations of patient flow through a system.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nevent_log\npd.DataFrame\nThe input event log containing patient events and timestamps.\nrequired\n\n\nevery_x_time_units\nint\nThe time interval between snapshots in minutes (default is 10).\n10\n\n\nlimit_duration\nint\nThe maximum duration to consider in minutes (default is 10 days).\n10 * 60 * 24\n\n\nstep_snapshot_max\nint\nThe maximum number of patients to include in each snapshot for each event (default is 50).\n50\n\n\ndebug_mode\nbool\nIf True, print debug information during processing (default is False).\nFalse\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nDataFrame\nA reshaped DataFrame containing snapshots of patient positions at regular time intervals, sorted by minute and event.\n\n\n\n\n\n\n\nThe function creates snapshots of patient positions at specified time intervals.\nIt handles patients who are present in the system at each snapshot time.\nPatients are ranked within each event based on their arrival order.\nA maximum number of patients per event can be set to limit the number of patients who will be displayed on screen within any one event type at a time.\nAn ‘exit’ event is added for each patient at the end of their journey.\nThe function uses memory management techniques (del and gc.collect()) to handle large datasets.\n\n\n\n\n\nAdd behavior for when limit_duration is None.\nConsider adding ‘first step’ and ‘last step’ parameters.\nImplement pathway order and precedence columns.\nFix the automatic exit at the end of the simulation run for all patients.",
    "crumbs": [
      "Reference",
      "Step-By-Step Functions",
      "prep.reshape_for_animations"
    ]
  },
  {
    "objectID": "reference/prep.reshape_for_animations.html#parameters",
    "href": "reference/prep.reshape_for_animations.html#parameters",
    "title": "prep.reshape_for_animations",
    "section": "",
    "text": "Name\nType\nDescription\nDefault\n\n\n\n\nevent_log\npd.DataFrame\nThe input event log containing patient events and timestamps.\nrequired\n\n\nevery_x_time_units\nint\nThe time interval between snapshots in minutes (default is 10).\n10\n\n\nlimit_duration\nint\nThe maximum duration to consider in minutes (default is 10 days).\n10 * 60 * 24\n\n\nstep_snapshot_max\nint\nThe maximum number of patients to include in each snapshot for each event (default is 50).\n50\n\n\ndebug_mode\nbool\nIf True, print debug information during processing (default is False).\nFalse",
    "crumbs": [
      "Reference",
      "Step-By-Step Functions",
      "prep.reshape_for_animations"
    ]
  },
  {
    "objectID": "reference/prep.reshape_for_animations.html#returns",
    "href": "reference/prep.reshape_for_animations.html#returns",
    "title": "prep.reshape_for_animations",
    "section": "",
    "text": "Name\nType\nDescription\n\n\n\n\n\nDataFrame\nA reshaped DataFrame containing snapshots of patient positions at regular time intervals, sorted by minute and event.",
    "crumbs": [
      "Reference",
      "Step-By-Step Functions",
      "prep.reshape_for_animations"
    ]
  },
  {
    "objectID": "reference/prep.reshape_for_animations.html#notes",
    "href": "reference/prep.reshape_for_animations.html#notes",
    "title": "prep.reshape_for_animations",
    "section": "",
    "text": "The function creates snapshots of patient positions at specified time intervals.\nIt handles patients who are present in the system at each snapshot time.\nPatients are ranked within each event based on their arrival order.\nA maximum number of patients per event can be set to limit the number of patients who will be displayed on screen within any one event type at a time.\nAn ‘exit’ event is added for each patient at the end of their journey.\nThe function uses memory management techniques (del and gc.collect()) to handle large datasets.",
    "crumbs": [
      "Reference",
      "Step-By-Step Functions",
      "prep.reshape_for_animations"
    ]
  },
  {
    "objectID": "reference/prep.reshape_for_animations.html#todo",
    "href": "reference/prep.reshape_for_animations.html#todo",
    "title": "prep.reshape_for_animations",
    "section": "",
    "text": "Add behavior for when limit_duration is None.\nConsider adding ‘first step’ and ‘last step’ parameters.\nImplement pathway order and precedence columns.\nFix the automatic exit at the end of the simulation run for all patients.",
    "crumbs": [
      "Reference",
      "Step-By-Step Functions",
      "prep.reshape_for_animations"
    ]
  },
  {
    "objectID": "reference/utils.event_log_from_ciw_recs.html",
    "href": "reference/utils.event_log_from_ciw_recs.html",
    "title": "utils.event_log_from_ciw_recs",
    "section": "",
    "text": "utils.event_log_from_ciw_recs(ciw_recs_obj, node_name_list)\nGiven the ciw recs object, return a dataframe in the format expected by the vidigi functions - reshape_for_animation OR - animate_activity_log\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nciw_recs_obj\n\nThe output of the .get_all_records() method run on the ciw simulation object. This is a list of named tuples. See https://ciw.readthedocs.io/en/latest/Tutorial/GettingStarted/part_3.html and https://ciw.readthedocs.io/en/latest/Reference/results.html for more details.\nrequired\n\n\nnode_name_list\n\nUser-defined list of strings where each string relates to the resource or activity that will take place at that ciw node\nrequired\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\npd.DataFrame\n\n\n\n\n\n\n\nGiven the ciw recs object, if we know the nodes and what they relate to, we can build up a picture the arrival date for the first tuple for a given user ID is the arrival\nThen, for each node: - the arrival date for a given node is when they start queueing - the service start date is when they stop queueing - the service start date is when they begin using the resource - the service end date is when the resource use ends - the server ID is the equivalent of a simpy resource use ID\nA more complex multi-node example can be found in https://github.com/Bergam0t/ciw-example-animation in the files - ciw_model.py - vidigi_experiments.py",
    "crumbs": [
      "Reference",
      "ciw Utility Functions",
      "utils.event_log_from_ciw_recs"
    ]
  },
  {
    "objectID": "reference/utils.event_log_from_ciw_recs.html#parameters",
    "href": "reference/utils.event_log_from_ciw_recs.html#parameters",
    "title": "utils.event_log_from_ciw_recs",
    "section": "",
    "text": "Name\nType\nDescription\nDefault\n\n\n\n\nciw_recs_obj\n\nThe output of the .get_all_records() method run on the ciw simulation object. This is a list of named tuples. See https://ciw.readthedocs.io/en/latest/Tutorial/GettingStarted/part_3.html and https://ciw.readthedocs.io/en/latest/Reference/results.html for more details.\nrequired\n\n\nnode_name_list\n\nUser-defined list of strings where each string relates to the resource or activity that will take place at that ciw node\nrequired",
    "crumbs": [
      "Reference",
      "ciw Utility Functions",
      "utils.event_log_from_ciw_recs"
    ]
  },
  {
    "objectID": "reference/utils.event_log_from_ciw_recs.html#returns",
    "href": "reference/utils.event_log_from_ciw_recs.html#returns",
    "title": "utils.event_log_from_ciw_recs",
    "section": "",
    "text": "Name\nType\nDescription\n\n\n\n\n\npd.DataFrame",
    "crumbs": [
      "Reference",
      "ciw Utility Functions",
      "utils.event_log_from_ciw_recs"
    ]
  },
  {
    "objectID": "reference/utils.event_log_from_ciw_recs.html#notes",
    "href": "reference/utils.event_log_from_ciw_recs.html#notes",
    "title": "utils.event_log_from_ciw_recs",
    "section": "",
    "text": "Given the ciw recs object, if we know the nodes and what they relate to, we can build up a picture the arrival date for the first tuple for a given user ID is the arrival\nThen, for each node: - the arrival date for a given node is when they start queueing - the service start date is when they stop queueing - the service start date is when they begin using the resource - the service end date is when the resource use ends - the server ID is the equivalent of a simpy resource use ID\nA more complex multi-node example can be found in https://github.com/Bergam0t/ciw-example-animation in the files - ciw_model.py - vidigi_experiments.py",
    "crumbs": [
      "Reference",
      "ciw Utility Functions",
      "utils.event_log_from_ciw_recs"
    ]
  },
  {
    "objectID": "reference/utils.VidigiPriorityStore.html",
    "href": "reference/utils.VidigiPriorityStore.html",
    "title": "utils.VidigiPriorityStore",
    "section": "",
    "text": "utils.VidigiPriorityStore()\nA SimPy store that processes requests with priority.\nThis class extends the SimPy Store to include a priority queue for handling requests. Requests are processed based on their priority, submission time, and preemption flag.\nAttributes: GetQueue (class): A reference to the sorted queue implementation used for handling prioritized requests. get (class): A reference to the PriorityGet class, which handles the creation of prioritized requests.\n\n\nCredit to arabinelli # https://stackoverflow.com/questions/58603000/how-do-i-make-a-priority-get-request-from-resource-store",
    "crumbs": [
      "Reference",
      "Simpy Utility Functions and Classes",
      "utils.VidigiPriorityStore"
    ]
  },
  {
    "objectID": "reference/utils.VidigiPriorityStore.html#notes",
    "href": "reference/utils.VidigiPriorityStore.html#notes",
    "title": "utils.VidigiPriorityStore",
    "section": "",
    "text": "Credit to arabinelli # https://stackoverflow.com/questions/58603000/how-do-i-make-a-priority-get-request-from-resource-store",
    "crumbs": [
      "Reference",
      "Simpy Utility Functions and Classes",
      "utils.VidigiPriorityStore"
    ]
  },
  {
    "objectID": "vidigi_docs/index.html",
    "href": "vidigi_docs/index.html",
    "title": "vidigi (Visual Interactive Dynamics and Integrated Graphical Insights)",
    "section": "",
    "text": "vidigi (Visual Interactive Dynamics and Integrated Graphical Insights)\n\n\nWelcome to vidigi - a package for visualising real or simulated pathways.\nPrimarily developed for healthcare simulation and intended to allow easy integration with tools like Streamlit so users can see the impact of changes to simulation parameters in real-time, vidigi\nvidigi is the Esperanto  for ‘to show’\n(or it’s the backronym ‘Visual Interactive Dynamics and Integrated Graphical Insights’ - whichever floats your boat)",
    "crumbs": [
      "Welcome"
    ]
  },
  {
    "objectID": "vidigi_docs/populating_event_logs.html",
    "href": "vidigi_docs/populating_event_logs.html",
    "title": "Populating Event Logs",
    "section": "",
    "text": "Four event types are supported in the model:\n\n‘arrival_departure’\n‘resource_use’\n‘resource_use_end’\n‘queue’.\n\nAs a minimum, you will require the use of ‘arrival_departure’ events and one of\n\n‘resource_use’ / ‘resource_use_end’\nOR ‘queue’\n\nYou can also use both ‘resource_use’ and ‘queue’ within the same model very effectively (see ex_1_simplest_case and ex_2_branching_and_optional_paths, among others).\n\n\nWithin this, two ‘arrival_departure’ events per entity are mandatory - arrival and depart, both with an event_type of arrival_departure, as shown below.\n\n\n\n\n\n\n\n\nImportant\n\n\n\nArrivals must use\n‘event_type’: ‘arrival_departure’\n‘event’: ‘arrival’\n\n\n\nevent_log.append(\n      {'patient': unique_entity_identifier,\n      'pathway': 'Revision',\n      'event_type': 'arrival_departure',\n      'event': 'arrival',\n      'time': env.now}\n  )\n\n\n\n\n\n\n\n\n\n\nImportant\n\n\n\nDepartures must use\n‘event_type’: ‘arrival_departure’\n‘event’: ‘depart’\n\n\n\nevent_log.append(\n      {'patient': unique_entity_identifier,\n      'pathway': 'Revision',\n      'event_type': 'arrival_departure',\n      'event': 'depart',\n      'time': env.now}\n  )\n\n\n\n\n\n\n\nWarning\n\n\n\nThese are critical as they are used to determine when patients should first and last appear in the model.\n\n\n\n\n\n\n\n\nImportant\n\n\n\nForgetting to include a departure step for all types of patients can lead to slow model and animation performance as the size of the event logs for individual moments will continue to increase indefinitely.\n\n\n\n\n\n\nQueues are key steps in the model.\nIt is possible to solely use queues and never make use of a simpy resource.\nBy tracking each important step in the process as a ‘queue’ step, the movement of patients can be accurately tracked.\nPatients will be ordered by the point at which they are added to the queue, with the first entries appearing at the front (bottom-right) of the queue.\nRecord the time the entity begins queueing for a resource with an event_type of ‘queue’.\nYou may use whatever string you wish to for the event name.\n\nevent_log.append(\n            {'patient': unique_entity_identifier,\n             'pathway': 'High intensity',\n             'event_type': 'queue',\n             'event': 'appointment_booked_waiting',\n             'time': self.env.now\n             }\n        )\n\nWhile the keys shown above are mandatory, you can add as many additional keys to a step’s log as desired. This can allow you to flexibly make use of the event log for other purposes as well as the animation.\n\n\n\nResource use is more complex to include but comes with two key benefits over the queue: - it becomes easier to monitor the length of time a resource is in use by a single entity as users won’t ‘move through’ the resource use stage (which can also prove confusing to less experienced viewers) - it becomes possible to show the total number of resources that are available, making it easier to understand how well resources are being utilised at different stages\nIn addition to the other fields, this also requires you to pass a resource_id argument. If you have set up your simpy store using the populate_store function from the utils module of the vidigi package, then your resources will have an ID attribute you can access in the way shown below after you have requested the resource with .get()\nRecord the time the resource begins use with an event_type of ‘resource_use’.\nYou may use whatever string you wish to for the event name.\n\n# request the resource\nmy_resource = yield my_resource_store.get()\n\nevent_log.append( \n    {'patient': unique_entity_identifier, \n     'pathway': 'My Pathway Name', \n     'event_type': 'resource_use', \n     'event': 'triage_begins', \n     'time': env.now, \n     'resource_id': triage_resource.id_attribute \n    } \n) \n\nWhen the resource is no longer in use, record the time with an event_type of ‘resource_use_end’.\nAgain, you may use whatever string you wish to for the event name.\nOnce again, you must record the ID of the resource that is being freed up.\nYou can do this before or after putting the resource back in the store.\n\nevent_log.append( \n            {'patient': unique_entity_identifier, \n             'pathway': 'My Pathway Name', \n             'event_type': 'resource_use_end', \n             'event': 'triage_complete', \n             'time': env.now, \n             'resource_id': triage_resource.id_attribute} \n        ) \n\n# Resource is no longer in use, so put it back in the store\nmy_resource_store.put(my_resource)",
    "crumbs": [
      "Details",
      "Populating Event Logs"
    ]
  },
  {
    "objectID": "vidigi_docs/populating_event_logs.html#event-types",
    "href": "vidigi_docs/populating_event_logs.html#event-types",
    "title": "Populating Event Logs",
    "section": "",
    "text": "Four event types are supported in the model:\n\n‘arrival_departure’\n‘resource_use’\n‘resource_use_end’\n‘queue’.\n\nAs a minimum, you will require the use of ‘arrival_departure’ events and one of\n\n‘resource_use’ / ‘resource_use_end’\nOR ‘queue’\n\nYou can also use both ‘resource_use’ and ‘queue’ within the same model very effectively (see ex_1_simplest_case and ex_2_branching_and_optional_paths, among others).\n\n\nWithin this, two ‘arrival_departure’ events per entity are mandatory - arrival and depart, both with an event_type of arrival_departure, as shown below.\n\n\n\n\n\n\n\n\nImportant\n\n\n\nArrivals must use\n‘event_type’: ‘arrival_departure’\n‘event’: ‘arrival’\n\n\n\nevent_log.append(\n      {'patient': unique_entity_identifier,\n      'pathway': 'Revision',\n      'event_type': 'arrival_departure',\n      'event': 'arrival',\n      'time': env.now}\n  )\n\n\n\n\n\n\n\n\n\n\nImportant\n\n\n\nDepartures must use\n‘event_type’: ‘arrival_departure’\n‘event’: ‘depart’\n\n\n\nevent_log.append(\n      {'patient': unique_entity_identifier,\n      'pathway': 'Revision',\n      'event_type': 'arrival_departure',\n      'event': 'depart',\n      'time': env.now}\n  )\n\n\n\n\n\n\n\nWarning\n\n\n\nThese are critical as they are used to determine when patients should first and last appear in the model.\n\n\n\n\n\n\n\n\nImportant\n\n\n\nForgetting to include a departure step for all types of patients can lead to slow model and animation performance as the size of the event logs for individual moments will continue to increase indefinitely.\n\n\n\n\n\n\nQueues are key steps in the model.\nIt is possible to solely use queues and never make use of a simpy resource.\nBy tracking each important step in the process as a ‘queue’ step, the movement of patients can be accurately tracked.\nPatients will be ordered by the point at which they are added to the queue, with the first entries appearing at the front (bottom-right) of the queue.\nRecord the time the entity begins queueing for a resource with an event_type of ‘queue’.\nYou may use whatever string you wish to for the event name.\n\nevent_log.append(\n            {'patient': unique_entity_identifier,\n             'pathway': 'High intensity',\n             'event_type': 'queue',\n             'event': 'appointment_booked_waiting',\n             'time': self.env.now\n             }\n        )\n\nWhile the keys shown above are mandatory, you can add as many additional keys to a step’s log as desired. This can allow you to flexibly make use of the event log for other purposes as well as the animation.\n\n\n\nResource use is more complex to include but comes with two key benefits over the queue: - it becomes easier to monitor the length of time a resource is in use by a single entity as users won’t ‘move through’ the resource use stage (which can also prove confusing to less experienced viewers) - it becomes possible to show the total number of resources that are available, making it easier to understand how well resources are being utilised at different stages\nIn addition to the other fields, this also requires you to pass a resource_id argument. If you have set up your simpy store using the populate_store function from the utils module of the vidigi package, then your resources will have an ID attribute you can access in the way shown below after you have requested the resource with .get()\nRecord the time the resource begins use with an event_type of ‘resource_use’.\nYou may use whatever string you wish to for the event name.\n\n# request the resource\nmy_resource = yield my_resource_store.get()\n\nevent_log.append( \n    {'patient': unique_entity_identifier, \n     'pathway': 'My Pathway Name', \n     'event_type': 'resource_use', \n     'event': 'triage_begins', \n     'time': env.now, \n     'resource_id': triage_resource.id_attribute \n    } \n) \n\nWhen the resource is no longer in use, record the time with an event_type of ‘resource_use_end’.\nAgain, you may use whatever string you wish to for the event name.\nOnce again, you must record the ID of the resource that is being freed up.\nYou can do this before or after putting the resource back in the store.\n\nevent_log.append( \n            {'patient': unique_entity_identifier, \n             'pathway': 'My Pathway Name', \n             'event_type': 'resource_use_end', \n             'event': 'triage_complete', \n             'time': env.now, \n             'resource_id': triage_resource.id_attribute} \n        ) \n\n# Resource is no longer in use, so put it back in the store\nmy_resource_store.put(my_resource)",
    "crumbs": [
      "Details",
      "Populating Event Logs"
    ]
  },
  {
    "objectID": "docs/vidigi_docs/vidigi_vs_bupar.html",
    "href": "docs/vidigi_docs/vidigi_vs_bupar.html",
    "title": "vidigi",
    "section": "",
    "text": "from examples.example_2_branching_multistep.ex_2_model_classes import Trial, g\nimport pandas as pd\nimport os\n\n\ng.sim_duration = 3000\ng.number_of_runs = 1\n\n\n\n\n\n\n\nView Imported Code, which has had logging steps added at the appropriate points in the ‘model’ class\n\n\n\n\n\nimport random\nimport numpy as np\nimport pandas as pd\nimport simpy\nfrom sim_tools.distributions import Exponential, Lognormal, Uniform, Normal, Bernoulli\nfrom vidigi.utils import populate_store\nfrom examples.simulation_utility_functions import trace\n\n\n# Class to store global parameter values.  We don't create an instance of this\n# class - we just refer to the class blueprint itself to access the numbers\n# inside.\nclass g:\n    '''\n    Create a scenario to parameterise the simulation model\n\n    Parameters:\n    -----------\n    random_number_set: int, optional (default=DEFAULT_RNG_SET)\n        Set to control the initial seeds of each stream of pseudo\n        random numbers used in the model.\n\n    n_triage: int\n        The number of triage cubicles\n\n    n_reg: int\n        The number of registration clerks\n\n    n_exam: int\n        The number of examination rooms\n\n    n_trauma: int\n        The number of trauma bays for stablisation\n\n    n_cubicles_non_trauma_treat: int\n        The number of non-trauma treatment cubicles\n\n    n_cubicles_trauma_treat: int\n        The number of trauma treatment cubicles\n\n    triage_mean: float\n        Mean duration of the triage distribution (Exponential)\n\n    reg_mean: float\n        Mean duration of the registration distribution (Lognormal)\n\n    reg_var: float\n        Variance of the registration distribution (Lognormal)\n\n    exam_mean: float\n        Mean of the examination distribution (Normal)\n\n    exam_var: float\n        Variance of the examination distribution (Normal)\n\n    trauma_mean: float\n        Mean of the trauma stabilisation distribution (Exponential)\n\n    trauma_treat_mean: float\n        Mean of the trauma cubicle treatment distribution (Lognormal)\n\n    trauma_treat_var: float\n        Variance of the trauma cubicle treatment distribution (Lognormal)\n\n    non_trauma_treat_mean: float\n        Mean of the non trauma treatment distribution\n\n    non_trauma_treat_var: float\n        Variance of the non trauma treatment distribution\n\n    non_trauma_treat_p: float\n        Probability non trauma patient requires treatment\n\n    prob_trauma: float\n        probability that a new arrival is a trauma patient.\n    '''\n    random_number_set = 42\n\n    n_triage=2\n    n_reg=2\n    n_exam=3\n    n_trauma=4\n    n_cubicles_non_trauma_treat=4\n    n_cubicles_trauma_treat=5\n\n    triage_mean=6\n    reg_mean=8\n    reg_var=2\n    exam_mean=16\n    exam_var=3\n    trauma_mean=90\n    trauma_treat_mean=30\n    trauma_treat_var=4\n    non_trauma_treat_mean=13.3\n    non_trauma_treat_var=2\n\n    non_trauma_treat_p=0.6\n    prob_trauma=0.12\n\n    arrival_df=\"ed_arrivals.csv\"\n\n    sim_duration = 600\n    number_of_runs = 100\n\n# Class representing patients coming in to the clinic.\nclass Patient:\n    '''\n    Class defining details for a patient entity\n    '''\n    def __init__(self, p_id):\n        '''\n        Constructor method\n\n        Params:\n        -----\n        identifier: int\n            a numeric identifier for the patient.\n        '''\n        self.identifier = p_id\n\n        # Time of arrival in model/at centre\n        self.arrival = -np.inf\n        # Total time in pathway\n        self.total_time = -np.inf\n\n        # Shared waits\n        self.wait_triage = -np.inf\n        self.wait_reg = -np.inf\n        self.wait_treat = -np.inf\n        # Non-trauma pathway - examination wait\n        self.wait_exam = -np.inf\n        # Trauma pathway - stabilisation wait\n        self.wait_trauma = -np.inf\n\n        # Shared durations\n        self.triage_duration = -np.inf\n        self.reg_duration = -np.inf\n        self.treat_duration = -np.inf\n\n        # Non-trauma pathway - examination duration\n        self.exam_duration = -np.inf\n        # Trauma pathway - stabilisation duration\n        self.trauma_duration = -np.inf\n\n\n# Class representing our model of the clinic.\nclass Model:\n    '''\n    Simulates the simplest minor treatment process for a patient\n\n    1. Arrive\n    2. Examined/treated by nurse when one available\n    3. Discharged\n    '''\n    # Constructor to set up the model for a run.  We pass in a run number when\n    # we create a new model.\n    def __init__(self, run_number):\n        # Create a SimPy environment in which everything will live\n        self.env = simpy.Environment()\n\n        self.event_log = []\n\n        # Create a patient counter (which we'll use as a patient ID)\n        self.patient_counter = 0\n\n        self.trauma_patients = []\n        self.non_trauma_patients = []\n\n        # Create our resources\n        self.init_resources()\n\n        # Store the passed in run number\n        self.run_number = run_number\n\n        # Create a new Pandas DataFrame that will store some results against\n        # the patient ID (which we'll use as the index).\n        self.results_df = pd.DataFrame()\n        self.results_df[\"Patient ID\"] = [1]\n        self.results_df[\"Queue Time Cubicle\"] = [0.0]\n        self.results_df[\"Time with Nurse\"] = [0.0]\n        self.results_df.set_index(\"Patient ID\", inplace=True)\n\n        # Create an attribute to store the mean queuing times across this run of\n        # the model\n        self.mean_q_time_cubicle = 0\n\n        # create distributions\n\n        # Triage duration\n        self.triage_dist = Exponential(g.triage_mean,\n                                       random_seed=self.run_number*g.random_number_set)\n\n        # Registration duration (non-trauma only)\n        self.reg_dist = Lognormal(g.reg_mean,\n                                  np.sqrt(g.reg_var),\n                                  random_seed=self.run_number*g.random_number_set)\n\n        # Evaluation (non-trauma only)\n        self.exam_dist = Normal(g.exam_mean,\n                                np.sqrt(g.exam_var),\n                                random_seed=self.run_number*g.random_number_set)\n\n        # Trauma/stablisation duration (trauma only)\n        self.trauma_dist = Exponential(g.trauma_mean,\n                                       random_seed=self.run_number*g.random_number_set)\n\n        # Non-trauma treatment\n        self.nt_treat_dist = Lognormal(g.non_trauma_treat_mean,\n                                       np.sqrt(g.non_trauma_treat_var),\n                                       random_seed=self.run_number*g.random_number_set)\n\n        # treatment of trauma patients\n        self.treat_dist = Lognormal(g.trauma_treat_mean,\n                                    np.sqrt(g.non_trauma_treat_var),\n                                    random_seed=self.run_number*g.random_number_set)\n\n        # probability of non-trauma patient requiring treatment\n        self.nt_p_treat_dist = Bernoulli(g.non_trauma_treat_p,\n                                         random_seed=self.run_number*g.random_number_set)\n\n        # probability of non-trauma versus trauma patient\n        self.p_trauma_dist = Bernoulli(g.prob_trauma,\n                                       random_seed=self.run_number*g.random_number_set)\n\n        # init sampling for non-stationary poisson process\n        self.init_nspp()\n\n    def init_nspp(self):\n\n        # read arrival profile\n        self.arrivals = pd.read_csv(g.arrival_df)  # pylint: disable=attribute-defined-outside-init\n        self.arrivals['mean_iat'] = 60 / self.arrivals['arrival_rate']\n\n        # maximum arrival rate (smallest time between arrivals)\n        self.lambda_max = self.arrivals['arrival_rate'].max()  # pylint: disable=attribute-defined-outside-init\n\n        # thinning exponential\n        self.arrival_dist = Exponential(60.0 / self.lambda_max,  # pylint: disable=attribute-defined-outside-init\n                                            random_seed=self.run_number*g.random_number_set)\n\n        # thinning uniform rng\n        self.thinning_rng = Uniform(low=0.0, high=1.0,  # pylint: disable=attribute-defined-outside-init\n                                    random_seed=self.run_number*g.random_number_set)\n\n\n    def init_resources(self):\n        '''\n        Init the number of resources\n        and store in the arguments container object\n\n        Resource list:\n            1. Nurses/treatment bays (same thing in this model)\n\n        '''\n        # Shared Resources\n        self.triage_cubicles = simpy.Store(self.env)\n        populate_store(num_resources=g.n_triage,\n                simpy_store=self.triage_cubicles,\n                sim_env=self.env)\n\n        self.registration_cubicles = simpy.Store(self.env)\n        populate_store(num_resources=g.n_reg,\n                       simpy_store=self.registration_cubicles,\n                       sim_env=self.env)\n\n        # Non-trauma\n        self.exam_cubicles = simpy.Store(self.env)\n        populate_store(num_resources=g.n_exam,\n                       simpy_store=self.exam_cubicles,\n                       sim_env=self.env)\n\n        self.non_trauma_treatment_cubicles = simpy.Store(self.env)\n        populate_store(num_resources=g.n_cubicles_non_trauma_treat,\n                       simpy_store=self.non_trauma_treatment_cubicles,\n                       sim_env=self.env)\n\n        # Trauma\n        self.trauma_stabilisation_bays = simpy.Store(self.env)\n        populate_store(num_resources=g.n_trauma,\n                       simpy_store=self.trauma_stabilisation_bays,\n                       sim_env=self.env)\n\n        self.trauma_treatment_cubicles = simpy.Store(self.env)\n        populate_store(num_resources=g.n_cubicles_trauma_treat,\n                       simpy_store=self.trauma_treatment_cubicles,\n                       sim_env=self.env)\n\n    # A generator function that represents the DES generator for patient\n    # arrivals\n    def generator_patient_arrivals(self):\n        # We use an infinite loop here to keep doing this indefinitely whilst\n        # the simulation runs\n        while True:\n            t = int(self.env.now // 60) % self.arrivals.shape[0]\n            lambda_t = self.arrivals['arrival_rate'].iloc[t]\n\n            # set to a large number so that at least 1 sample taken!\n            u = np.Inf\n\n            interarrival_time = 0.0\n            # reject samples if u &gt;= lambda_t / lambda_max\n            while u &gt;= (lambda_t / self.lambda_max):\n                interarrival_time += self.arrival_dist.sample()\n                u = self.thinning_rng.sample()\n\n            # Freeze this instance of this function in place until the\n            # inter-arrival time we sampled above has elapsed.  Note - time in\n            # SimPy progresses in \"Time Units\", which can represent anything\n            # you like (just make sure you're consistent within the model)\n            yield self.env.timeout(interarrival_time)\n\n            # Increment the patient counter by 1 (this means our first patient\n            # will have an ID of 1)\n            self.patient_counter += 1\n\n            # Create a new patient - an instance of the Patient Class we\n            # defined above.  Remember, we pass in the ID when creating a\n            # patient - so here we pass the patient counter to use as the ID.\n            p = Patient(self.patient_counter)\n\n            trace(f'patient {self.patient_counter} arrives at: {self.env.now:.3f}')\n            self.event_log.append(\n                {'patient': self.patient_counter,\n                 'pathway': 'Shared',\n                 'event': 'arrival',\n                 'event_type': 'arrival_departure',\n                 'time': self.env.now}\n            )\n\n            # sample if the patient is trauma or non-trauma\n            trauma = self.p_trauma_dist.sample()\n\n            # Tell SimPy to start up the attend_clinic generator function with\n            # this patient (the generator function that will model the\n            # patient's journey through the system)\n            # and store patient in list for later easy access\n            if trauma:\n                # create and store a trauma patient to update KPIs.\n                self.trauma_patients.append(p)\n                self.env.process(self.attend_trauma_pathway(p))\n\n            else:\n                # create and store a non-trauma patient to update KPIs.\n                self.non_trauma_patients.append(p)\n                self.env.process(self.attend_non_trauma_pathway(p))\n\n    # A generator function that represents the pathway for a patient going\n    # through the clinic.\n    # The patient object is passed in to the generator function so we can\n    # extract information from / record information to it\n    def attend_non_trauma_pathway(self, patient):\n        '''\n        simulates the non-trauma/minor treatment process for a patient\n\n        1. request and wait for sign-in/triage\n        2. patient registration\n        3. examination\n        4a. percentage discharged\n        4b. remaining percentage treatment then discharge\n        '''\n        # record the time of arrival and entered the triage queue\n        patient.arrival = self.env.now\n        self.event_log.append(\n            {'patient': patient.identifier,\n             'pathway': 'Non-Trauma',\n             'event_type': 'queue',\n             'event': 'triage_wait_begins',\n             'time': self.env.now}\n        )\n\n        ###################################################\n        # request sign-in/triage\n        triage_resource = yield self.triage_cubicles.get()\n\n        # record the waiting time for triage\n        patient.wait_triage = self.env.now - patient.arrival\n        trace(f'patient {patient.identifier} triaged to minors '\n                f'{self.env.now:.3f}')\n        self.event_log.append(\n            {'patient': patient.identifier,\n                'pathway': 'Non-Trauma',\n                'event_type': 'resource_use',\n                'event': 'triage_begins',\n                'time': self.env.now,\n                'resource_id': triage_resource.id_attribute\n                }\n        )\n\n        # sample triage duration.\n        patient.triage_duration = self.triage_dist.sample()\n        yield self.env.timeout(patient.triage_duration)\n\n        trace(f'triage {patient.identifier} complete {self.env.now:.3f}; '\n                f'waiting time was {patient.wait_triage:.3f}')\n        self.event_log.append(\n            {'patient': patient.identifier,\n                'pathway': 'Non-Trauma',\n                'event_type': 'resource_use_end',\n                'event': 'triage_complete',\n                'time': self.env.now,\n                'resource_id': triage_resource.id_attribute}\n        )\n\n        # Resource is no longer in use, so put it back in the store\n        self.triage_cubicles.put(triage_resource)\n        #########################################################\n\n        # record the time that entered the registration queue\n        start_wait = self.env.now\n        self.event_log.append(\n            {'patient': patient.identifier,\n             'pathway': 'Non-Trauma',\n             'event_type': 'queue',\n             'event': 'MINORS_registration_wait_begins',\n             'time': self.env.now}\n        )\n\n        #########################################################\n        # request registration clerk\n        registration_resource = yield self.registration_cubicles.get()\n\n        # record the waiting time for registration\n        patient.wait_reg = self.env.now - start_wait\n        trace(f'registration of patient {patient.identifier} at '\n                f'{self.env.now:.3f}')\n        self.event_log.append(\n            {'patient': patient.identifier,\n                'pathway': 'Non-Trauma',\n                'event_type': 'resource_use',\n                'event': 'MINORS_registration_begins',\n                'time': self.env.now,\n                'resource_id': registration_resource.id_attribute\n                }\n        )\n\n        # sample registration duration.\n        patient.reg_duration = self.reg_dist.sample()\n        yield self.env.timeout(patient.reg_duration)\n\n        trace(f'patient {patient.identifier} registered at'\n                f'{self.env.now:.3f}; '\n                f'waiting time was {patient.wait_reg:.3f}')\n        self.event_log.append(\n            {'patient': patient.identifier,\n                'pathway': 'Non-Trauma',\n                'event': 'MINORS_registration_complete',\n                'event_type': 'resource_use_end',\n                'time': self.env.now,\n                'resource_id': registration_resource.id_attribute}\n        )\n        # Resource is no longer in use, so put it back in the store\n        self.registration_cubicles.put(registration_resource)\n        ########################################################\n\n        # record the time that entered the evaluation queue\n        start_wait = self.env.now\n\n        self.event_log.append(\n            {'patient': patient.identifier,\n             'pathway': 'Non-Trauma',\n             'event': 'MINORS_examination_wait_begins',\n             'event_type': 'queue',\n             'time': self.env.now}\n        )\n\n        #########################################################\n        # request examination resource\n        examination_resource = yield self.exam_cubicles.get()\n\n        # record the waiting time for examination to begin\n        patient.wait_exam = self.env.now - start_wait\n        trace(f'examination of patient {patient.identifier} begins '\n                f'{self.env.now:.3f}')\n        self.event_log.append(\n            {'patient': patient.identifier,\n                'pathway': 'Non-Trauma',\n                'event': 'MINORS_examination_begins',\n                'event_type': 'resource_use',\n                'time': self.env.now,\n                'resource_id': examination_resource.id_attribute\n                }\n        )\n\n        # sample examination duration.\n        patient.exam_duration = self.exam_dist.sample()\n        yield self.env.timeout(patient.exam_duration)\n\n        trace(f'patient {patient.identifier} examination complete '\n                f'at {self.env.now:.3f};'\n                f'waiting time was {patient.wait_exam:.3f}')\n        self.event_log.append(\n            {'patient': patient.identifier,\n                'pathway': 'Non-Trauma',\n                'event': 'MINORS_examination_complete',\n                'event_type': 'resource_use_end',\n                'time': self.env.now,\n                'resource_id': examination_resource.id_attribute}\n        )\n        # Resource is no longer in use, so put it back in\n        self.exam_cubicles.put(examination_resource)\n        ############################################################################\n\n        # sample if patient requires treatment?\n        patient.require_treat = self.nt_p_treat_dist.sample()  #pylint: disable=attribute-defined-outside-init\n\n        if patient.require_treat:\n\n            self.event_log.append(\n                {'patient': patient.identifier,\n                 'pathway': 'Non-Trauma',\n                 'event': 'requires_treatment',\n                 'event_type': 'attribute_assigned',\n                 'time': self.env.now}\n            )\n\n            # record the time that entered the treatment queue\n            start_wait = self.env.now\n            self.event_log.append(\n                {'patient': patient.identifier,\n                 'pathway': 'Non-Trauma',\n                 'event': 'MINORS_treatment_wait_begins',\n                 'event_type': 'queue',\n                 'time': self.env.now}\n            )\n            ###################################################\n            # request treatment cubicle\n\n            non_trauma_treatment_resource = yield self.non_trauma_treatment_cubicles.get()\n\n            # record the waiting time for treatment\n            patient.wait_treat = self.env.now - start_wait\n            trace(f'treatment of patient {patient.identifier} begins '\n                    f'{self.env.now:.3f}')\n            self.event_log.append(\n                {'patient': patient.identifier,\n                    'pathway': 'Non-Trauma',\n                    'event': 'MINORS_treatment_begins',\n                    'event_type': 'resource_use',\n                    'time': self.env.now,\n                    'resource_id': non_trauma_treatment_resource.id_attribute\n                }\n            )\n\n            # sample treatment duration.\n            patient.treat_duration = self.nt_treat_dist.sample()\n            yield self.env.timeout(patient.treat_duration)\n\n            trace(f'patient {patient.identifier} treatment complete '\n                    f'at {self.env.now:.3f};'\n                    f'waiting time was {patient.wait_treat:.3f}')\n            self.event_log.append(\n                {'patient': patient.identifier,\n                    'pathway': 'Non-Trauma',\n                    'event': 'MINORS_treatment_complete',\n                    'event_type': 'resource_use_end',\n                    'time': self.env.now,\n                    'resource_id': non_trauma_treatment_resource.id_attribute}\n            )\n\n            # Resource is no longer in use, so put it back in the store\n            self.non_trauma_treatment_cubicles.put(non_trauma_treatment_resource)\n        ##########################################################################\n\n        # Return to what happens to all patients, regardless of whether they were sampled as needing treatment\n        self.event_log.append(\n            {'patient': patient.identifier,\n            'pathway': 'Shared',\n            'event': 'depart',\n            'event_type': 'arrival_departure',\n            'time': self.env.now}\n        )\n\n        # total time in system\n        patient.total_time = self.env.now - patient.arrival\n\n    def attend_trauma_pathway(self, patient):\n        '''\n        simulates the major treatment process for a patient\n\n        1. request and wait for sign-in/triage\n        2. trauma\n        3. treatment\n        '''\n        # record the time of arrival and entered the triage queue\n        patient.arrival = self.env.now\n        self.event_log.append(\n            {'patient': patient.identifier,\n             'pathway': 'Trauma',\n             'event_type': 'queue',\n             'event': 'triage_wait_begins',\n             'time': self.env.now}\n        )\n\n        ###################################################\n        # request sign-in/triage\n        triage_resource = yield self.triage_cubicles.get()\n\n        # record the waiting time for triage\n        patient.wait_triage = self.env.now - patient.arrival\n\n        trace(f'patient {patient.identifier} triaged to trauma '\n                f'{self.env.now:.3f}')\n        self.event_log.append(\n            {'patient': patient.identifier,\n             'pathway': 'Trauma',\n             'event_type': 'resource_use',\n             'event': 'triage_begins',\n             'time': self.env.now,\n             'resource_id': triage_resource.id_attribute\n            }\n        )\n\n        # sample triage duration.\n        patient.triage_duration = self.triage_dist.sample()\n        yield self.env.timeout(patient.triage_duration)\n\n        trace(f'triage {patient.identifier} complete {self.env.now:.3f}; '\n              f'waiting time was {patient.wait_triage:.3f}')\n        self.event_log.append(\n            {'patient': patient.identifier,\n             'pathway': 'Trauma',\n             'event_type': 'resource_use_end',\n             'event': 'triage_complete',\n             'time': self.env.now,\n             'resource_id': triage_resource.id_attribute}\n        )\n\n        # Resource is no longer in use, so put it back in the store\n        self.triage_cubicles.put(triage_resource)\n        ###################################################\n\n        # record the time that entered the trauma queue\n        start_wait = self.env.now\n        self.event_log.append(\n            {'patient': patient.identifier,\n             'pathway': 'Trauma',\n             'event_type': 'queue',\n             'event': 'TRAUMA_stabilisation_wait_begins',\n             'time': self.env.now}\n        )\n\n        ###################################################\n        # request trauma room\n        trauma_resource = yield self.trauma_stabilisation_bays.get()\n\n        self.event_log.append(\n            {'patient': patient.identifier,\n                'pathway': 'Trauma',\n                'event_type': 'resource_use',\n                'event': 'TRAUMA_stabilisation_begins',\n                'time': self.env.now,\n                'resource_id': trauma_resource.id_attribute\n                }\n        )\n\n        # record the waiting time for trauma\n        patient.wait_trauma = self.env.now - start_wait\n\n        # sample stablisation duration.\n        patient.trauma_duration = self.trauma_dist.sample()\n        yield self.env.timeout(patient.trauma_duration)\n\n        trace(f'stabilisation of patient {patient.identifier} at '\n              f'{self.env.now:.3f}')\n        self.event_log.append(\n            {'patient': patient.identifier,\n             'pathway': 'Trauma',\n             'event_type': 'resource_use_end',\n             'event': 'TRAUMA_stabilisation_complete',\n             'time': self.env.now,\n             'resource_id': trauma_resource.id_attribute\n            }\n        )\n        # Resource is no longer in use, so put it back in the store\n        self.trauma_stabilisation_bays.put(trauma_resource)\n\n        #######################################################\n\n        # record the time that patient entered the treatment queue\n        start_wait = self.env.now\n        self.event_log.append(\n            {'patient': patient.identifier,\n             'pathway': 'Trauma',\n             'event_type': 'queue',\n             'event': 'TRAUMA_treatment_wait_begins',\n             'time': self.env.now}\n        )\n\n        ########################################################\n        # request treatment cubicle\n        trauma_treatment_resource = yield self.trauma_treatment_cubicles.get()\n\n        # record the waiting time for trauma\n        patient.wait_treat = self.env.now - start_wait\n        trace(f'treatment of patient {patient.identifier} at '\n                f'{self.env.now:.3f}')\n        self.event_log.append(\n            {'patient': patient.identifier,\n                'pathway': 'Trauma',\n                'event_type': 'resource_use',\n                'event': 'TRAUMA_treatment_begins',\n                'time': self.env.now,\n                'resource_id': trauma_treatment_resource.id_attribute\n                }\n        )\n\n        # sample treatment duration.\n        patient.treat_duration = self.trauma_dist.sample()\n        yield self.env.timeout(patient.treat_duration)\n\n        trace(f'patient {patient.identifier} treatment complete {self.env.now:.3f}; '\n              f'waiting time was {patient.wait_treat:.3f}')\n        self.event_log.append(\n            {'patient': patient.identifier,\n             'pathway': 'Trauma',\n             'event_type': 'resource_use_end',\n             'event': 'TRAUMA_treatment_complete',\n             'time': self.env.now,\n             'resource_id': trauma_treatment_resource.id_attribute}\n        )\n        self.event_log.append(\n            {'patient': patient.identifier,\n            'pathway': 'Shared',\n            'event': 'depart',\n            'event_type': 'arrival_departure',\n            'time': self.env.now}\n        )\n\n        # Resource is no longer in use, so put it back in the store\n        self.trauma_treatment_cubicles.put(trauma_treatment_resource)\n\n        #########################################################\n\n        # total time in system\n        patient.total_time = self.env.now - patient.arrival\n\n\n    # This method calculates results over a single run.  Here we just calculate\n    # a mean, but in real world models you'd probably want to calculate more.\n    def calculate_run_results(self):\n        # Take the mean of the queuing times across patients in this run of the\n        # model.\n        self.mean_q_time_cubicle = self.results_df[\"Queue Time Cubicle\"].mean()\n\n    # The run method starts up the DES entity generators, runs the simulation,\n    # and in turns calls anything we need to generate results for the run\n    def run(self):\n        # Start up our DES entity generators that create new patients.  We've\n        # only got one in this model, but we'd need to do this for each one if\n        # we had multiple generators.\n        self.env.process(self.generator_patient_arrivals())\n\n        # Run the model for the duration specified in g class\n        self.env.run(until=g.sim_duration)\n\n        # Now the simulation run has finished, call the method that calculates\n        # run results\n        self.calculate_run_results()\n\n        self.event_log = pd.DataFrame(self.event_log)\n\n        self.event_log[\"run\"] = self.run_number\n\n        return {'results': self.results_df, 'event_log': self.event_log}\n\n# Class representing a Trial for our simulation - a batch of simulation runs.\nclass Trial:\n    # The constructor sets up a pandas dataframe that will store the key\n    # results from each run against run number, with run number as the index.\n    def  __init__(self):\n        self.df_trial_results = pd.DataFrame()\n        self.df_trial_results[\"Run Number\"] = [0]\n        self.df_trial_results[\"Arrivals\"] = [0]\n        self.df_trial_results[\"Mean Queue Time Cubicle\"] = [0.0]\n        self.df_trial_results.set_index(\"Run Number\", inplace=True)\n\n        self.all_event_logs = []\n\n    # Method to run a trial\n    def run_trial(self):\n        # Run the simulation for the number of runs specified in g class.\n        # For each run, we create a new instance of the Model class and call its\n        # run method, which sets everything else in motion.  Once the run has\n        # completed, we grab out the stored run results (just mean queuing time\n        # here) and store it against the run number in the trial results\n        # dataframe.\n        for run in range(g.number_of_runs):\n            random.seed(run)\n\n            my_model = Model(run)\n            model_outputs = my_model.run()\n            patient_level_results = model_outputs[\"results\"]\n            event_log = model_outputs[\"event_log\"]\n\n            self.df_trial_results.loc[run] = [\n                len(patient_level_results),\n                my_model.mean_q_time_cubicle,\n            ]\n\n            # print(event_log)\n\n            self.all_event_logs.append(event_log)\n\n        self.all_event_logs = pd.concat(self.all_event_logs)\n\n\n\n\nmy_trial = Trial()\n\nmy_trial.run_trial()\n\n\nmy_trial.all_event_logs.head(10)\n\n\n\n\n\n\n\n\npatient\npathway\nevent\nevent_type\ntime\nresource_id\nrun\n\n\n\n\n0\n1\nShared\narrival\narrival_departure\n3.285355\nNaN\n0\n\n\n1\n1\nNon-Trauma\ntriage_wait_begins\nqueue\n3.285355\nNaN\n0\n\n\n2\n1\nNon-Trauma\ntriage_begins\nresource_use\n3.285355\n1.0\n0\n\n\n3\n2\nShared\narrival\narrival_departure\n3.289691\nNaN\n0\n\n\n4\n2\nNon-Trauma\ntriage_wait_begins\nqueue\n3.289691\nNaN\n0\n\n\n5\n2\nNon-Trauma\ntriage_begins\nresource_use\n3.289691\n2.0\n0\n\n\n6\n1\nNon-Trauma\ntriage_complete\nresource_use_end\n7.364946\n1.0\n0\n\n\n7\n1\nNon-Trauma\nMINORS_registration_wait_begins\nqueue\n7.364946\nNaN\n0\n\n\n8\n1\nNon-Trauma\nMINORS_registration_begins\nresource_use\n7.364946\n1.0\n0\n\n\n9\n2\nNon-Trauma\ntriage_complete\nresource_use_end\n9.407274\n2.0\n0\n\n\n\n\n\n\n\n\nmy_trial.all_event_logs.event_type.value_counts()\n\nevent_type\nqueue                 2100\nresource_use          2035\nresource_use_end      2021\narrival_departure     1167\nattribute_assigned     264\nName: count, dtype: int64\n\n\n\nmy_trial.all_event_logs.event.value_counts()\n\nevent\narrival                             623\ntriage_wait_begins                  623\ntriage_begins                       622\ntriage_complete                     620\ndepart                              544\nMINORS_registration_wait_begins     539\nMINORS_registration_begins          514\nMINORS_registration_complete        512\nMINORS_examination_wait_begins      512\nMINORS_examination_begins           475\nMINORS_examination_complete         472\nrequires_treatment                  264\nMINORS_treatment_wait_begins        264\nMINORS_treatment_begins             264\nMINORS_treatment_complete           262\nTRAUMA_stabilisation_wait_begins     81\nTRAUMA_stabilisation_begins          81\nTRAUMA_stabilisation_complete        81\nTRAUMA_treatment_wait_begins         81\nTRAUMA_treatment_begins              79\nTRAUMA_treatment_complete            74\nName: count, dtype: int64\n\n\n\n# First, identify all patients who have a 'depart' event\n# patients_with_depart = my_trial.all_event_logs[my_trial.all_event_logs['event'].str.contains('depart')]['patient'].unique()\n\n# Then filter the original DataFrame to only include those patients\n# filtered_df = my_trial.all_event_logs[my_trial.all_event_logs['patient'].isin(patients_with_depart)]\n\nlogs_transformed = my_trial.all_event_logs[~my_trial.all_event_logs['event'].str.contains('wait')].copy()\n# logs_transformed = filtered_df[~filtered_df['event'].str.contains('wait')].copy()\nlogs_transformed = logs_transformed[logs_transformed['event_type'].isin(['resource_use', 'resource_use_end'])].copy()\nlogs_transformed['event_stage'] = logs_transformed['event_type'].apply(lambda x: 'complete' if 'end' in x else 'start')\nlogs_transformed['event_name'] = logs_transformed['event'].str.replace('_begins|_complete', '', regex=True)\nlogs_transformed['resource_id_full'] = logs_transformed.apply(lambda x: f\"{x['event_name']}_{x['resource_id']:.0f}\", axis=1)\nlogs_transformed = logs_transformed.sort_values(['run', 'time'], ascending=True)\n# logs_transformed[\"activity_id\"] = (\n#     logs_transformed.groupby([\"run\", \"patient\", \"event_name\"]).ngroup() + 1\n# )\n\n# logs_transformed = logs_transformed.sort_values([\"run\", \"patient\", \"activity_id\", \"event_stage\"], ascending=[True, True, True, False])\n\n# Sort the data by run, patient, time, and event_name to handle tied start times\nlogs_transformed = logs_transformed.sort_values([\"run\", \"patient\", \"time\", \"event_name\"])\n\n# Get the first occurrence of each activity (the start event)\nfirst_occurrences = (\n    logs_transformed[logs_transformed[\"event_stage\"] == \"start\"]\n    .drop_duplicates([\"run\", \"patient\", \"event_name\"])\n    .copy()\n)\n\n# Sort by time within each run to determine the proper sequence\nfirst_occurrences = first_occurrences.sort_values([\"run\", \"time\", \"event_name\"])\n\n# Assign sequential activity_id within each run\nfirst_occurrences[\"activity_id\"] = first_occurrences.groupby(\"run\").cumcount() + 1\n\n# Merge the activity_id back to the main DataFrame\nlogs_transformed = logs_transformed.merge(\n    first_occurrences[[\"run\", \"patient\", \"event_name\", \"activity_id\"]],\n    on=[\"run\", \"patient\", \"event_name\"],\n    how=\"left\"\n)\n\n# Sort for final ordering\nlogs_transformed = logs_transformed.sort_values(\n    [\"run\", \"patient\", \"activity_id\", \"event_stage\"],\n    ascending=[True, True, True, False]\n)\nlogs_transformed.head(50)\n\n\n\n\n\n\n\n\npatient\npathway\nevent\nevent_type\ntime\nresource_id\nrun\nevent_stage\nevent_name\nresource_id_full\nactivity_id\n\n\n\n\n0\n1\nNon-Trauma\ntriage_begins\nresource_use\n3.285355\n1.0\n0\nstart\ntriage\ntriage_1\n1\n\n\n2\n1\nNon-Trauma\ntriage_complete\nresource_use_end\n7.364946\n1.0\n0\ncomplete\ntriage\ntriage_1\n1\n\n\n1\n1\nNon-Trauma\nMINORS_registration_begins\nresource_use\n7.364946\n1.0\n0\nstart\nMINORS_registration\nMINORS_registration_1\n3\n\n\n4\n1\nNon-Trauma\nMINORS_registration_complete\nresource_use_end\n15.418481\n1.0\n0\ncomplete\nMINORS_registration\nMINORS_registration_1\n3\n\n\n3\n1\nNon-Trauma\nMINORS_examination_begins\nresource_use\n15.418481\n1.0\n0\nstart\nMINORS_examination\nMINORS_examination_1\n5\n\n\n5\n1\nNon-Trauma\nMINORS_examination_complete\nresource_use_end\n31.636252\n1.0\n0\ncomplete\nMINORS_examination\nMINORS_examination_1\n5\n\n\n6\n2\nNon-Trauma\ntriage_begins\nresource_use\n3.289691\n2.0\n0\nstart\ntriage\ntriage_2\n2\n\n\n8\n2\nNon-Trauma\ntriage_complete\nresource_use_end\n9.407274\n2.0\n0\ncomplete\ntriage\ntriage_2\n2\n\n\n7\n2\nNon-Trauma\nMINORS_registration_begins\nresource_use\n9.407274\n2.0\n0\nstart\nMINORS_registration\nMINORS_registration_2\n4\n\n\n10\n2\nNon-Trauma\nMINORS_registration_complete\nresource_use_end\n17.104670\n2.0\n0\ncomplete\nMINORS_registration\nMINORS_registration_2\n4\n\n\n9\n2\nNon-Trauma\nMINORS_examination_begins\nresource_use\n17.104670\n2.0\n0\nstart\nMINORS_examination\nMINORS_examination_2\n6\n\n\n11\n2\nNon-Trauma\nMINORS_examination_complete\nresource_use_end\n32.875857\n2.0\n0\ncomplete\nMINORS_examination\nMINORS_examination_2\n6\n\n\n12\n2\nNon-Trauma\nMINORS_treatment_begins\nresource_use\n32.875857\n1.0\n0\nstart\nMINORS_treatment\nMINORS_treatment_1\n7\n\n\n13\n2\nNon-Trauma\nMINORS_treatment_complete\nresource_use_end\n46.278797\n1.0\n0\ncomplete\nMINORS_treatment\nMINORS_treatment_1\n7\n\n\n14\n3\nNon-Trauma\ntriage_begins\nresource_use\n33.426168\n1.0\n0\nstart\ntriage\ntriage_1\n8\n\n\n16\n3\nNon-Trauma\ntriage_complete\nresource_use_end\n33.545008\n1.0\n0\ncomplete\ntriage\ntriage_1\n8\n\n\n15\n3\nNon-Trauma\nMINORS_registration_begins\nresource_use\n33.545008\n1.0\n0\nstart\nMINORS_registration\nMINORS_registration_1\n9\n\n\n18\n3\nNon-Trauma\nMINORS_registration_complete\nresource_use_end\n42.359504\n1.0\n0\ncomplete\nMINORS_registration\nMINORS_registration_1\n9\n\n\n17\n3\nNon-Trauma\nMINORS_examination_begins\nresource_use\n42.359504\n3.0\n0\nstart\nMINORS_examination\nMINORS_examination_3\n12\n\n\n19\n3\nNon-Trauma\nMINORS_examination_complete\nresource_use_end\n59.468749\n3.0\n0\ncomplete\nMINORS_examination\nMINORS_examination_3\n12\n\n\n20\n3\nNon-Trauma\nMINORS_treatment_begins\nresource_use\n59.468749\n2.0\n0\nstart\nMINORS_treatment\nMINORS_treatment_2\n16\n\n\n21\n3\nNon-Trauma\nMINORS_treatment_complete\nresource_use_end\n72.510229\n2.0\n0\ncomplete\nMINORS_treatment\nMINORS_treatment_2\n16\n\n\n22\n4\nNon-Trauma\ntriage_begins\nresource_use\n37.900548\n2.0\n0\nstart\ntriage\ntriage_2\n10\n\n\n24\n4\nNon-Trauma\ntriage_complete\nresource_use_end\n37.914164\n2.0\n0\ncomplete\ntriage\ntriage_2\n10\n\n\n23\n4\nNon-Trauma\nMINORS_registration_begins\nresource_use\n37.914164\n2.0\n0\nstart\nMINORS_registration\nMINORS_registration_2\n11\n\n\n26\n4\nNon-Trauma\nMINORS_registration_complete\nresource_use_end\n45.938325\n2.0\n0\ncomplete\nMINORS_registration\nMINORS_registration_2\n11\n\n\n25\n4\nNon-Trauma\nMINORS_examination_begins\nresource_use\n45.938325\n1.0\n0\nstart\nMINORS_examination\nMINORS_examination_1\n13\n\n\n27\n4\nNon-Trauma\nMINORS_examination_complete\nresource_use_end\n62.120017\n1.0\n0\ncomplete\nMINORS_examination\nMINORS_examination_1\n13\n\n\n28\n4\nNon-Trauma\nMINORS_treatment_begins\nresource_use\n62.120017\n3.0\n0\nstart\nMINORS_treatment\nMINORS_treatment_3\n17\n\n\n29\n4\nNon-Trauma\nMINORS_treatment_complete\nresource_use_end\n76.274743\n3.0\n0\ncomplete\nMINORS_treatment\nMINORS_treatment_3\n17\n\n\n30\n5\nNon-Trauma\ntriage_begins\nresource_use\n51.770459\n1.0\n0\nstart\ntriage\ntriage_1\n14\n\n\n32\n5\nNon-Trauma\ntriage_complete\nresource_use_end\n55.072516\n1.0\n0\ncomplete\ntriage\ntriage_1\n14\n\n\n31\n5\nNon-Trauma\nMINORS_registration_begins\nresource_use\n55.072516\n1.0\n0\nstart\nMINORS_registration\nMINORS_registration_1\n15\n\n\n34\n5\nNon-Trauma\nMINORS_registration_complete\nresource_use_end\n62.243834\n1.0\n0\ncomplete\nMINORS_registration\nMINORS_registration_1\n15\n\n\n33\n5\nNon-Trauma\nMINORS_examination_begins\nresource_use\n62.243834\n2.0\n0\nstart\nMINORS_examination\nMINORS_examination_2\n18\n\n\n35\n5\nNon-Trauma\nMINORS_examination_complete\nresource_use_end\n77.316027\n2.0\n0\ncomplete\nMINORS_examination\nMINORS_examination_2\n18\n\n\n36\n6\nTrauma\ntriage_begins\nresource_use\n113.767200\n2.0\n0\nstart\ntriage\ntriage_2\n19\n\n\n38\n6\nTrauma\ntriage_complete\nresource_use_end\n123.546842\n2.0\n0\ncomplete\ntriage\ntriage_2\n19\n\n\n37\n6\nTrauma\nTRAUMA_stabilisation_begins\nresource_use\n123.546842\n1.0\n0\nstart\nTRAUMA_stabilisation\nTRAUMA_stabilisation_1\n21\n\n\n39\n6\nTrauma\nTRAUMA_stabilisation_complete\nresource_use_end\n184.740714\n1.0\n0\ncomplete\nTRAUMA_stabilisation\nTRAUMA_stabilisation_1\n21\n\n\n40\n6\nTrauma\nTRAUMA_treatment_begins\nresource_use\n184.740714\n1.0\n0\nstart\nTRAUMA_treatment\nTRAUMA_treatment_1\n37\n\n\n41\n6\nTrauma\nTRAUMA_treatment_complete\nresource_use_end\n186.523313\n1.0\n0\ncomplete\nTRAUMA_treatment\nTRAUMA_treatment_1\n37\n\n\n42\n7\nNon-Trauma\ntriage_begins\nresource_use\n123.044756\n1.0\n0\nstart\ntriage\ntriage_1\n20\n\n\n44\n7\nNon-Trauma\ntriage_complete\nresource_use_end\n127.086253\n1.0\n0\ncomplete\ntriage\ntriage_1\n20\n\n\n43\n7\nNon-Trauma\nMINORS_registration_begins\nresource_use\n127.086253\n2.0\n0\nstart\nMINORS_registration\nMINORS_registration_2\n23\n\n\n46\n7\nNon-Trauma\nMINORS_registration_complete\nresource_use_end\n135.479993\n2.0\n0\ncomplete\nMINORS_registration\nMINORS_registration_2\n23\n\n\n45\n7\nNon-Trauma\nMINORS_examination_begins\nresource_use\n135.479993\n3.0\n0\nstart\nMINORS_examination\nMINORS_examination_3\n27\n\n\n47\n7\nNon-Trauma\nMINORS_examination_complete\nresource_use_end\n152.106294\n3.0\n0\ncomplete\nMINORS_examination\nMINORS_examination_3\n27\n\n\n48\n8\nNon-Trauma\ntriage_begins\nresource_use\n124.735469\n2.0\n0\nstart\ntriage\ntriage_2\n22\n\n\n50\n8\nNon-Trauma\ntriage_complete\nresource_use_end\n129.267277\n2.0\n0\ncomplete\ntriage\ntriage_2\n22\n\n\n\n\n\n\n\n\nlogs_transformed[(logs_transformed[\"run\"]==1) & (logs_transformed[\"activity_id\"]==26)]\n\n\n\n\n\n\n\n\npatient\npathway\nevent\nevent_type\ntime\nresource_id\nrun\nevent_stage\nevent_name\nresource_id_full\nactivity_id\n\n\n\n\n\n\n\n\n\n\nlogs_transformed[logs_transformed[\"activity_id\"]==26].sort_values('run').head(30)\n\n\n\n\n\n\n\n\npatient\npathway\nevent\nevent_type\ntime\nresource_id\nrun\nevent_stage\nevent_name\nresource_id_full\nactivity_id\n\n\n\n\n60\n10\nTrauma\ntriage_begins\nresource_use\n129.468902\n2.0\n0\nstart\ntriage\ntriage_2\n26\n\n\n62\n10\nTrauma\ntriage_complete\nresource_use_end\n165.815421\n2.0\n0\ncomplete\ntriage\ntriage_2\n26\n\n\n\n\n\n\n\n\nlogs_transformed.sort_values('activity_id').head(20)\n\n\n\n\n\n\n\n\npatient\npathway\nevent\nevent_type\ntime\nresource_id\nrun\nevent_stage\nevent_name\nresource_id_full\nactivity_id\n\n\n\n\n0\n1\nNon-Trauma\ntriage_begins\nresource_use\n3.285355\n1.0\n0\nstart\ntriage\ntriage_1\n1\n\n\n2\n1\nNon-Trauma\ntriage_complete\nresource_use_end\n7.364946\n1.0\n0\ncomplete\ntriage\ntriage_1\n1\n\n\n6\n2\nNon-Trauma\ntriage_begins\nresource_use\n3.289691\n2.0\n0\nstart\ntriage\ntriage_2\n2\n\n\n8\n2\nNon-Trauma\ntriage_complete\nresource_use_end\n9.407274\n2.0\n0\ncomplete\ntriage\ntriage_2\n2\n\n\n1\n1\nNon-Trauma\nMINORS_registration_begins\nresource_use\n7.364946\n1.0\n0\nstart\nMINORS_registration\nMINORS_registration_1\n3\n\n\n4\n1\nNon-Trauma\nMINORS_registration_complete\nresource_use_end\n15.418481\n1.0\n0\ncomplete\nMINORS_registration\nMINORS_registration_1\n3\n\n\n7\n2\nNon-Trauma\nMINORS_registration_begins\nresource_use\n9.407274\n2.0\n0\nstart\nMINORS_registration\nMINORS_registration_2\n4\n\n\n10\n2\nNon-Trauma\nMINORS_registration_complete\nresource_use_end\n17.104670\n2.0\n0\ncomplete\nMINORS_registration\nMINORS_registration_2\n4\n\n\n3\n1\nNon-Trauma\nMINORS_examination_begins\nresource_use\n15.418481\n1.0\n0\nstart\nMINORS_examination\nMINORS_examination_1\n5\n\n\n5\n1\nNon-Trauma\nMINORS_examination_complete\nresource_use_end\n31.636252\n1.0\n0\ncomplete\nMINORS_examination\nMINORS_examination_1\n5\n\n\n11\n2\nNon-Trauma\nMINORS_examination_complete\nresource_use_end\n32.875857\n2.0\n0\ncomplete\nMINORS_examination\nMINORS_examination_2\n6\n\n\n9\n2\nNon-Trauma\nMINORS_examination_begins\nresource_use\n17.104670\n2.0\n0\nstart\nMINORS_examination\nMINORS_examination_2\n6\n\n\n12\n2\nNon-Trauma\nMINORS_treatment_begins\nresource_use\n32.875857\n1.0\n0\nstart\nMINORS_treatment\nMINORS_treatment_1\n7\n\n\n13\n2\nNon-Trauma\nMINORS_treatment_complete\nresource_use_end\n46.278797\n1.0\n0\ncomplete\nMINORS_treatment\nMINORS_treatment_1\n7\n\n\n14\n3\nNon-Trauma\ntriage_begins\nresource_use\n33.426168\n1.0\n0\nstart\ntriage\ntriage_1\n8\n\n\n16\n3\nNon-Trauma\ntriage_complete\nresource_use_end\n33.545008\n1.0\n0\ncomplete\ntriage\ntriage_1\n8\n\n\n15\n3\nNon-Trauma\nMINORS_registration_begins\nresource_use\n33.545008\n1.0\n0\nstart\nMINORS_registration\nMINORS_registration_1\n9\n\n\n18\n3\nNon-Trauma\nMINORS_registration_complete\nresource_use_end\n42.359504\n1.0\n0\ncomplete\nMINORS_registration\nMINORS_registration_1\n9\n\n\n24\n4\nNon-Trauma\ntriage_complete\nresource_use_end\n37.914164\n2.0\n0\ncomplete\ntriage\ntriage_2\n10\n\n\n22\n4\nNon-Trauma\ntriage_begins\nresource_use\n37.900548\n2.0\n0\nstart\ntriage\ntriage_2\n10\n\n\n\n\n\n\n\n\nlogs_transformed[[\"event_name\", \"event_stage\", \"event_type\"]].value_counts()\n\nevent_name            event_stage  event_type      \ntriage                start        resource_use        622\n                      complete     resource_use_end    620\nMINORS_registration   start        resource_use        514\n                      complete     resource_use_end    512\nMINORS_examination    start        resource_use        475\n                      complete     resource_use_end    472\nMINORS_treatment      start        resource_use        264\n                      complete     resource_use_end    262\nTRAUMA_stabilisation  complete     resource_use_end     81\n                      start        resource_use         81\nTRAUMA_treatment      start        resource_use         79\n                      complete     resource_use_end     74\nName: count, dtype: int64\n\n\n\nlogs_transformed.event.value_counts()\n\nevent\ntriage_begins                    622\ntriage_complete                  620\nMINORS_registration_begins       514\nMINORS_registration_complete     512\nMINORS_examination_begins        475\nMINORS_examination_complete      472\nMINORS_treatment_begins          264\nMINORS_treatment_complete        262\nTRAUMA_stabilisation_begins       81\nTRAUMA_stabilisation_complete     81\nTRAUMA_treatment_begins           79\nTRAUMA_treatment_complete         74\nName: count, dtype: int64\n\n\nFor ease, now let’s save these results as a file that we can load into R.\nWe could use a csv for easy interoperability. Alternatively, we could use something like Feather or Parquet, which are usable by both R and Python while retaining data types.\nFor ease of use and long-term readbility, we will use csv in this case.\n\nlogs_transformed.to_csv('simulation_logs_for_bupar.csv', index=False)"
  },
  {
    "objectID": "docs/vidigi_docs/vidigi_vs_bupar.out.html",
    "href": "docs/vidigi_docs/vidigi_vs_bupar.out.html",
    "title": "",
    "section": "",
    "text": "from examples.example_2_branching_multistep.ex_2_model_classes import Trial, g\nimport pandas as pd\nimport os\n\n\ng.sim_duration = 3000\ng.number_of_runs = 1\n\n\nView Imported Code, which has had logging steps added at the appropriate points in the ‘model’ class\nimport random\nimport numpy as np\nimport pandas as pd\nimport simpy\nfrom sim_tools.distributions import Exponential, Lognormal, Uniform, Normal, Bernoulli\nfrom vidigi.utils import populate_store\nfrom examples.simulation_utility_functions import trace\n\n\n# Class to store global parameter values.  We don't create an instance of this\n# class - we just refer to the class blueprint itself to access the numbers\n# inside.\nclass g:\n    '''\n    Create a scenario to parameterise the simulation model\n\n    Parameters:\n    -----------\n    random_number_set: int, optional (default=DEFAULT_RNG_SET)\n        Set to control the initial seeds of each stream of pseudo\n        random numbers used in the model.\n\n    n_triage: int\n        The number of triage cubicles\n\n    n_reg: int\n        The number of registration clerks\n\n    n_exam: int\n        The number of examination rooms\n\n    n_trauma: int\n        The number of trauma bays for stablisation\n\n    n_cubicles_non_trauma_treat: int\n        The number of non-trauma treatment cubicles\n\n    n_cubicles_trauma_treat: int\n        The number of trauma treatment cubicles\n\n    triage_mean: float\n        Mean duration of the triage distribution (Exponential)\n\n    reg_mean: float\n        Mean duration of the registration distribution (Lognormal)\n\n    reg_var: float\n        Variance of the registration distribution (Lognormal)\n\n    exam_mean: float\n        Mean of the examination distribution (Normal)\n\n    exam_var: float\n        Variance of the examination distribution (Normal)\n\n    trauma_mean: float\n        Mean of the trauma stabilisation distribution (Exponential)\n\n    trauma_treat_mean: float\n        Mean of the trauma cubicle treatment distribution (Lognormal)\n\n    trauma_treat_var: float\n        Variance of the trauma cubicle treatment distribution (Lognormal)\n\n    non_trauma_treat_mean: float\n        Mean of the non trauma treatment distribution\n\n    non_trauma_treat_var: float\n        Variance of the non trauma treatment distribution\n\n    non_trauma_treat_p: float\n        Probability non trauma patient requires treatment\n\n    prob_trauma: float\n        probability that a new arrival is a trauma patient.\n    '''\n    random_number_set = 42\n\n    n_triage=2\n    n_reg=2\n    n_exam=3\n    n_trauma=4\n    n_cubicles_non_trauma_treat=4\n    n_cubicles_trauma_treat=5\n\n    triage_mean=6\n    reg_mean=8\n    reg_var=2\n    exam_mean=16\n    exam_var=3\n    trauma_mean=90\n    trauma_treat_mean=30\n    trauma_treat_var=4\n    non_trauma_treat_mean=13.3\n    non_trauma_treat_var=2\n\n    non_trauma_treat_p=0.6\n    prob_trauma=0.12\n\n    arrival_df=\"ed_arrivals.csv\"\n\n    sim_duration = 600\n    number_of_runs = 100\n\n# Class representing patients coming in to the clinic.\nclass Patient:\n    '''\n    Class defining details for a patient entity\n    '''\n    def __init__(self, p_id):\n        '''\n        Constructor method\n\n        Params:\n        -----\n        identifier: int\n            a numeric identifier for the patient.\n        '''\n        self.identifier = p_id\n\n        # Time of arrival in model/at centre\n        self.arrival = -np.inf\n        # Total time in pathway\n        self.total_time = -np.inf\n\n        # Shared waits\n        self.wait_triage = -np.inf\n        self.wait_reg = -np.inf\n        self.wait_treat = -np.inf\n        # Non-trauma pathway - examination wait\n        self.wait_exam = -np.inf\n        # Trauma pathway - stabilisation wait\n        self.wait_trauma = -np.inf\n\n        # Shared durations\n        self.triage_duration = -np.inf\n        self.reg_duration = -np.inf\n        self.treat_duration = -np.inf\n\n        # Non-trauma pathway - examination duration\n        self.exam_duration = -np.inf\n        # Trauma pathway - stabilisation duration\n        self.trauma_duration = -np.inf\n\n\n# Class representing our model of the clinic.\nclass Model:\n    '''\n    Simulates the simplest minor treatment process for a patient\n\n    1. Arrive\n    2. Examined/treated by nurse when one available\n    3. Discharged\n    '''\n    # Constructor to set up the model for a run.  We pass in a run number when\n    # we create a new model.\n    def __init__(self, run_number):\n        # Create a SimPy environment in which everything will live\n        self.env = simpy.Environment()\n\n        self.event_log = []\n\n        # Create a patient counter (which we'll use as a patient ID)\n        self.patient_counter = 0\n\n        self.trauma_patients = []\n        self.non_trauma_patients = []\n\n        # Create our resources\n        self.init_resources()\n\n        # Store the passed in run number\n        self.run_number = run_number\n\n        # Create a new Pandas DataFrame that will store some results against\n        # the patient ID (which we'll use as the index).\n        self.results_df = pd.DataFrame()\n        self.results_df[\"Patient ID\"] = [1]\n        self.results_df[\"Queue Time Cubicle\"] = [0.0]\n        self.results_df[\"Time with Nurse\"] = [0.0]\n        self.results_df.set_index(\"Patient ID\", inplace=True)\n\n        # Create an attribute to store the mean queuing times across this run of\n        # the model\n        self.mean_q_time_cubicle = 0\n\n        # create distributions\n\n        # Triage duration\n        self.triage_dist = Exponential(g.triage_mean,\n                                       random_seed=self.run_number*g.random_number_set)\n\n        # Registration duration (non-trauma only)\n        self.reg_dist = Lognormal(g.reg_mean,\n                                  np.sqrt(g.reg_var),\n                                  random_seed=self.run_number*g.random_number_set)\n\n        # Evaluation (non-trauma only)\n        self.exam_dist = Normal(g.exam_mean,\n                                np.sqrt(g.exam_var),\n                                random_seed=self.run_number*g.random_number_set)\n\n        # Trauma/stablisation duration (trauma only)\n        self.trauma_dist = Exponential(g.trauma_mean,\n                                       random_seed=self.run_number*g.random_number_set)\n\n        # Non-trauma treatment\n        self.nt_treat_dist = Lognormal(g.non_trauma_treat_mean,\n                                       np.sqrt(g.non_trauma_treat_var),\n                                       random_seed=self.run_number*g.random_number_set)\n\n        # treatment of trauma patients\n        self.treat_dist = Lognormal(g.trauma_treat_mean,\n                                    np.sqrt(g.non_trauma_treat_var),\n                                    random_seed=self.run_number*g.random_number_set)\n\n        # probability of non-trauma patient requiring treatment\n        self.nt_p_treat_dist = Bernoulli(g.non_trauma_treat_p,\n                                         random_seed=self.run_number*g.random_number_set)\n\n        # probability of non-trauma versus trauma patient\n        self.p_trauma_dist = Bernoulli(g.prob_trauma,\n                                       random_seed=self.run_number*g.random_number_set)\n\n        # init sampling for non-stationary poisson process\n        self.init_nspp()\n\n    def init_nspp(self):\n\n        # read arrival profile\n        self.arrivals = pd.read_csv(g.arrival_df)  # pylint: disable=attribute-defined-outside-init\n        self.arrivals['mean_iat'] = 60 / self.arrivals['arrival_rate']\n\n        # maximum arrival rate (smallest time between arrivals)\n        self.lambda_max = self.arrivals['arrival_rate'].max()  # pylint: disable=attribute-defined-outside-init\n\n        # thinning exponential\n        self.arrival_dist = Exponential(60.0 / self.lambda_max,  # pylint: disable=attribute-defined-outside-init\n                                            random_seed=self.run_number*g.random_number_set)\n\n        # thinning uniform rng\n        self.thinning_rng = Uniform(low=0.0, high=1.0,  # pylint: disable=attribute-defined-outside-init\n                                    random_seed=self.run_number*g.random_number_set)\n\n\n    def init_resources(self):\n        '''\n        Init the number of resources\n        and store in the arguments container object\n\n        Resource list:\n            1. Nurses/treatment bays (same thing in this model)\n\n        '''\n        # Shared Resources\n        self.triage_cubicles = simpy.Store(self.env)\n        populate_store(num_resources=g.n_triage,\n                simpy_store=self.triage_cubicles,\n                sim_env=self.env)\n\n        self.registration_cubicles = simpy.Store(self.env)\n        populate_store(num_resources=g.n_reg,\n                       simpy_store=self.registration_cubicles,\n                       sim_env=self.env)\n\n        # Non-trauma\n        self.exam_cubicles = simpy.Store(self.env)\n        populate_store(num_resources=g.n_exam,\n                       simpy_store=self.exam_cubicles,\n                       sim_env=self.env)\n\n        self.non_trauma_treatment_cubicles = simpy.Store(self.env)\n        populate_store(num_resources=g.n_cubicles_non_trauma_treat,\n                       simpy_store=self.non_trauma_treatment_cubicles,\n                       sim_env=self.env)\n\n        # Trauma\n        self.trauma_stabilisation_bays = simpy.Store(self.env)\n        populate_store(num_resources=g.n_trauma,\n                       simpy_store=self.trauma_stabilisation_bays,\n                       sim_env=self.env)\n\n        self.trauma_treatment_cubicles = simpy.Store(self.env)\n        populate_store(num_resources=g.n_cubicles_trauma_treat,\n                       simpy_store=self.trauma_treatment_cubicles,\n                       sim_env=self.env)\n\n    # A generator function that represents the DES generator for patient\n    # arrivals\n    def generator_patient_arrivals(self):\n        # We use an infinite loop here to keep doing this indefinitely whilst\n        # the simulation runs\n        while True:\n            t = int(self.env.now // 60) % self.arrivals.shape[0]\n            lambda_t = self.arrivals['arrival_rate'].iloc[t]\n\n            # set to a large number so that at least 1 sample taken!\n            u = np.Inf\n\n            interarrival_time = 0.0\n            # reject samples if u &gt;= lambda_t / lambda_max\n            while u &gt;= (lambda_t / self.lambda_max):\n                interarrival_time += self.arrival_dist.sample()\n                u = self.thinning_rng.sample()\n\n            # Freeze this instance of this function in place until the\n            # inter-arrival time we sampled above has elapsed.  Note - time in\n            # SimPy progresses in \"Time Units\", which can represent anything\n            # you like (just make sure you're consistent within the model)\n            yield self.env.timeout(interarrival_time)\n\n            # Increment the patient counter by 1 (this means our first patient\n            # will have an ID of 1)\n            self.patient_counter += 1\n\n            # Create a new patient - an instance of the Patient Class we\n            # defined above.  Remember, we pass in the ID when creating a\n            # patient - so here we pass the patient counter to use as the ID.\n            p = Patient(self.patient_counter)\n\n            trace(f'patient {self.patient_counter} arrives at: {self.env.now:.3f}')\n            self.event_log.append(\n                {'patient': self.patient_counter,\n                 'pathway': 'Shared',\n                 'event': 'arrival',\n                 'event_type': 'arrival_departure',\n                 'time': self.env.now}\n            )\n\n            # sample if the patient is trauma or non-trauma\n            trauma = self.p_trauma_dist.sample()\n\n            # Tell SimPy to start up the attend_clinic generator function with\n            # this patient (the generator function that will model the\n            # patient's journey through the system)\n            # and store patient in list for later easy access\n            if trauma:\n                # create and store a trauma patient to update KPIs.\n                self.trauma_patients.append(p)\n                self.env.process(self.attend_trauma_pathway(p))\n\n            else:\n                # create and store a non-trauma patient to update KPIs.\n                self.non_trauma_patients.append(p)\n                self.env.process(self.attend_non_trauma_pathway(p))\n\n    # A generator function that represents the pathway for a patient going\n    # through the clinic.\n    # The patient object is passed in to the generator function so we can\n    # extract information from / record information to it\n    def attend_non_trauma_pathway(self, patient):\n        '''\n        simulates the non-trauma/minor treatment process for a patient\n\n        1. request and wait for sign-in/triage\n        2. patient registration\n        3. examination\n        4a. percentage discharged\n        4b. remaining percentage treatment then discharge\n        '''\n        # record the time of arrival and entered the triage queue\n        patient.arrival = self.env.now\n        self.event_log.append(\n            {'patient': patient.identifier,\n             'pathway': 'Non-Trauma',\n             'event_type': 'queue',\n             'event': 'triage_wait_begins',\n             'time': self.env.now}\n        )\n\n        ###################################################\n        # request sign-in/triage\n        triage_resource = yield self.triage_cubicles.get()\n\n        # record the waiting time for triage\n        patient.wait_triage = self.env.now - patient.arrival\n        trace(f'patient {patient.identifier} triaged to minors '\n                f'{self.env.now:.3f}')\n        self.event_log.append(\n            {'patient': patient.identifier,\n                'pathway': 'Non-Trauma',\n                'event_type': 'resource_use',\n                'event': 'triage_begins',\n                'time': self.env.now,\n                'resource_id': triage_resource.id_attribute\n                }\n        )\n\n        # sample triage duration.\n        patient.triage_duration = self.triage_dist.sample()\n        yield self.env.timeout(patient.triage_duration)\n\n        trace(f'triage {patient.identifier} complete {self.env.now:.3f}; '\n                f'waiting time was {patient.wait_triage:.3f}')\n        self.event_log.append(\n            {'patient': patient.identifier,\n                'pathway': 'Non-Trauma',\n                'event_type': 'resource_use_end',\n                'event': 'triage_complete',\n                'time': self.env.now,\n                'resource_id': triage_resource.id_attribute}\n        )\n\n        # Resource is no longer in use, so put it back in the store\n        self.triage_cubicles.put(triage_resource)\n        #########################################################\n\n        # record the time that entered the registration queue\n        start_wait = self.env.now\n        self.event_log.append(\n            {'patient': patient.identifier,\n             'pathway': 'Non-Trauma',\n             'event_type': 'queue',\n             'event': 'MINORS_registration_wait_begins',\n             'time': self.env.now}\n        )\n\n        #########################################################\n        # request registration clerk\n        registration_resource = yield self.registration_cubicles.get()\n\n        # record the waiting time for registration\n        patient.wait_reg = self.env.now - start_wait\n        trace(f'registration of patient {patient.identifier} at '\n                f'{self.env.now:.3f}')\n        self.event_log.append(\n            {'patient': patient.identifier,\n                'pathway': 'Non-Trauma',\n                'event_type': 'resource_use',\n                'event': 'MINORS_registration_begins',\n                'time': self.env.now,\n                'resource_id': registration_resource.id_attribute\n                }\n        )\n\n        # sample registration duration.\n        patient.reg_duration = self.reg_dist.sample()\n        yield self.env.timeout(patient.reg_duration)\n\n        trace(f'patient {patient.identifier} registered at'\n                f'{self.env.now:.3f}; '\n                f'waiting time was {patient.wait_reg:.3f}')\n        self.event_log.append(\n            {'patient': patient.identifier,\n                'pathway': 'Non-Trauma',\n                'event': 'MINORS_registration_complete',\n                'event_type': 'resource_use_end',\n                'time': self.env.now,\n                'resource_id': registration_resource.id_attribute}\n        )\n        # Resource is no longer in use, so put it back in the store\n        self.registration_cubicles.put(registration_resource)\n        ########################################################\n\n        # record the time that entered the evaluation queue\n        start_wait = self.env.now\n\n        self.event_log.append(\n            {'patient': patient.identifier,\n             'pathway': 'Non-Trauma',\n             'event': 'MINORS_examination_wait_begins',\n             'event_type': 'queue',\n             'time': self.env.now}\n        )\n\n        #########################################################\n        # request examination resource\n        examination_resource = yield self.exam_cubicles.get()\n\n        # record the waiting time for examination to begin\n        patient.wait_exam = self.env.now - start_wait\n        trace(f'examination of patient {patient.identifier} begins '\n                f'{self.env.now:.3f}')\n        self.event_log.append(\n            {'patient': patient.identifier,\n                'pathway': 'Non-Trauma',\n                'event': 'MINORS_examination_begins',\n                'event_type': 'resource_use',\n                'time': self.env.now,\n                'resource_id': examination_resource.id_attribute\n                }\n        )\n\n        # sample examination duration.\n        patient.exam_duration = self.exam_dist.sample()\n        yield self.env.timeout(patient.exam_duration)\n\n        trace(f'patient {patient.identifier} examination complete '\n                f'at {self.env.now:.3f};'\n                f'waiting time was {patient.wait_exam:.3f}')\n        self.event_log.append(\n            {'patient': patient.identifier,\n                'pathway': 'Non-Trauma',\n                'event': 'MINORS_examination_complete',\n                'event_type': 'resource_use_end',\n                'time': self.env.now,\n                'resource_id': examination_resource.id_attribute}\n        )\n        # Resource is no longer in use, so put it back in\n        self.exam_cubicles.put(examination_resource)\n        ############################################################################\n\n        # sample if patient requires treatment?\n        patient.require_treat = self.nt_p_treat_dist.sample()  #pylint: disable=attribute-defined-outside-init\n\n        if patient.require_treat:\n\n            self.event_log.append(\n                {'patient': patient.identifier,\n                 'pathway': 'Non-Trauma',\n                 'event': 'requires_treatment',\n                 'event_type': 'attribute_assigned',\n                 'time': self.env.now}\n            )\n\n            # record the time that entered the treatment queue\n            start_wait = self.env.now\n            self.event_log.append(\n                {'patient': patient.identifier,\n                 'pathway': 'Non-Trauma',\n                 'event': 'MINORS_treatment_wait_begins',\n                 'event_type': 'queue',\n                 'time': self.env.now}\n            )\n            ###################################################\n            # request treatment cubicle\n\n            non_trauma_treatment_resource = yield self.non_trauma_treatment_cubicles.get()\n\n            # record the waiting time for treatment\n            patient.wait_treat = self.env.now - start_wait\n            trace(f'treatment of patient {patient.identifier} begins '\n                    f'{self.env.now:.3f}')\n            self.event_log.append(\n                {'patient': patient.identifier,\n                    'pathway': 'Non-Trauma',\n                    'event': 'MINORS_treatment_begins',\n                    'event_type': 'resource_use',\n                    'time': self.env.now,\n                    'resource_id': non_trauma_treatment_resource.id_attribute\n                }\n            )\n\n            # sample treatment duration.\n            patient.treat_duration = self.nt_treat_dist.sample()\n            yield self.env.timeout(patient.treat_duration)\n\n            trace(f'patient {patient.identifier} treatment complete '\n                    f'at {self.env.now:.3f};'\n                    f'waiting time was {patient.wait_treat:.3f}')\n            self.event_log.append(\n                {'patient': patient.identifier,\n                    'pathway': 'Non-Trauma',\n                    'event': 'MINORS_treatment_complete',\n                    'event_type': 'resource_use_end',\n                    'time': self.env.now,\n                    'resource_id': non_trauma_treatment_resource.id_attribute}\n            )\n\n            # Resource is no longer in use, so put it back in the store\n            self.non_trauma_treatment_cubicles.put(non_trauma_treatment_resource)\n        ##########################################################################\n\n        # Return to what happens to all patients, regardless of whether they were sampled as needing treatment\n        self.event_log.append(\n            {'patient': patient.identifier,\n            'pathway': 'Shared',\n            'event': 'depart',\n            'event_type': 'arrival_departure',\n            'time': self.env.now}\n        )\n\n        # total time in system\n        patient.total_time = self.env.now - patient.arrival\n\n    def attend_trauma_pathway(self, patient):\n        '''\n        simulates the major treatment process for a patient\n\n        1. request and wait for sign-in/triage\n        2. trauma\n        3. treatment\n        '''\n        # record the time of arrival and entered the triage queue\n        patient.arrival = self.env.now\n        self.event_log.append(\n            {'patient': patient.identifier,\n             'pathway': 'Trauma',\n             'event_type': 'queue',\n             'event': 'triage_wait_begins',\n             'time': self.env.now}\n        )\n\n        ###################################################\n        # request sign-in/triage\n        triage_resource = yield self.triage_cubicles.get()\n\n        # record the waiting time for triage\n        patient.wait_triage = self.env.now - patient.arrival\n\n        trace(f'patient {patient.identifier} triaged to trauma '\n                f'{self.env.now:.3f}')\n        self.event_log.append(\n            {'patient': patient.identifier,\n             'pathway': 'Trauma',\n             'event_type': 'resource_use',\n             'event': 'triage_begins',\n             'time': self.env.now,\n             'resource_id': triage_resource.id_attribute\n            }\n        )\n\n        # sample triage duration.\n        patient.triage_duration = self.triage_dist.sample()\n        yield self.env.timeout(patient.triage_duration)\n\n        trace(f'triage {patient.identifier} complete {self.env.now:.3f}; '\n              f'waiting time was {patient.wait_triage:.3f}')\n        self.event_log.append(\n            {'patient': patient.identifier,\n             'pathway': 'Trauma',\n             'event_type': 'resource_use_end',\n             'event': 'triage_complete',\n             'time': self.env.now,\n             'resource_id': triage_resource.id_attribute}\n        )\n\n        # Resource is no longer in use, so put it back in the store\n        self.triage_cubicles.put(triage_resource)\n        ###################################################\n\n        # record the time that entered the trauma queue\n        start_wait = self.env.now\n        self.event_log.append(\n            {'patient': patient.identifier,\n             'pathway': 'Trauma',\n             'event_type': 'queue',\n             'event': 'TRAUMA_stabilisation_wait_begins',\n             'time': self.env.now}\n        )\n\n        ###################################################\n        # request trauma room\n        trauma_resource = yield self.trauma_stabilisation_bays.get()\n\n        self.event_log.append(\n            {'patient': patient.identifier,\n                'pathway': 'Trauma',\n                'event_type': 'resource_use',\n                'event': 'TRAUMA_stabilisation_begins',\n                'time': self.env.now,\n                'resource_id': trauma_resource.id_attribute\n                }\n        )\n\n        # record the waiting time for trauma\n        patient.wait_trauma = self.env.now - start_wait\n\n        # sample stablisation duration.\n        patient.trauma_duration = self.trauma_dist.sample()\n        yield self.env.timeout(patient.trauma_duration)\n\n        trace(f'stabilisation of patient {patient.identifier} at '\n              f'{self.env.now:.3f}')\n        self.event_log.append(\n            {'patient': patient.identifier,\n             'pathway': 'Trauma',\n             'event_type': 'resource_use_end',\n             'event': 'TRAUMA_stabilisation_complete',\n             'time': self.env.now,\n             'resource_id': trauma_resource.id_attribute\n            }\n        )\n        # Resource is no longer in use, so put it back in the store\n        self.trauma_stabilisation_bays.put(trauma_resource)\n\n        #######################################################\n\n        # record the time that patient entered the treatment queue\n        start_wait = self.env.now\n        self.event_log.append(\n            {'patient': patient.identifier,\n             'pathway': 'Trauma',\n             'event_type': 'queue',\n             'event': 'TRAUMA_treatment_wait_begins',\n             'time': self.env.now}\n        )\n\n        ########################################################\n        # request treatment cubicle\n        trauma_treatment_resource = yield self.trauma_treatment_cubicles.get()\n\n        # record the waiting time for trauma\n        patient.wait_treat = self.env.now - start_wait\n        trace(f'treatment of patient {patient.identifier} at '\n                f'{self.env.now:.3f}')\n        self.event_log.append(\n            {'patient': patient.identifier,\n                'pathway': 'Trauma',\n                'event_type': 'resource_use',\n                'event': 'TRAUMA_treatment_begins',\n                'time': self.env.now,\n                'resource_id': trauma_treatment_resource.id_attribute\n                }\n        )\n\n        # sample treatment duration.\n        patient.treat_duration = self.trauma_dist.sample()\n        yield self.env.timeout(patient.treat_duration)\n\n        trace(f'patient {patient.identifier} treatment complete {self.env.now:.3f}; '\n              f'waiting time was {patient.wait_treat:.3f}')\n        self.event_log.append(\n            {'patient': patient.identifier,\n             'pathway': 'Trauma',\n             'event_type': 'resource_use_end',\n             'event': 'TRAUMA_treatment_complete',\n             'time': self.env.now,\n             'resource_id': trauma_treatment_resource.id_attribute}\n        )\n        self.event_log.append(\n            {'patient': patient.identifier,\n            'pathway': 'Shared',\n            'event': 'depart',\n            'event_type': 'arrival_departure',\n            'time': self.env.now}\n        )\n\n        # Resource is no longer in use, so put it back in the store\n        self.trauma_treatment_cubicles.put(trauma_treatment_resource)\n\n        #########################################################\n\n        # total time in system\n        patient.total_time = self.env.now - patient.arrival\n\n\n    # This method calculates results over a single run.  Here we just calculate\n    # a mean, but in real world models you'd probably want to calculate more.\n    def calculate_run_results(self):\n        # Take the mean of the queuing times across patients in this run of the\n        # model.\n        self.mean_q_time_cubicle = self.results_df[\"Queue Time Cubicle\"].mean()\n\n    # The run method starts up the DES entity generators, runs the simulation,\n    # and in turns calls anything we need to generate results for the run\n    def run(self):\n        # Start up our DES entity generators that create new patients.  We've\n        # only got one in this model, but we'd need to do this for each one if\n        # we had multiple generators.\n        self.env.process(self.generator_patient_arrivals())\n\n        # Run the model for the duration specified in g class\n        self.env.run(until=g.sim_duration)\n\n        # Now the simulation run has finished, call the method that calculates\n        # run results\n        self.calculate_run_results()\n\n        self.event_log = pd.DataFrame(self.event_log)\n\n        self.event_log[\"run\"] = self.run_number\n\n        return {'results': self.results_df, 'event_log': self.event_log}\n\n# Class representing a Trial for our simulation - a batch of simulation runs.\nclass Trial:\n    # The constructor sets up a pandas dataframe that will store the key\n    # results from each run against run number, with run number as the index.\n    def  __init__(self):\n        self.df_trial_results = pd.DataFrame()\n        self.df_trial_results[\"Run Number\"] = [0]\n        self.df_trial_results[\"Arrivals\"] = [0]\n        self.df_trial_results[\"Mean Queue Time Cubicle\"] = [0.0]\n        self.df_trial_results.set_index(\"Run Number\", inplace=True)\n\n        self.all_event_logs = []\n\n    # Method to run a trial\n    def run_trial(self):\n        # Run the simulation for the number of runs specified in g class.\n        # For each run, we create a new instance of the Model class and call its\n        # run method, which sets everything else in motion.  Once the run has\n        # completed, we grab out the stored run results (just mean queuing time\n        # here) and store it against the run number in the trial results\n        # dataframe.\n        for run in range(g.number_of_runs):\n            random.seed(run)\n\n            my_model = Model(run)\n            model_outputs = my_model.run()\n            patient_level_results = model_outputs[\"results\"]\n            event_log = model_outputs[\"event_log\"]\n\n            self.df_trial_results.loc[run] = [\n                len(patient_level_results),\n                my_model.mean_q_time_cubicle,\n            ]\n\n            # print(event_log)\n\n            self.all_event_logs.append(event_log)\n\n        self.all_event_logs = pd.concat(self.all_event_logs)\n\n\nmy_trial = Trial()\n\nmy_trial.run_trial()\n\n\nmy_trial.all_event_logs.head(10)"
  }
]