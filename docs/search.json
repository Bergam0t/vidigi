[
  {
    "objectID": "vidigi_docs/vidigi_vs_bupar.html",
    "href": "vidigi_docs/vidigi_vs_bupar.html",
    "title": "Vidigi vs BupaR",
    "section": "",
    "text": "The title of this section is perhaps misleading! As the author of the package, I think the visuals produced by the two packages occupy slightly different niches, and the use of both can benefit your project.\nAs an additional bonus, the process of creating the logs you require for a vidigi project give you the perfect dataset for your bupaR visuals too!\nbupaR outputs could form part of a verification and validation strategy. They can also perform part of your communications strategy, helping to provide a talking point for meetings with stakeholders in much the same way as a screenshot of your Simul8 or Anylogic model would. In the absence of a graphical interface for building a model, the bupar outputs can help you - and your stakeholders - to ensure that linkages between different model steps are sensible and appropriate.\nWe will begin in Python, working to add a couple of columns to our vidigi event log to prepare it for use in bupaR.\nNow, it’s time to move to R (as bupaR and the bupaverse is only implemented in R).\npm4py exists as a process analytics package for Python, but the visuals of bupaR are of a high quality.",
    "crumbs": [
      "Miscellaneous",
      "Vidigi vs BupaR"
    ]
  },
  {
    "objectID": "vidigi_docs/vidigi_vs_bupar.html#creating-outputs",
    "href": "vidigi_docs/vidigi_vs_bupar.html#creating-outputs",
    "title": "Vidigi vs BupaR",
    "section": "Creating outputs",
    "text": "Creating outputs\n\nProcess Maps\n\nAbsolute frequencies\n\nactivity_log %&gt;%\n    process_map(frequency(\"absolute\"))\n\n\n\n\n\n\nactivity_log %&gt;%\n    process_map(frequency(\"absolute-case\"))\n\n\n\n\n\n\n\nRelative frequencies\n\nactivity_log %&gt;%\n    process_map(frequency(\"relative\"))\n\n\n\n\n\n\nactivity_log %&gt;%\n    process_map(frequency(\"relative-case\"),\n              render_options = list(edge_label_color = \"white\"))\n\n\n\n\n\n\nactivity_log %&gt;%\n    process_map(frequency(\"relative-consequent\"),\n              render_options = list(edge_label_color = \"white\"))\n\n\n\n\n\n\n\n\nPerformance Maps\n\nMean Waits\n\nactivity_log %&gt;%\n    process_map(performance())\n\n\n\n\n\n\n\nMax Waits\n\nactivity_log %&gt;%\n    process_map(performance(FUN = max))\n\nWarning: There was 1 warning in `summarize()`.\nℹ In argument: `label = do.call(...)`.\nℹ In group 9: `ACTIVITY_CLASSIFIER_ = NA` and `from_id = NA`.\nCaused by warning in `type()`:\n! no non-missing arguments to max; returning -Inf\n\n\nWarning: There were 2 warnings in `summarize()`.\nThe first warning was:\nℹ In argument: `value = do.call(...)`.\nℹ In group 1: `ACTIVITY_CLASSIFIER_ = \"ARTIFICIAL_END\"`, `next_act = NA`,\n  `from_id = 1`, `to_id = NA`.\nCaused by warning in `type()`:\n! no non-missing arguments to max; returning -Inf\nℹ Run `dplyr::last_dplyr_warnings()` to see the 1 remaining warning.\n\n\n\n\n\n\n\n\n90th percentile\n\np90 &lt;- function(x, ...) {\n    quantile(x, probs = 0.9, ...)\n}\n\nactivity_log %&gt;%\n    process_map(performance(FUN = p90))\n\n\n\n\n\n\n\n\nAnalytics\nTake a look at this page in the bupaR docs details of each of these plots.\n\nIdle Time\n\nactivity_log %&gt;%\n    idle_time(\"resource\", units = \"mins\")\n\n# A tibble: 20 × 2\n   resource_id_full       idle_time     \n   &lt;chr&gt;                  &lt;drtn&gt;        \n 1 MINORS_treatment_1     2101.6612 mins\n 2 MINORS_treatment_2     2065.5869 mins\n 3 MINORS_treatment_3     2043.3483 mins\n 4 MINORS_treatment_4     1945.5681 mins\n 5 TRAUMA_treatment_1     1415.3914 mins\n 6 TRAUMA_treatment_2     1275.9829 mins\n 7 TRAUMA_treatment_3     1208.0795 mins\n 8 TRAUMA_treatment_5     1098.2404 mins\n 9 triage_2               1043.9654 mins\n10 triage_1                999.9198 mins\n11 TRAUMA_treatment_4      959.1452 mins\n12 MINORS_registration_2   951.0949 mins\n13 MINORS_registration_1   943.0261 mins\n14 TRAUMA_stabilisation_1  881.6663 mins\n15 TRAUMA_stabilisation_2  714.7071 mins\n16 TRAUMA_stabilisation_3  691.9842 mins\n17 TRAUMA_stabilisation_4  564.1900 mins\n18 MINORS_examination_2    469.1167 mins\n19 MINORS_examination_1    463.9669 mins\n20 MINORS_examination_3    441.1148 mins\n\n\n\nactivity_log %&gt;%\n    idle_time(\"resource\", units = \"mins\") %&gt;%\n    plot()\n\n\n\n\n\n\n\n\n\n\nProcessing Time\n\nactivity_log %&gt;%\n    processing_time(\"log\", units = \"mins\") %&gt;%\n    plot()\n\n\n\n\n\n\n\n\n\nactivity_log %&gt;%\n    processing_time(\"case\", units = \"mins\") %&gt;%\n    plot()\n\n\n\n\n\n\n\n\n\nactivity_log %&gt;%\n    processing_time(\"activity\", units = \"mins\") %&gt;%\n    plot()\n\n\n\n\n\n\n\n\n\nactivity_log %&gt;%\n    processing_time(\"resource-activity\", units = \"mins\") %&gt;%\n    plot()\n\n\n\n\n\n\n\n\n\n\nThroughput time\n\nactivity_log %&gt;%\n    throughput_time(\"log\", units = \"mins\") %&gt;%\n    plot()\n\n\n\n\n\n\n\n\n\n\nActivity Presence\n\nactivity_log %&gt;%\n    activity_presence() %&gt;%\n    plot()\n\n\n\n\n\n\n\n\n\n\n\nResource visualisations\n\nHandover-of-work network\n\nactivity_log %&gt;%\n    resource_map()\n\n\n\n\n\n\n\nResource precedence matrix\n\nactivity_log %&gt;%\n    resource_matrix() %&gt;%\n    plot()\n\n\n\n\n\n\n\n\n\n\n\nProcess matrix\n\nactivity_log %&gt;%\n    process_matrix(frequency(\"absolute\")) %&gt;%\n    plot()\n\n\n\n\n\n\n\n\n\n\nTrace Explorer\nThis plot helps us to unerstand how often different combinations of activities occur, and whether there are any unexpected paths in our data.\n\nactivity_log %&gt;%\n    trace_explorer(n_traces = 10)\n\nWarning: Fewer traces (6) found than specified `n_traces` (10).\n\n\n\n\n\n\n\n\n\n\n\nAnimated process map\n\nactivity_log %&gt;%\n    animate_process()\n\n\n\n\n\nLet’s compare directly with our vidigi output.\n\n\n\n\n\n\nTip\n\n\n\nThe key difference between what is produced via bupaverse’s animate_process and what can be created via vidigi is the ability of vidigi to more clearly show the scale of queues, and the number of resources available at any given point.\nVidigi can also more clearly highlight the impact of priority on resources through the use of distinct icons, though this is not demonstrated in this example.\n\n\n\n\n\n\n\n\nClick here to expand vidigi animation generation code\n\n\n\n\n\n\nfrom examples.example_2_branching_multistep.ex_2_model_classes import Trial, g\nfrom vidigi.animation import animate_activity_log\nimport pandas as pd\nimport plotly.io as pio\n#pio.renderers.default = \"notebook\"\npio.renderers.default = \"iframe\"\n\ng.sim_duration = 3000\ng.number_of_runs = 3\n\nmy_trial = Trial()\n\nmy_trial.run_trial()\n\nevent_position_df = pd.DataFrame([\n                # {'event': 'arrival', 'x':  10, 'y': 250, 'label': \"Arrival\" },\n\n                # Triage - minor and trauma\n                {'event': 'triage_wait_begins',\n                 'x':  160, 'y': 375, 'label': \"Waiting for&lt;br&gt;Triage\"  },\n                {'event': 'triage_begins',\n                 'x':  160, 'y': 315, 'resource':'n_triage', 'label': \"Being Triaged\" },\n\n                # Minors (non-trauma) pathway\n                {'event': 'MINORS_registration_wait_begins',\n                 'x':  300, 'y': 145, 'label': \"Waiting for&lt;br&gt;Registration\"  },\n                {'event': 'MINORS_registration_begins',\n                 'x':  300, 'y': 85, 'resource':'n_reg', 'label':'Being&lt;br&gt;Registered'  },\n\n                {'event': 'MINORS_examination_wait_begins',\n                 'x':  465, 'y': 145, 'label': \"Waiting for&lt;br&gt;Examination\"  },\n                {'event': 'MINORS_examination_begins',\n                 'x':  465, 'y': 85, 'resource':'n_exam', 'label': \"Being&lt;br&gt;Examined\" },\n\n                {'event': 'MINORS_treatment_wait_begins',\n                 'x':  630, 'y': 145, 'label': \"Waiting for&lt;br&gt;Treatment\"  },\n                {'event': 'MINORS_treatment_begins',\n                 'x':  630, 'y': 85, 'resource':'n_cubicles_non_trauma_treat', 'label': \"Being&lt;br&gt;Treated\" },\n\n                # Trauma pathway\n                {'event': 'TRAUMA_stabilisation_wait_begins',\n                 'x': 300, 'y': 560, 'label': \"Waiting for&lt;br&gt;Stabilisation\" },\n                {'event': 'TRAUMA_stabilisation_begins',\n                 'x': 300, 'y': 490, 'resource':'n_trauma', 'label': \"Being&lt;br&gt;Stabilised\" },\n\n                {'event': 'TRAUMA_treatment_wait_begins',\n                 'x': 630, 'y': 560, 'label': \"Waiting for&lt;br&gt;Treatment\" },\n                {'event': 'TRAUMA_treatment_begins',\n                 'x': 630, 'y': 490, 'resource':'n_cubicles_trauma_treat', 'label': \"Being&lt;br&gt;Treated\" },\n\n                 {'event': 'depart',\n                 'x':  670, 'y': 330, 'label': \"Exit\"}\n            ])\n\n\nanimate_activity_log(\n        event_log=my_trial.all_event_logs[my_trial.all_event_logs['run']==0],\n        event_position_df=event_position_df,\n        scenario=g(),\n        entity_col_name=\"patient\",\n        debug_mode=False,\n        setup_mode=False,\n        every_x_time_units=5,\n        include_play_button=True,\n        gap_between_entities=10,\n        gap_between_queue_rows=20,\n        plotly_height=900,\n        plotly_width=1600,\n        override_x_max=700,\n        override_y_max=675,\n        entity_icon_size=20,\n        resource_icon_size=20,\n        wrap_queues_at=10,\n        step_snapshot_max=50,\n        limit_duration=3000,\n        time_display_units=\"dhm\",\n        display_stage_labels=False,\n        add_background_image=\"https://raw.githubusercontent.com/Bergam0t/vidigi/refs/heads/main/examples/example_2_branching_multistep/Full%20Model%20Background%20Image%20-%20Horizontal%20Layout.drawio.png\",\n    )\n\n\n\n\n\n\n\n\n\n\n\nOther chart types\n\nDotted chart\nWe can see the impact of the pattern of daily arrivals across the course of the model, with the waits clearing out overnight when arrivals slow down.\n\nactivity_log %&gt;%\n    dotted_chart(x = \"absolute\")\n\n\n\n\n\n\n\n\n\nactivity_log %&gt;%\n    dotted_chart(x = \"relative\", sort=\"start\")\n\n\n\n\n\n\n\n\n\n\nBreaking down dotted charts by route\n\nMinors\n\nactivity_log %&gt;%\n    filter(event_name %in% c('MINORS_examination', 'MINORS_registration', 'MINORS_treatment', 'triage')) %&gt;%\n    dotted_chart(x = \"absolute\")\n\n\n\n\n\n\n\n\n\nactivity_log %&gt;%\n    filter(event_name %in% c('MINORS_examination', 'MINORS_registration', 'MINORS_treatment', 'triage')) %&gt;%\n    dotted_chart(x = \"relative\", sort=\"start\")\n\n\n\n\n\n\n\n\n\n\nTrauma\n\nactivity_log %&gt;%\n    filter(event_name %in% c('TRAUMA_stabilisation', 'TRAUMA_treatment', 'triage')) %&gt;%\n    dotted_chart(x = \"absolute\")\n\n\n\n\n\n\n\n\n\nactivity_log %&gt;%\n    filter(event_name %in% c('TRAUMA_stabilisation', 'TRAUMA_treatment', 'triage')) %&gt;%\n    dotted_chart(x = \"relative\", sort=\"start\")",
    "crumbs": [
      "Miscellaneous",
      "Vidigi vs BupaR"
    ]
  },
  {
    "objectID": "vidigi_docs/vidigi_vs_bupar.html#conclusion",
    "href": "vidigi_docs/vidigi_vs_bupar.html#conclusion",
    "title": "Vidigi vs BupaR",
    "section": "Conclusion",
    "text": "Conclusion\nvidigi and bupaR are complementary packages to use when visualising, verifying and validating your simulation models - or working with real-world process data.",
    "crumbs": [
      "Miscellaneous",
      "Vidigi vs BupaR"
    ]
  },
  {
    "objectID": "vidigi_docs/introduction.html",
    "href": "vidigi_docs/introduction.html",
    "title": "Usage Instructions with SimPy",
    "section": "",
    "text": "Visual display of the outputs of discrete event simulations in simpy have been identified as one of the limitations of simpy, potentially hindering adoption of FOSS simulation in comparison to commercial modelling offerings or GUI FOSS alternatives such as JaamSim.\n\nWhen compared to commercial DES software packages that are commonly used in health research, such as Simul8, or AnyLogic, a limitation of our approach is that we do not display a dynamic patient pathway or queuing network that updates as the model runs a single replication. This is termed Visual Interactive Simulation (VIS) and can help users understand where process problems and delays occur in a patient pathway; albeit with the caveat that single replications can be outliers. A potential FOSS solution compatible with a browser-based app could use a Python package that can represent a queuing network, such as NetworkX, and displaying results via matplotlib. If sophisticated VIS is essential for a FOSS model then researchers may need to look outside of web apps; for example, salabim provides a powerful FOSS solution for custom animation of DES models. - Monks T and Harper A. Improving the usability of open health service delivery simulation models using Python and web apps [version 2; peer review: 3 approved]. NIHR Open Res 2023, 3:48 (https://doi.org/10.3310/nihropenres.13467.2)\n\nThis package allows visually appealing, flexible visualisations of the movement of entities through some kind of pathway.\nIt is primarily tested with discrete event simulations to be created from simpy models, such as the examples below.\n\nPlotly is leveraged to create the final animation, meaning that users can benefit from the ability to further customise or extend the plotly plot, as well as easily integrating with web frameworks such as Streamlit, Dash or Shiny for Python.\nThe code has been designed to be flexible and could potentially be used with alternative simulation packages such as ciw or simmer if it is possible to provide all of the required details in the logs that are output.",
    "crumbs": [
      "Introduction"
    ]
  },
  {
    "objectID": "vidigi_docs/introduction.html#introduction",
    "href": "vidigi_docs/introduction.html#introduction",
    "title": "Usage Instructions with SimPy",
    "section": "",
    "text": "Visual display of the outputs of discrete event simulations in simpy have been identified as one of the limitations of simpy, potentially hindering adoption of FOSS simulation in comparison to commercial modelling offerings or GUI FOSS alternatives such as JaamSim.\n\nWhen compared to commercial DES software packages that are commonly used in health research, such as Simul8, or AnyLogic, a limitation of our approach is that we do not display a dynamic patient pathway or queuing network that updates as the model runs a single replication. This is termed Visual Interactive Simulation (VIS) and can help users understand where process problems and delays occur in a patient pathway; albeit with the caveat that single replications can be outliers. A potential FOSS solution compatible with a browser-based app could use a Python package that can represent a queuing network, such as NetworkX, and displaying results via matplotlib. If sophisticated VIS is essential for a FOSS model then researchers may need to look outside of web apps; for example, salabim provides a powerful FOSS solution for custom animation of DES models. - Monks T and Harper A. Improving the usability of open health service delivery simulation models using Python and web apps [version 2; peer review: 3 approved]. NIHR Open Res 2023, 3:48 (https://doi.org/10.3310/nihropenres.13467.2)\n\nThis package allows visually appealing, flexible visualisations of the movement of entities through some kind of pathway.\nIt is primarily tested with discrete event simulations to be created from simpy models, such as the examples below.\n\nPlotly is leveraged to create the final animation, meaning that users can benefit from the ability to further customise or extend the plotly plot, as well as easily integrating with web frameworks such as Streamlit, Dash or Shiny for Python.\nThe code has been designed to be flexible and could potentially be used with alternative simulation packages such as ciw or simmer if it is possible to provide all of the required details in the logs that are output.",
    "crumbs": [
      "Introduction"
    ]
  },
  {
    "objectID": "vidigi_docs/introduction.html#examples",
    "href": "vidigi_docs/introduction.html#examples",
    "title": "Usage Instructions with SimPy",
    "section": "Examples",
    "text": "Examples\nTo develop and demonstrate the concept, it has so far been used to incorporate visualisation into several existing simpy models that were not initially designed with this sort of visualisation in mind: - a minor injuries unit, showing the utility of the model at high resolutions with branching pathways and the ability to add in a custom background to clearly demarcate process steps\n\n\nan elective surgical pathway (with a focus on cancelled theatre slots due to bed unavailability in recovery areas), with length of stay displayed as well as additional text and graphical data\n\n\n\na community mental health assessment pathway, showing the wait to an appointment as well as highlighting ‘urgent’ patients with a different icon and showing the time from referral to appointment below the patient icons when they attend the appointment.\n\n\n\na community mental health assessment pathway with pooling of clinics, showing the ‘home’ clinic for clients via icon so the balance between ‘home’ and ‘other’ clients can be explored.\n\n\n\na community mental health assessment and treatment pathway, showing the movement of clients between a wait list, a booking list, and returning for repeat appointments over a period of time while sitting on a caseload in between.",
    "crumbs": [
      "Introduction"
    ]
  },
  {
    "objectID": "vidigi_docs/introduction.html#creating-a-visualisation-from-an-existing-model",
    "href": "vidigi_docs/introduction.html#creating-a-visualisation-from-an-existing-model",
    "title": "Usage Instructions with SimPy",
    "section": "Creating a visualisation from an existing model",
    "text": "Creating a visualisation from an existing model\nTwo key things need to happen to existing models to work with the visualisation code: 1. All simpy resources need to be changed to simpy stores containing a custom resource with an ID attribute 2. Logging needs to be added at key points: arrival, (queueing, resource use start, resource use end), departure where the steps in the middle can be repeated for as many queues and resource types as required\n\n1. All simpy resources need to be changed to simpy stores containing a custom resource with an ID attribute\nTo allow the use of resources to be visualised correctly - with entities staying with the same resource throughout the time they are using it - it is essential to be able to identify and track individual resources.\nBy default, this is not possible with Simpy resources. They have no ID attribute or similar.\n\n\nClick here for behind-the-scenes details on this\n\nThe easiest workaround which drops fairly painlessly into existing models is to use a simpy store with a custom resource class.\nThe custom resource is setup as follows:\n\nclass CustomResource(simpy.Resource):\n    def __init__(self, env, capacity, id_attribute=None):\n        super().__init__(env, capacity)\n        self.id_attribute = id_attribute\n\n    def request(self, *args, **kwargs):\n        # Add logic to handle the ID attribute when a request is made\n        return super().request(*args, **kwargs)\n\n    def release(self, *args, **kwargs):\n        # Add logic to handle the ID attribute when a release is made\n        return super().release(*args, **kwargs)\n\nThe creation of simpy resources is then replaced with the following pattern:\n\nbeds = simpy.Store(environment)\n\nfor i in range(number_of_beds):\n    beds.put(\n        CustomResource(\n            environment,\n            capacity=1,\n            id_attribute=i+1)\n        )\n\n\nvidigi.resources provides a helper function for setting up simpy resources in the required manner.\nFor a given resource that would have been created like this:\n\nnurses = simpy.Resource(simpy_environment, capacity=number_of_nurses)\n\nYou would use\n\nfrom vidigi.resources import populate_store\nnurses = simpy.Store(simpy_environment)\n\npopulate_store(num_resources=number_of_nurses, simpy_store=nurses, sim_env=simpy_environment)\n\nInstead of requesting a resource in the standard way, you instead use the .get() method.\n\nreq = beds.get()\n\nor\n\nwith beds.get() as req:\n  ...CODE HERE THAT USES THE RESOURCE...\n\nAt the end, it is important to put the resource back into the store, even if you used the ‘with’ notation, so it can be made available to the next requester:\n\nbeds.put(req)\n\nThis becomes slightly more complex with conditional requesting (for example, where a resource request is made but if it cannot be fulfilled in time, the requester will renege). This is demonstrated in example 3.\nThe benefit of this is that when we are logging, we can use the .id_attribute attribute of the custom resource to record the resource that was in use. This can have wider benefits for monitoring individual resource utilisation within your model as well.\n\n\n2. Logging needs to be added at key points\nThe animation function needs to be passed an event log with the following layout:\n\n\n\n\n\n\n\n\n\n\n\npatient\npathway\nevent_type\nevent\ntime\nresource_id\n\n\n\n\n15\nPrimary\narrival_departure\narrival\n1.22\n\n\n\n15\nPrimary\nqueue\nenter_queue_for_bed\n1.35\n\n\n\n27\nRevision\narrival_departure\narrival\n1.47\n\n\n\n27\nRevision\nqueue\nenter_queue_for_bed\n1.58\n\n\n\n12\nPrimary\nresource_use_end\npost_surgery_stay_ends\n1.9\n4\n\n\n15\nRevision\nresource_use\npost_survery_stay_begins\n1.9\n4\n\n\n\nOne easy way to achieve this is by appending dictionaries to a list at each important point in the process. For example:\n\nevent_log = []\n...\n...\nevent_log.append(\n      {'patient': id,\n      'pathway': 'Revision',\n      'event_type': 'resource_use',\n      'event': 'post_surgery_stay_begins',\n      'time': self.env.now,\n      'resource_id': bed.id_attribute}\n  )\n\nThe list of dictionaries can then be converted to a pandas dataframe using\n\npd.DataFrame(event_log)\n\nand passed to the animation function where required.\n\nEvent types\nFour event types are supported in the model: ‘arrival_departure’, ‘resource_use’, ‘resource_use_end’, and ‘queue’.\nAs a minimum, you will require the use of ‘arrival_departure’ events and one of - ‘resource_use’/‘resource_use_end’ - OR ‘queue’\nYou can also use both ‘resource_use’ and ‘queue’ within the same model very effectively (see ex_1_simplest_case and ex_2_branching_and_optional_paths).\n\narrival_departure\nWithin this, a minimum of two ‘arrival_departure’ events per entity are mandatory - arrival and depart, both with an event_type of arrival_departure, as shown below.\n\nevent_log.append(\n      {'patient': unique_entity_identifier,\n      'pathway': 'Revision',\n      'event_type': 'arrival_departure',\n      'event': 'arrival',\n      'time': env.now}\n  )\n\n\nevent_log.append(\n      {'patient': unique_entity_identifier,\n      'pathway': 'Revision',\n      'event_type': 'arrival_departure',\n      'event': 'depart',\n      'time': env.now}\n  )\n\nThese are critical as they are used to determine when patients should first and last appear in the model. Forgetting to include a departure step for all types of patients can lead to slow model performance as the size of the event logs for individual moments will continue to increase indefinitely.\n\n\nqueue\nQueues are key steps in the model.\nIt is possible to solely use queues and never make use of a simpy resource.\nBy tracking each important step in the process as a ‘queue’ step, the movement of patients can be accurately tracked.\nPatients will be ordered by the point at which they are added to the queue, with the first entries appearing at the front (bottom-right) of the queue.\n\nevent_log.append(\n            {'patient': unique_entity_identifier,\n             'pathway': 'High intensity',\n             'event_type': 'queue',\n             'event': 'appointment_booked_waiting',\n             'time': self.env.now\n             }\n        )\n\nWhile the keys shown above are mandatory, you can add as many additional keys to a step’s log as desired. This can allow you to flexibly make use of the event log for other purposes as well as the animation.\n\n\nresource_use and resource_use_end\nResource use is more complex to include but comes with two key benefits over the queue: - it becomes easier to monitor the length of time a resource is in use by a single entity as users won’t ‘move through’ the resource use stage (which can also prove confusing to less experienced viewers) - it becomes possible to show the total number of resources that are available, making it easier to understand how well resources are being utilised at different stages\n\nclass CustomResource(simpy.Resource):\n    def __init__(self, env, capacity, id_attribute=None):\n        super().__init__(env, capacity)\n        self.id_attribute = id_attribute\n\n    def request(self, *args, **kwargs):\n        # Add logic to handle the ID attribute when a request is made\n        # For example, you can assign an ID to the requester\n        # self.id_attribute = assign_id_logic()\n        return super().request(*args, **kwargs)\n\n    def release(self, *args, **kwargs):\n        # Add logic to handle the ID attribute when a release is made\n        # For example, you can reset the ID attribute\n        # reset_id_logic(self.id_attribute)\n        return super().release(*args, **kwargs)\n\ntriage = simpy.Store(self.env)\n\nfor i in range(n_triage):\n    triage.put(\n        CustomResource(\n            env,\n            capacity=1,\n            id_attribute = i+1)\n        )\n\n# request sign-in/triage\ntriage_resource = yield triage.get()\n\nevent_log.append(\n    {'patient': unique_entity_identifier,\n     'pathway': 'Trauma',\n     'event_type': 'resource_use',\n     'event': 'triage_begins',\n     'time': env.now,\n     'resource_id': triage_resource.id_attribute\n    }\n)\n\nyield self.env.timeout(1)\n\nevent_log.append(\n            {'patient': unique_entity_identifier,\n             'pathway': 'Trauma',\n             'event_type': 'resource_use_end',\n             'event': 'triage_complete',\n             'time': env.now,\n             'resource_id': triage_resource.id_attribute}\n        )\n\n# Resource is no longer in use, so put it back in the store\ntriage.put(triage_resource)\n\nWhen providing your event position details, it then just requires you to include an identifier for the resource.\nNOTE: At present this requires you to be using an class to manage your resource counts (if following HSMA simpy structure, this will be your g class).\nThis requirement is planned to be removed in a future version of the work, allowing more flexibility.\n\n{'event': 'TRAUMA_stabilisation_begins',\n 'x': 300, 'y': 500, 'resource':'n_trauma', 'label': \"Being&lt;br&gt;Stabilised\" }",
    "crumbs": [
      "Introduction"
    ]
  },
  {
    "objectID": "vidigi_docs/introduction.html#creating-the-animation",
    "href": "vidigi_docs/introduction.html#creating-the-animation",
    "title": "Usage Instructions with SimPy",
    "section": "Creating the animation",
    "text": "Creating the animation\n\nDetermining event positioning in the animation\nOnce the event log has been created, the positions of each queue and resource must be set up.\nAn easy way to create this is passing a list of dictionaries to the pd.DataFrame function.\nThe columns required are event: This must match the label used for the event in the event log x: The x coordinate of the event for the animation. This will correspond to the bottom-right hand corner of a queue, or the rightmost resource. y: The y coordinate of the event for the animaation. This will correspond to the lowest row of a queue, or the central point of the resources. label: A label for the stage. This can be hidden at a later step if you opt to use a background image with labels built-in. Note that line breaks in the label can be created using the HTML tag &lt;br&gt;. resource (OPTIONAL): Only required if the step is a resource_use step. This looks at the ‘scenario’ object passed to the animate_activity_log() function and pulls the attribute with the given name, which should give the number of available resources for that step.\n\n        event_position_df = pd.DataFrame([\n                # Triage\n                {'event': 'triage_wait_begins',\n                 'x':  160, 'y': 400, 'label': \"Waiting for&lt;br&gt;Triage\"  },\n                {'event': 'triage_begins',\n                 'x':  160, 'y': 315, 'resource':'n_triage', 'label': \"Being Triaged\" },\n\n                # Trauma pathway\n                {'event': 'TRAUMA_stabilisation_wait_begins',\n                 'x': 300, 'y': 560, 'label': \"Waiting for&lt;br&gt;Stabilisation\" },\n                {'event': 'TRAUMA_stabilisation_begins',\n                 'x': 300, 'y': 500, 'resource':'n_trauma', 'label': \"Being&lt;br&gt;Stabilised\" },\n\n                {'event': 'TRAUMA_treatment_wait_begins',\n                 'x': 630, 'y': 560, 'label': \"Waiting for&lt;br&gt;Treatment\" },\n                {'event': 'TRAUMA_treatment_begins',\n                 'x': 630, 'y': 500, 'resource':'n_cubicles', 'label': \"Being&lt;br&gt;Treated\" },\n\n                 {'event': 'depart',\n                 'x':  670, 'y': 330, 'label': \"Exit\"}\n            ])\n\n\n\nCreating the animation\nThere are two main ways to create the animation:\n\nusing the one-step function animate_activity_log() (see pages/1_Simple_ED_interactive, pages/2_Simple_ED_Forced_Overcrowding or pages/3_Complex_ED_Interactive for examples of this)\nusing the functions reshape_for_animations(), generate_animation_df() and generate_animation() separately, passing the output of each to the next step. This allows you to apply significant extra customisations; examples demonstrating this will be added soon.",
    "crumbs": [
      "Introduction"
    ]
  },
  {
    "objectID": "vidigi_docs/introduction.html#emergency-department-treatment-centre-model",
    "href": "vidigi_docs/introduction.html#emergency-department-treatment-centre-model",
    "title": "Usage Instructions with SimPy",
    "section": "Emergency department (Treatment Centre) model",
    "text": "Emergency department (Treatment Centre) model\nMonks.T, Harper.A, Anagnoustou. A, Allen.M, Taylor.S. (2022) Open Science for Computer Simulation\nhttps://github.com/TomMonks/treatment-centre-sim\nThe layout code for the emergency department model: https://github.com/hsma-programme/Teaching_DES_Concepts_Streamlit",
    "crumbs": [
      "Introduction"
    ]
  },
  {
    "objectID": "vidigi_docs/introduction.html#the-hospital-efficiency-project-model",
    "href": "vidigi_docs/introduction.html#the-hospital-efficiency-project-model",
    "title": "Usage Instructions with SimPy",
    "section": "The hospital efficiency project model",
    "text": "The hospital efficiency project model\nHarper, A., & Monks, T. Hospital Efficiency Project Orthopaedic Planning Model Discrete-Event Simulation [Computer software]. https://doi.org/10.5281/zenodo.7951080\nhttps://github.com/AliHarp/HEP/tree/main",
    "crumbs": [
      "Introduction"
    ]
  },
  {
    "objectID": "vidigi_docs/introduction.html#simulation-model-with-scheduling-example",
    "href": "vidigi_docs/introduction.html#simulation-model-with-scheduling-example",
    "title": "Usage Instructions with SimPy",
    "section": "Simulation model with scheduling example",
    "text": "Simulation model with scheduling example\nMonks, T.\nhttps://github.com/health-data-science-OR/stochastic_systems\nhttps://github.com/health-data-science-OR/stochastic_systems/tree/master/labs/simulation/lab5",
    "crumbs": [
      "Introduction"
    ]
  },
  {
    "objectID": "vidigi_docs/adding_vidigi_to_a_simple_simpy_model_hsma_structure_old.html",
    "href": "vidigi_docs/adding_vidigi_to_a_simple_simpy_model_hsma_structure_old.html",
    "title": "Adding Vidigi to a Simple simpy Model (HSMA Structure) - vidigi 0.0.4 and below",
    "section": "",
    "text": "On the Health Service Modelling Associates (HSMA) course we teach a particular way of writing your simpy models. More details of the approach we take can be found in our Little Book of DES.\nHowever, the core concepts of adding vidigi to your models will be the same across different models - so this example will hopefully be helpful regardless of the way you structure your simpy models.",
    "crumbs": [
      "Working with older versions of vidigi",
      "Adding Vidigi to a Simple simpy Model (HSMA Structure) - vidigi 0.0.4 and below"
    ]
  },
  {
    "objectID": "vidigi_docs/adding_vidigi_to_a_simple_simpy_model_hsma_structure_old.html#vidigis-requirements",
    "href": "vidigi_docs/adding_vidigi_to_a_simple_simpy_model_hsma_structure_old.html#vidigis-requirements",
    "title": "Adding Vidigi to a Simple simpy Model (HSMA Structure) - vidigi 0.0.4 and below",
    "section": "Vidigi’s requirements",
    "text": "Vidigi’s requirements\nThe key input vidigi requires an event log of the times that each entity in your system reached key milestones like arriving in the system, beginning to queue for a resource, being seen by a resource, and exiting the system.\nWe also need to tell vidigi what kind of activity is happening at each point:\n\narrive/depart\nqueue\nresource_use\n\nWe also provide vidigi with a table of coordinates that will help it to lay out our entities and resources, and determine their path from the entrance, to the exit, and to some extent their movement between stages.\nVidigi then takes this event log and the layout table and will process them into a table that tracks the position of every entity in the system at specified time intervals.",
    "crumbs": [
      "Working with older versions of vidigi",
      "Adding Vidigi to a Simple simpy Model (HSMA Structure) - vidigi 0.0.4 and below"
    ]
  },
  {
    "objectID": "vidigi_docs/adding_vidigi_to_a_simple_simpy_model_hsma_structure_old.html#hsma-model-structure",
    "href": "vidigi_docs/adding_vidigi_to_a_simple_simpy_model_hsma_structure_old.html#hsma-model-structure",
    "title": "Adding Vidigi to a Simple simpy Model (HSMA Structure) - vidigi 0.0.4 and below",
    "section": "HSMA Model Structure",
    "text": "HSMA Model Structure\nIn HSMA, we use four primary classes to structure our models:\n\ng, which stores model parameters (like the number of resources of a given type and distribution parameters) and simulation parameters (like the number of replications to run and the )\nEntity, which may be named something more descriptive like ‘Patient’ or ‘Customer’. You may also have more than one entity class. Each entity will store information such as its ID, and will be passed into the model to work through the pathway.\nModel, which will generate entities, simulate the pathway the entity takes through the system, and contain a way to run a single replication of the model\nTrial, which allows us to run the simulation multiple times, collect results from all of these, and get an indication of average performance and performance variation across our different model runs",
    "crumbs": [
      "Working with older versions of vidigi",
      "Adding Vidigi to a Simple simpy Model (HSMA Structure) - vidigi 0.0.4 and below"
    ]
  },
  {
    "objectID": "vidigi_docs/adding_vidigi_to_a_simple_simpy_model_hsma_structure_old.html#a-simple-model",
    "href": "vidigi_docs/adding_vidigi_to_a_simple_simpy_model_hsma_structure_old.html#a-simple-model",
    "title": "Adding Vidigi to a Simple simpy Model (HSMA Structure) - vidigi 0.0.4 and below",
    "section": "A Simple Model",
    "text": "A Simple Model\nWe’re going to start off with a very simple model of a walk-in clinic pathway.\nIn this clinic, patients arrive and are seen in the order they arrive by one of several available nurses. All nurses have the same skillset, so the queue is a simple first-in-first-out (FIFO). There is some variability in the arrival time of patients, as well as variability in how long it takes for each patient to be seen.\n\nthe g Class\nIn our g class, we set up parameters that will be used throughout.\n\nclass g:\n    random_number_set = 42 # Control\n    ial seeds of each stream of pseudorandom numbers used\n\n    n_cubicles = 3 # The number of treatment cubicles\n    trauma_treat_mean = 40 # Mean of the trauma cubicle treatment distribution (Lognormal)\n    trauma_treat_var = 5 # Variance of the trauma cubicle treatment distribution (Lognormal)\n\n    arrival_rate = 5 # mean of the exponential distribution for sampling the inter-arrival time of entities\n\n\n    sim_duration = 600 # The number of time units the simulation will run for\n    number_of_runs = 100 # The number of times the simulation will be run with different random number streams\n\n\n\nthe Patient Class\nOur Patient class represents a single individual.\nThe attributes in this class are used to track various metrics that will be used for determining how well our particular scenario has performed - think of it like a person holding a clipboard that is having various times and figures recorded on it as they move through the system.\n\nclass Patient:\n    def __init__(self, p_id):\n        self.identifier = p_id\n        self.arrival = -np.inf\n        self.wait_treat = -np.inf\n        self.total_time = -np.inf\n        self.treat_duration = -np.inf\n\n\n\nthe Model Class\nOur model class is more complex.\n:::\n\nthe init method\nFirst, we set up a series of attributes\n\n    def __init__(self, run_number):\n        # Create a SimPy environment in which everything will live\n        self.env = simpy.Environment()\n\n        # Create a patient counter (which we'll use as a patient ID)\n        self.patient_counter = 0\n\n        self.patients = []\n\n        # Create our resources\n        self.init_resources()\n\n        # Store the passed in run number\n        self.run_number = run_number\n\n        # Create a new Pandas DataFrame that will store some results against\n        # the patient ID (which we'll use as the index).\n        self.results_df = pd.DataFrame()\n        self.results_df[\"Patient ID\"] = [1]\n        self.results_df[\"Queue Time Cubicle\"] = [0.0]\n        self.results_df[\"Time with Nurse\"] = [0.0]\n        self.results_df.set_index(\"Patient ID\", inplace=True)\n\n        # Create an attribute to store the mean queuing times across this run of\n        # the model\n        self.mean_q_time_cubicle = 0\n\n        self.patient_inter_arrival_dist = Exponential(mean = g.arrival_rate,\n                                                      random_seed = self.run_number*g.random_number_set)\n        self.treat_dist = Lognormal(mean = g.trauma_treat_mean,\n                                    stdev = g.trauma_treat_var,\n                                    random_seed = self.run_number*g.random_number_set)\n\n\n\nthe init_resources method\n\n    def init_resources(self):\n        '''\n        Init the number of resources\n\n        Resource list:\n            1. Nurses/treatment bays (same thing in this model)\n\n        '''\n        self.treatment_cubicles = simpy.Resource(self.env, capacity=g.n_cubicles)\n\n\n\nthe generator_patient_arrivals method\n\n    def generator_patient_arrivals(self):\n        # We use an infinite loop here to keep doing this indefinitely whilst\n        # the simulation runs\n        while True:\n            # Increment the patient counter by 1 (this means our first patient\n            # will have an ID of 1)\n            self.patient_counter += 1\n\n            # Create a new patient - an instance of the Patient Class we\n            # defined above.  Remember, we pass in the ID when creating a\n            # patient - so here we pass the patient counter to use as the ID.\n            p = Patient(self.patient_counter)\n\n            # Store patient in list for later easy access\n            self.patients.append(p)\n\n            # Tell SimPy to start up the attend_clinic generator function with\n            # this patient (the generator function that will model the\n            # patient's journey through the system)\n            self.env.process(self.attend_clinic(p))\n\n            # Randomly sample the time to the next patient arriving.  Here, we\n            # sample from an exponential distribution (common for inter-arrival\n            # times), and pass in a lambda value of 1 / mean.  The mean\n            # inter-arrival time is stored in the g class.\n            sampled_inter = self.patient_inter_arrival_dist.sample()\n\n            # Freeze this instance of this function in place until the\n            # inter-arrival time we sampled above has elapsed.  Note - time in\n            # SimPy progresses in \"Time Units\", which can represent anything\n            # you like (just make sure you're consistent within the model)\n            yield self.env.timeout(sampled_inter)\n\n\n\nthe attend_clinic function\n\n    def attend_clinic(self, patient):\n        self.arrival = self.env.now\n\n        # request examination resource\n        start_wait = self.env.now\n\n        with self.treatment_cubicles.request() as req:\n            # Seize a treatment resource when available\n            yield req\n\n            # record the waiting time for registration\n            self.wait_treat = self.env.now - start_wait\n\n            # sample treatment duration\n            self.treat_duration = self.treat_dist.sample()\n            yield self.env.timeout(self.treat_duration)\n\n        # total time in system\n        self.total_time = self.env.now - self.arrival\n\n\n\nthe calculate_run_results function\n\n    def calculate_run_results(self):\n        # Take the mean of the queuing times across patients in this run of the\n        # model.\n        self.mean_q_time_cubicle = self.results_df[\"Queue Time Cubicle\"].mean()\n\n\n\nthe run function\n\n    def run(self):\n        # Start up our DES entity generators that create new patients.  We've\n        # only got one in this model, but we'd need to do this for each one if\n        # we had multiple generators.\n        self.env.process(self.generator_patient_arrivals())\n\n        # Run the model for the duration specified in g class\n        self.env.run(until=g.sim_duration)\n\n        # Now the simulation run has finished, call the method that calculates\n        # run results\n        self.calculate_run_results()\n\n\n\n\nthe Trial Class\n\nthe init method\n\ndef  __init__(self):\n    self.df_trial_results = pd.DataFrame()\n    self.df_trial_results[\"Run Number\"] = [0]\n    self.df_trial_results[\"Arrivals\"] = [0]\n    self.df_trial_results[\"Mean Queue Time Cubicle\"] = [0.0]\n    self.df_trial_results.set_index(\"Run Number\", inplace=True)\n\n\n\nThe run_trial method\nRun the simulation for the number of runs specified in g class.\nor each run, we create a new instance of the Model class and call its run method, which sets everything else in motion.\nOnce the run has completed, we grab out the stored run results (just mean queuing time here) and store it against the run number in the trial results dataframe.\n\n    def run_trial(self):\n        print(f\"{g.n_cubicles} nurses\")\n        print(\"\") ## Print a blank line\n\n        for run in range(g.number_of_runs):\n            random.seed(run)\n\n            my_model = Model(run)\n            my_model.run()\n\n            self.df_trial_results.loc[run] = [my_model.mean_q_time_cubicle]\n\n        return self.df_trial_results",
    "crumbs": [
      "Working with older versions of vidigi",
      "Adding Vidigi to a Simple simpy Model (HSMA Structure) - vidigi 0.0.4 and below"
    ]
  },
  {
    "objectID": "vidigi_docs/adding_vidigi_to_a_simple_simpy_model_hsma_structure_old.html#making-changes-for-vidigi",
    "href": "vidigi_docs/adding_vidigi_to_a_simple_simpy_model_hsma_structure_old.html#making-changes-for-vidigi",
    "title": "Adding Vidigi to a Simple simpy Model (HSMA Structure) - vidigi 0.0.4 and below",
    "section": "Making Changes for Vidigi",
    "text": "Making Changes for Vidigi\n\nimports\n\n\n\nOriginal\n\nimport random\nimport numpy as np\nimport pandas as pd\nimport simpy\nfrom sim_tools.distributions import Exponential, Lognormal\n\n\n\n\n\n\nWith Vidigi Modifications\n\nimport random\nimport numpy as np\nimport pandas as pd\nimport simpy\nfrom sim_tools.distributions import Exponential, Lognormal\nfrom vidigi.resources import populate_store \nfrom vidigi.animation import animate_activity_log \n\n\n\n\n\n\nthe g Class\nOur g class is unchanged.\n\n\nthe Entity Class\nOur entity class - in this case, Patient - is unchanged.\n\n\nthe Model Class\n\nThe init method\nTo our init method for the Model class, we add an empty list that will store event logs throughout the model run for each patient.\n\n\n\nOriginal\n\ndef __init__(self, run_number):\n    # Create a SimPy environment in which everything will live\n    self.env = simpy.Environment()\n\n    # Create a patient counter (which we'll use as a patient ID)\n    self.patient_counter = 0\n\n    # Create an empty list to store patient objects in\n    self.patients = []\n\n    # Create our resources\n    self.init_resources()\n\n    # Store the passed in run number\n    self.run_number = run_number\n\n    # Create a new Pandas DataFrame that will store some results\n    # against the patient ID (which we'll use as the index).\n    self.results_df = pd.DataFrame()\n    self.results_df[\"Patient ID\"] = [1]\n    self.results_df[\"Queue Time Cubicle\"] = [0.0]\n    self.results_df[\"Time with Nurse\"] = [0.0]\n    self.results_df.set_index(\"Patient ID\", inplace=True)\n\n    # Create an attribute to store the mean queuing times\n    # across this run of the model\n    self.mean_q_time_cubicle = 0\n\n    self.patient_inter_arrival_dist = Exponential(\n        mean = g.arrival_rate,\n        random_seed = self.run_number*g.random_number_set\n        )\n\n    self.treat_dist = Lognormal(\n        mean = g.trauma_treat_mean,\n        stdev = g.trauma_treat_var,\n        random_seed = self.run_number*g.random_number_set\n        )\n\n\n\n\n\n\nWith Vidigi Modifications\n\ndef __init__(self, run_number):\n    # Create a SimPy environment in which everything will live\n    self.env = simpy.Environment()\n\n    # Add an empty list to store our event logs in \n    self.event_log = [] \n\n    # Create a patient counter (which we'll use as a patient ID)\n    self.patient_counter = 0\n\n    # Create an empty list to store patient objects in\n    self.patients = []\n\n    # Create our resources\n    self.init_resources()\n\n    # Store the passed in run number\n    self.run_number = run_number\n\n    # Create a new Pandas DataFrame that will store some results\n    # against the patient ID (which we'll use as the index)\n    self.results_df = pd.DataFrame()\n    self.results_df[\"Patient ID\"] = [1]\n    self.results_df[\"Queue Time Cubicle\"] = [0.0]\n    self.results_df[\"Time with Nurse\"] = [0.0]\n    self.results_df.set_index(\"Patient ID\", inplace=True)\n\n    # Create an attribute to store the mean queuing times\n    # across this run of the model\n    self.mean_q_time_cubicle = 0\n\n    self.patient_inter_arrival_dist = Exponential(\n        mean = g.arrival_rate,\n        random_seed = self.run_number*g.random_number_set\n        )\n\n    self.treat_dist = Lognormal(\n        mean = g.trauma_treat_mean,\n        stdev = g.trauma_treat_var,\n        random_seed = self.run_number*g.random_number_set\n        )\n\n\n\n\n\n\nthe init_resources method\nVidigi needs to know which resource a user made use of so that we can ensure it stays with the correct resource throughout its time in the animation.\nThe standard simpy Resource does not have a way of tracking that, so we need to do two things: - create a simpy Store that we will store our resources in - use the vidigi helper function populate_store() to generate a store full of special resources that each have a unique ID we can track when doing our event logging\nOverall, the use of stores won’t generally change your code too much - and we cover exactly what needs to change a little later in this document.\nIf you are using priority resources, this step will be a little different - see Example 3 in the documents if you need to use Resources that prioritise some entities over others.\n\n\n\nOriginal\n\ndef init_resources(self):\n    self.treatment_cubicles = simpy.Resource(\n        self.env,\n        capacity=g.n_cubicles\n        )\n\n\n\n\n\n\nWith Vidigi Modifications\n\ndef init_resources(self):\n    self.treatment_cubicles = simpy.Store(self.env) \n\n    populate_store(  \n        num_resources=g.n_cubicles, \n        simpy_store=self.treatment_cubicles, \n        sim_env=self.env\n        ) \n\n\n\n\n\n\nthe generator_patient_arrivals method\nThis method is unchanged.\n\n\nthe attend_clinic method\nThis is the key place in which we add our logging. The logs are what vidigi relies on to calculate who should be where, when, within the animation.\nEvent logging takes the format below:\n\nself.event_log.append(\n        {'patient': entity_identifier,\n            'pathway': 'My_Pathway_Name',\n            'event_type': 'arrival_departure', # or 'queue', 'resource_use', or 'resource_use_end'\n            'event': 'arrival', # or 'depart', or for 'queue' and 'resource_use' or 'resource_use_end' you can determine your own event name\n            'time': self.env.now}\n    )\n\nMore details about event logging can be found in the ‘Event Logging’ page.\nThis is also where we need to change the way we request resources to account for the fact we are now using a simpy store instead of directly interacting with our simpy resources.\nWhere we would have previously used\n\nwith self.treatment_cubicles.request() as req:\n    # Seize a treatment resource when available\n    yield req\n\n    # ALL CODE WHERE WE NEED TO KEEP HOLD OF THE RESOURCE\n\n# CONTINUE AFTER RELEASING RESOURCE HERE\n\nwe instead now use\n\n# Seize a treatment resource when available\ntreatment_resource = yield self.treatment_cubicles.get()\n\n# ALL CODE WHERE WE NEED TO KEEP HOLD OF THE RESOURCE\n\n# CONTINUE AFTER RELEASING RESOURCE HERE\n\n# Resource is no longer in use, so put it back in the store\nself.treatment_cubicles.put(treatment_resource)\n\n\n\n\nOriginal\n\ndef attend_clinic(self, patient):\n    self.arrival = self.env.now\n\n    # request examination resource\n    start_wait = self.env.now\n\n    with self.treatment_cubicles.request() as req:\n        # Seize a treatment resource when available\n        yield req\n\n        # record the waiting time for registration\n        self.wait_treat = self.env.now - start_wait\n\n        # sample treatment duration\n        self.treat_duration = self.treat_dist.sample()\n        yield self.env.timeout(self.treat_duration)\n\n    # total time in system\n    self.total_time = self.env.now - self.arrival\n\n\n\n\n\n\nWith Vidigi Modifications\n\ndef attend_clinic(self, patient):\n    self.arrival = self.env.now\n    self.event_log.append( \n        {'patient': patient.identifier, \n            'pathway': 'Simplest', \n            'event_type': 'arrival_departure', \n            # you must use this event name for arrival events\n            'event': 'arrival',  \n            'time': self.env.now} \n    ) \n\n    # request examination resource\n    start_wait = self.env.now\n    self.event_log.append( \n        {'patient': patient.identifier, \n            'pathway': 'Simplest', \n            # for a queue, you can define your chosen event name\n            'event': 'treatment_wait_begins', \n            'event_type': 'queue', \n            'time': self.env.now} \n    ) \n\n    # Seize a treatment resource when available\n    treatment_resource = yield self.treatment_cubicles.get() \n\n    # record the waiting time for registration\n    self.wait_treat = self.env.now - start_wait\n    self.event_log.append( \n        {'patient': patient.identifier, \n            'pathway': 'Simplest', \n            'event': 'treatment_begins', \n            # for a resource_use, you can define your chosen event name\n            'event_type': 'resource_use', \n            'time': self.env.now, \n            # grab the resource id from the treatment_resource requested\n            'resource_id': treatment_resource.id_attribute \n            } \n    ) \n\n    # sample treatment duration\n    self.treat_duration = self.treat_dist.sample()\n    yield self.env.timeout(self.treat_duration)\n\n    self.event_log.append( \n        {'patient': patient.identifier, \n            'pathway': 'Simplest', \n            # for a resource_use_end, you can define your chosen event name\n            'event': 'treatment_complete', \n            'event_type': 'resource_use_end', \n            'time': self.env.now, \n            'resource_id': treatment_resource.id_attribute} \n    ) \n\n    # Resource is no longer in use, so put it back in the store \n    self.treatment_cubicles.put(treatment_resource) \n\n    # total time in system\n    self.total_time = self.env.now - self.arrival\n    self.event_log.append( \n        {'patient': patient.identifier, \n        'pathway': 'Simplest', \n        'event': 'depart', # you must use this event name for departure events \n        'event_type': 'arrival_departure', \n        'time': self.env.now} \n    ) \n\n\n\n\n\n\nthe calculate_run_results method\nThis method is unchanged.\n\n\nthe run method\n\n\n\nOriginal\n\ndef run(self):\n    # Start up our DES entity generators that create new patients.  We've\n    # only got one in this model, but we'd need to do this for each one if\n    # we had multiple generators.\n    self.env.process(self.generator_patient_arrivals())\n\n    # Run the model for the duration specified in g class\n    self.env.run(until=g.sim_duration)\n\n    # Now the simulation run has finished, call the method that calculates\n    # run results\n    self.calculate_run_results()\n\n\n\n\n\n\nWith Vidigi Modifications\n\ndef run(self):\n    # Start up our DES entity generators that create new patients.  We've\n    # only got one in this model, but we'd need to do this for each one if\n    # we had multiple generators.\n    self.env.process(self.generator_patient_arrivals())\n\n    # Run the model for the duration specified in g class\n    self.env.run(until=g.sim_duration)\n\n    # Now the simulation run has finished, call the method that calculates\n    # run results\n    self.calculate_run_results()\n\n    self.event_log = pd.DataFrame(self.event_log) \n\n    self.event_log[\"run\"] = self.run_number \n\n    return {'results': self.results_df, 'event_log': self.event_log}  \n\n\n\n\n\n\n\nthe Trial Class\n\nthe init method\n\n\n\nOriginal\n\ndef  __init__(self):\n    self.df_trial_results = pd.DataFrame()\n    self.df_trial_results[\"Run Number\"] = [0]\n    self.df_trial_results[\"Arrivals\"] = [0]\n    self.df_trial_results[\"Mean Queue Time Cubicle\"] = [0.0]\n    self.df_trial_results.set_index(\"Run Number\", inplace=True)\n\n\n\n\n\n\nWith Vidigi Modifications\n\ndef  __init__(self):\n    self.df_trial_results = pd.DataFrame()\n    self.df_trial_results[\"Run Number\"] = [0]\n    self.df_trial_results[\"Arrivals\"] = [0]\n    self.df_trial_results[\"Mean Queue Time Cubicle\"] = [0.0]\n    self.df_trial_results.set_index(\"Run Number\", inplace=True)\n\n    self.all_event_logs = [] \n\n\n\n\n\n\nthe run_trial method\n\n\n\nOriginal\n\ndef run_trial(self):\n    for run in range(g.number_of_runs):\n        random.seed(run)\n\n        my_model = Model(run)\n        my_model.run()\n\n        self.df_trial_results.loc[run] = [\n            my_model.mean_q_time_cubicle\n        ]\n\n    return self.df_trial_results\n\n\n\n\n\n\nWith Vidigi Modifications\n\ndef run_trial(self):\n    for run in range(g.number_of_runs):\n        random.seed(run)\n\n        my_model = Model(run)\n        model_outputs = my_model.run()\n        patient_level_results = model_outputs[\"results\"] \n        event_log = model_outputs[\"event_log\"] \n\n        self.df_trial_results.loc[run] = [\n            my_model.mean_q_time_cubicle\n        ]\n\n        self.all_event_logs.append(event_log) \n\n    self.all_event_logs = pd.concat(self.all_event_logs)",
    "crumbs": [
      "Working with older versions of vidigi",
      "Adding Vidigi to a Simple simpy Model (HSMA Structure) - vidigi 0.0.4 and below"
    ]
  },
  {
    "objectID": "vidigi_docs/adding_vidigi_to_a_simple_simpy_model_hsma_structure_old.html#using-vidigi-to-create-an-animation-from-our-event-log",
    "href": "vidigi_docs/adding_vidigi_to_a_simple_simpy_model_hsma_structure_old.html#using-vidigi-to-create-an-animation-from-our-event-log",
    "title": "Adding Vidigi to a Simple simpy Model (HSMA Structure) - vidigi 0.0.4 and below",
    "section": "Using vidigi to create an animation from our event log",
    "text": "Using vidigi to create an animation from our event log\nFor simple animations with vidigi, it is recommended that you use the animate_activity_log function.\nThis all-in-one function takes an event log of the structure discussed above, then turns it into an animated output that can be embedded in a quarto document, a web app, or saved as a standalone HTML file.\nFirst, we need to create an instance of our trial class, then run the trial.\n\nmy_trial = Trial()\n\nmy_trial.run_trial()\n\nThe dataframe of event logs can then be viewed using my_trial.all_event_logs\n\nThe event_position_df\nWe can then generate our coordinates for the initial positioning of each step.\n\n\n\n\n\n\nNote\n\n\n\nThe ‘event’ names must match the event names you assigned in the logging steps.\nHowever, this will not be displayed anywhere in the final setup. Instead, use ‘label’ to define a human-readable label that can optionally be displayed in the final animation.\n\n\n\n\n\n\n\n\nWarning\n\n\n\n‘label’ should not be left out or be an empty string - both of these will cause problems.\n\n\n\n\n\n\n\n\nNote\n\n\n\nYou only need to provide positions for\n\narrival\ndeparture\nqueue\nresource_use (optional - you can have an animation that is only queues)\n\ni.e. you do not need to provide coordinates for resource_use_end\nYou can also opt to skip any queue or resource_use steps you do not want to show, though note that this could produce a misleading output if not carefully explained to end users\n\n\n\n\n\n\n\n\nTip\n\n\n\nFor queues and resource use, the coordinate will correspond to the bottom-right-hand corner of the block of queueing entities or resources.\n\n\n\nevent_position_df = pd.DataFrame([\n                    {'event': 'arrival',\n                     'x':  50, 'y': 300,\n                     'label': \"Arrival\" },\n\n                    # Triage - minor and trauma\n                    {'event': 'treatment_wait_begins',\n                     'x':  205, 'y': 275,\n                     'label': \"Waiting for Treatment\"},\n\n                    {'event': 'treatment_begins',\n                     'x':  205, 'y': 175,\n                     'resource':'n_cubicles',\n                     'label': \"Being Treated\"},\n\n                    {'event': 'depart',\n                     'x':  270, 'y': 70,\n                     'label': \"Exit\"}\n\n                ])",
    "crumbs": [
      "Working with older versions of vidigi",
      "Adding Vidigi to a Simple simpy Model (HSMA Structure) - vidigi 0.0.4 and below"
    ]
  },
  {
    "objectID": "vidigi_docs/adding_vidigi_to_a_simple_simpy_model_hsma_structure_old.html#creating-the-animation",
    "href": "vidigi_docs/adding_vidigi_to_a_simple_simpy_model_hsma_structure_old.html#creating-the-animation",
    "title": "Adding Vidigi to a Simple simpy Model (HSMA Structure) - vidigi 0.0.4 and below",
    "section": "Creating the animation",
    "text": "Creating the animation\nFinally, we can create the animation.\n\n\n\n\n\n\nWarning\n\n\n\nIt is important that you only pass in a single run at a time!\nPassing a dataframe in containing more than one run will produce incorrect animations.\nYou may, however, wish to give the user control over which run they visualise using a dropdown in something like Streamlit or Shiny - or perhaps\n\n\n\nsingle_run_event_log_df = my_trial.all_event_logs[my_trial.all_event_logs['run']==1]\n\nanimate_activity_log(\n        event_log=single_run_event_log_df,\n        event_position_df= event_position_df,\n        scenario=g(), # Use an instance of the g class as our scenario\n        limit_duration=g.sim_duration,\n        debug_mode=True, # Turn on logging messages\n        setup_mode=True, # Turn on axis units - this can help with honing your event_position_df\n        every_x_time_units=1,\n        include_play_button=True,\n        entity_icon_size=20,\n        resource_icon_size=20,\n        gap_between_entities=6,\n        gap_between_resource_rows=25,\n        plotly_height=700,\n        frame_duration=200,\n        plotly_width=1200,\n        override_x_max=300,\n        override_y_max=500,\n        wrap_queues_at=25,\n        step_snapshot_max=125,\n        time_display_units=\"dhm\",\n        display_stage_labels=True # display our Label column from our event_position_df\n    )\n\n\n\n\n\n\n\nClick here to view the full code\n\n\n\n\n\n\nimport random\nimport numpy as np\nimport pandas as pd\nimport simpy\nfrom sim_tools.distributions import Exponential, Lognormal\nfrom vidigi.resources import populate_store\nfrom vidigi.animation import animate_activity_log\n\n# Class to store global parameter values.  We don't create an instance of this\n# class - we just refer to the class blueprint itself to access the numbers\n# inside.\nclass g:\n    '''\n    Create a scenario to parameterise the simulation model\n\n    Parameters:\n    -----------\n    random_number_set: int, optional (default=DEFAULT_RNG_SET)\n        Set to control the initial seeds of each stream of pseudo\n        random numbers used in the model.\n\n    n_cubicles: int\n        The number of treatment cubicles\n\n    trauma_treat_mean: float\n        Mean of the trauma cubicle treatment distribution (Lognormal)\n\n    trauma_treat_var: float\n        Variance of the trauma cubicle treatment distribution (Lognormal)\n\n    arrival_rate: float\n        Set the mean of the exponential distribution that is used to sample the\n        inter-arrival time of patients\n\n    sim_duration: int\n        The number of time units the simulation will run for\n\n    number_of_runs: int\n        The number of times the simulation will be run with different random number streams\n\n    '''\n    random_number_set = 42\n\n    n_cubicles = 3\n    trauma_treat_mean = 40\n    trauma_treat_var = 5\n\n    arrival_rate = 5\n\n    sim_duration = 600\n    number_of_runs = 100\n\n# Class representing patients coming in to the clinic.\nclass Patient:\n    '''\n    Class defining details for a patient entity\n    '''\n    def __init__(self, p_id):\n        '''\n        Constructor method\n\n        Params:\n        -----\n        identifier: int\n            a numeric identifier for the patient.\n        '''\n        self.identifier = p_id\n        self.arrival = -np.inf\n        self.wait_treat = -np.inf\n        self.total_time = -np.inf\n        self.treat_duration = -np.inf\n\n# Class representing our model of the clinic.\nclass Model:\n    '''\n    Simulates the simplest minor treatment process for a patient\n\n    1. Arrive\n    2. Examined/treated by nurse when one available\n    3. Discharged\n    '''\n    # Constructor to set up the model for a run.  We pass in a run number when\n    # we create a new model.\n    def __init__(self, run_number):\n        # Create a SimPy environment in which everything will live\n        self.env = simpy.Environment()\n\n        self.event_log = []\n\n        # Create a patient counter (which we'll use as a patient ID)\n        self.patient_counter = 0\n\n        self.patients = []\n\n        # Create our resources\n        self.init_resources()\n\n        # Store the passed in run number\n        self.run_number = run_number\n\n        # Create a new Pandas DataFrame that will store some results against\n        # the patient ID (which we'll use as the index).\n        self.results_df = pd.DataFrame()\n        self.results_df[\"Patient ID\"] = [1]\n        self.results_df[\"Queue Time Cubicle\"] = [0.0]\n        self.results_df[\"Time with Nurse\"] = [0.0]\n        self.results_df.set_index(\"Patient ID\", inplace=True)\n\n        # Create an attribute to store the mean queuing times across this run of\n        # the model\n        self.mean_q_time_cubicle = 0\n\n        self.patient_inter_arrival_dist = Exponential(mean = g.arrival_rate,\n                                                      random_seed = self.run_number*g.random_number_set)\n        self.treat_dist = Lognormal(mean = g.trauma_treat_mean,\n                                    stdev = g.trauma_treat_var,\n                                    random_seed = self.run_number*g.random_number_set)\n\n    def init_resources(self):\n        '''\n        Init the number of resources\n        and store in the arguments container object\n\n        Resource list:\n            1. Nurses/treatment bays (same thing in this model)\n\n        '''\n        self.treatment_cubicles = simpy.Store(self.env)\n\n        populate_store(num_resources=g.n_cubicles,\n                       simpy_store=self.treatment_cubicles,\n                       sim_env=self.env)\n\n        # for i in range(g.n_cubicles):\n        #     self.treatment_cubicles.put(\n        #         CustomResource(\n        #             self.env,\n        #             capacity=1,\n        #             id_attribute = i+1)\n        #         )\n\n    # A generator function that represents the DES generator for patient\n    # arrivals\n    def generator_patient_arrivals(self):\n        # We use an infinite loop here to keep doing this indefinitely whilst\n        # the simulation runs\n        while True:\n            # Increment the patient counter by 1 (this means our first patient\n            # will have an ID of 1)\n            self.patient_counter += 1\n\n            # Create a new patient - an instance of the Patient Class we\n            # defined above.  Remember, we pass in the ID when creating a\n            # patient - so here we pass the patient counter to use as the ID.\n            p = Patient(self.patient_counter)\n\n            # Store patient in list for later easy access\n            self.patients.append(p)\n\n            # Tell SimPy to start up the attend_clinic generator function with\n            # this patient (the generator function that will model the\n            # patient's journey through the system)\n            self.env.process(self.attend_clinic(p))\n\n            # Randomly sample the time to the next patient arriving.  Here, we\n            # sample from an exponential distribution (common for inter-arrival\n            # times), and pass in a lambda value of 1 / mean.  The mean\n            # inter-arrival time is stored in the g class.\n            sampled_inter = self.patient_inter_arrival_dist.sample()\n\n            # Freeze this instance of this function in place until the\n            # inter-arrival time we sampled above has elapsed.  Note - time in\n            # SimPy progresses in \"Time Units\", which can represent anything\n            # you like (just make sure you're consistent within the model)\n            yield self.env.timeout(sampled_inter)\n\n    # A generator function that represents the pathway for a patient going\n    # through the clinic.\n    # The patient object is passed in to the generator function so we can\n    # extract information from / record information to it\n    def attend_clinic(self, patient):\n        self.arrival = self.env.now\n        self.event_log.append(\n            {'patient': patient.identifier,\n             'pathway': 'Simplest',\n             'event_type': 'arrival_departure',\n             'event': 'arrival',\n             'time': self.env.now}\n        )\n\n        # request examination resource\n        start_wait = self.env.now\n        self.event_log.append(\n            {'patient': patient.identifier,\n             'pathway': 'Simplest',\n             'event': 'treatment_wait_begins',\n             'event_type': 'queue',\n             'time': self.env.now}\n        )\n\n        # Seize a treatment resource when available\n        treatment_resource = yield self.treatment_cubicles.get()\n\n        # record the waiting time for registration\n        self.wait_treat = self.env.now - start_wait\n        self.event_log.append(\n            {'patient': patient.identifier,\n                'pathway': 'Simplest',\n                'event': 'treatment_begins',\n                'event_type': 'resource_use',\n                'time': self.env.now,\n                'resource_id': treatment_resource.id_attribute\n                }\n        )\n\n        # sample treatment duration\n        self.treat_duration = self.treat_dist.sample()\n        yield self.env.timeout(self.treat_duration)\n\n        self.event_log.append(\n            {'patient': patient.identifier,\n                'pathway': 'Simplest',\n                'event': 'treatment_complete',\n                'event_type': 'resource_use_end',\n                'time': self.env.now,\n                'resource_id': treatment_resource.id_attribute}\n        )\n\n        # Resource is no longer in use, so put it back in\n        self.treatment_cubicles.put(treatment_resource)\n\n        # total time in system\n        self.total_time = self.env.now - self.arrival\n        self.event_log.append(\n            {'patient': patient.identifier,\n            'pathway': 'Simplest',\n            'event': 'depart',\n            'event_type': 'arrival_departure',\n            'time': self.env.now}\n        )\n\n\n    # This method calculates results over a single run.  Here we just calculate\n    # a mean, but in real world models you'd probably want to calculate more.\n    def calculate_run_results(self):\n        # Take the mean of the queuing times across patients in this run of the\n        # model.\n        self.mean_q_time_cubicle = self.results_df[\"Queue Time Cubicle\"].mean()\n\n    # The run method starts up the DES entity generators, runs the simulation,\n    # and in turns calls anything we need to generate results for the run\n    def run(self):\n        # Start up our DES entity generators that create new patients.  We've\n        # only got one in this model, but we'd need to do this for each one if\n        # we had multiple generators.\n        self.env.process(self.generator_patient_arrivals())\n\n        # Run the model for the duration specified in g class\n        self.env.run(until=g.sim_duration)\n\n        # Now the simulation run has finished, call the method that calculates\n        # run results\n        self.calculate_run_results()\n\n        self.event_log = pd.DataFrame(self.event_log)\n\n        self.event_log[\"run\"] = self.run_number\n\n        return {'results': self.results_df, 'event_log': self.event_log}\n\n# Class representing a Trial for our simulation - a batch of simulation runs.\nclass Trial:\n    # The constructor sets up a pandas dataframe that will store the key\n    # results from each run against run number, with run number as the index.\n    def  __init__(self):\n        self.df_trial_results = pd.DataFrame()\n        self.df_trial_results[\"Run Number\"] = [0]\n        self.df_trial_results[\"Arrivals\"] = [0]\n        self.df_trial_results[\"Mean Queue Time Cubicle\"] = [0.0]\n        self.df_trial_results.set_index(\"Run Number\", inplace=True)\n\n        self.all_event_logs = []\n\n    # Method to run a trial\n    def run_trial(self):\n        print(f\"{g.n_cubicles} nurses\")\n        print(\"\") ## Print a blank line\n\n        # Run the simulation for the number of runs specified in g class.\n        # For each run, we create a new instance of the Model class and call its\n        # run method, which sets everything else in motion.  Once the run has\n        # completed, we grab out the stored run results (just mean queuing time\n        # here) and store it against the run number in the trial results\n        # dataframe.\n        for run in range(g.number_of_runs):\n            random.seed(run)\n\n            my_model = Model(run)\n            model_outputs = my_model.run()\n            patient_level_results = model_outputs[\"results\"]\n            event_log = model_outputs[\"event_log\"]\n\n            self.df_trial_results.loc[run] = [\n                len(patient_level_results),\n                my_model.mean_q_time_cubicle,\n            ]\n\n            # print(event_log)\n\n            self.all_event_logs.append(event_log)\n\n        self.all_event_logs = pd.concat(self.all_event_logs)\n\n\n\n\n\nmy_trial = Trial()\n\nmy_trial.run_trial()\n\nsingle_run_event_log_df = my_trial.all_event_logs[my_trial.all_event_logs['run']==1]\n\nanimate_activity_log(\n        event_log=single_run_event_log_df,\n        event_position_df= event_position_df,\n        scenario=g(), # Use an instance of the g class as our scenario\n        entity_col_name=\"patient\",\n        limit_duration=g.sim_duration,\n        debug_mode=True, # Turn on logging messages\n        setup_mode=True, # Turn on axis units - this can help with honing your event_position_df\n        every_x_time_units=1,\n        include_play_button=True,\n        entity_icon_size=20,\n        resource_icon_size=20,\n        gap_between_entities=6,\n        gap_between_queue_rows=25,\n        plotly_height=700,\n        frame_duration=200,\n        plotly_width=1200,\n        override_x_max=300,\n        override_y_max=500,\n        wrap_queues_at=25,\n        step_snapshot_max=125,\n        time_display_units=\"dhm\",\n        display_stage_labels=True # display our Label column from our event_position_df\n    )\n\n3 nurses\n\nAnimation function called at 17:21:14\nIteration through time-unit-by-time-unit logs complete 17:21:16\nSnapshot df concatenation complete at 17:21:16\nReshaped animation dataframe finished construction at 17:21:16\nPlacement dataframe finished construction at 17:21:16\nOutput animation generation complete at 17:21:19\nTotal Time Elapsed: 5.42 seconds\n\n\n        \n        \n        \n\n\n                                                    \n\n\nWhen you have finished tweaking the layout, you can further enhance your output.\n\nanimate_activity_log(\n        event_log=single_run_event_log_df,\n        event_position_df= event_position_df,\n        scenario=g(),\n        entity_col_name=\"patient\",\n        limit_duration=g.sim_duration,\n        debug_mode=False, # Turn off logging messages\n        setup_mode=False, # Turn off axis units\n        every_x_time_units=1,\n        include_play_button=True,\n        entity_icon_size=20,\n        resource_icon_size=20,\n        gap_between_entities=6,\n        gap_between_queue_rows=25,\n        plotly_height=700,\n        frame_duration=200,\n        plotly_width=1200,\n        override_x_max=300,\n        override_y_max=500,\n        wrap_queues_at=25,\n        step_snapshot_max=125,\n        time_display_units=\"dhm\",\n        display_stage_labels=False, # hide our Label column from our event_position_df\n        # Add a local or web-hosted image as our background\n        add_background_image=\"https://raw.githubusercontent.com/Bergam0t/vidigi/refs/heads/main/examples/example_1_simplest_case/Simplest%20Model%20Background%20Image%20-%20Horizontal%20Layout.drawio.png\")\n\n                                                    \n\n\nWe can then rerun our animation, passing in different parameters - though make sure to rerun your trial if you do so!\nHere, we will increase the number of cubicles from 3 to 7 and see the impact this has on the queue size.\n\ng.n_cubicles = 7 \n\nmy_trial = Trial()\n\nmy_trial.run_trial()\n\nsingle_run_event_log_df = my_trial.all_event_logs[my_trial.all_event_logs['run']==1]\n\nanimate_activity_log(\n        event_log=single_run_event_log_df,\n        event_position_df= event_position_df,\n        scenario=g(),\n        entity_col_name=\"patient\",\n        limit_duration=g.sim_duration,\n        debug_mode=False, # Turn off logging messages\n        setup_mode=False, # Turn off axis units\n        every_x_time_units=1,\n        include_play_button=True,\n        entity_icon_size=20,\n        resource_icon_size=20,\n        gap_between_entities=6,\n        gap_between_queue_rows=25,\n        plotly_height=700,\n        frame_duration=200,\n        plotly_width=1200,\n        override_x_max=300,\n        override_y_max=500,\n        wrap_queues_at=25,\n        step_snapshot_max=125,\n        time_display_units=\"dhm\",\n        display_stage_labels=False, # hide our Label column from our event_position_df\n        # Add a local or web-hosted image as our background\n        add_background_image=\"https://raw.githubusercontent.com/Bergam0t/vidigi/refs/heads/main/examples/example_1_simplest_case/Simplest%20Model%20Background%20Image%20-%20Horizontal%20Layout.drawio.png\")\n\n7 nurses",
    "crumbs": [
      "Working with older versions of vidigi",
      "Adding Vidigi to a Simple simpy Model (HSMA Structure) - vidigi 0.0.4 and below"
    ]
  },
  {
    "objectID": "reference/utils.VidigiStore.html",
    "href": "reference/utils.VidigiStore.html",
    "title": "utils.VidigiStore",
    "section": "",
    "text": "utils.VidigiStore(self, env, capacity=float('inf'), init_items=None)\nA wrapper around SimPy’s Store that allows using a context manager pattern similar to resource requests.\nThis allows code like:\nwith store.request() as req: yield req # Use the item that was obtained yield env.timeout(10) # Item is automatically returned when exiting the context\nAI USE DISCLOSURE: This code was generated by Claude 3.7 Sonnet. It has been evaluated and tested by a human.\n\n\n\n\n\nName\nDescription\n\n\n\n\ncapacity\nGet the capacity of the store\n\n\nitems\nGet all items currently in the store\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nget\nAlias for request() to maintain compatibility with both patterns.\n\n\nget_direct\nGet an item from the store without the context manager.\n\n\nput\nPut an item into the store.\n\n\nrequest\nRequest context manager for getting an item from the store.\n\n\nrequest_direct\nAlias for get_direct() to maintain consistent API with SimPy resources.\n\n\n\n\n\nutils.VidigiStore.get()\nAlias for request() to maintain compatibility with both patterns.\nReturns: A context manager for getting an item\n\n\n\nutils.VidigiStore.get_direct()\nGet an item from the store without the context manager. Use this if you don’t want to automatically return the item.\nReturns: A get event that can be yielded\n\n\n\nutils.VidigiStore.put(item)\nPut an item into the store.\nArgs: item: The item to put in the store\n\n\n\nutils.VidigiStore.request()\nRequest context manager for getting an item from the store. The item is automatically returned when exiting the context.\nUsage: with store.request() as req: yield req # This yields the get event # Now we have the item from the store yield env.timeout(10) # Item is automatically returned when exiting the context\nReturns: A context manager that returns the get event and handles returning the item\n\n\n\nutils.VidigiStore.request_direct()\nAlias for get_direct() to maintain consistent API with SimPy resources.\nReturns: A get event that can be yielded"
  },
  {
    "objectID": "reference/utils.VidigiStore.html#attributes",
    "href": "reference/utils.VidigiStore.html#attributes",
    "title": "utils.VidigiStore",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\ncapacity\nGet the capacity of the store\n\n\nitems\nGet all items currently in the store"
  },
  {
    "objectID": "reference/utils.VidigiStore.html#methods",
    "href": "reference/utils.VidigiStore.html#methods",
    "title": "utils.VidigiStore",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nget\nAlias for request() to maintain compatibility with both patterns.\n\n\nget_direct\nGet an item from the store without the context manager.\n\n\nput\nPut an item into the store.\n\n\nrequest\nRequest context manager for getting an item from the store.\n\n\nrequest_direct\nAlias for get_direct() to maintain consistent API with SimPy resources.\n\n\n\n\n\nutils.VidigiStore.get()\nAlias for request() to maintain compatibility with both patterns.\nReturns: A context manager for getting an item\n\n\n\nutils.VidigiStore.get_direct()\nGet an item from the store without the context manager. Use this if you don’t want to automatically return the item.\nReturns: A get event that can be yielded\n\n\n\nutils.VidigiStore.put(item)\nPut an item into the store.\nArgs: item: The item to put in the store\n\n\n\nutils.VidigiStore.request()\nRequest context manager for getting an item from the store. The item is automatically returned when exiting the context.\nUsage: with store.request() as req: yield req # This yields the get event # Now we have the item from the store yield env.timeout(10) # Item is automatically returned when exiting the context\nReturns: A context manager that returns the get event and handles returning the item\n\n\n\nutils.VidigiStore.request_direct()\nAlias for get_direct() to maintain consistent API with SimPy resources.\nReturns: A get event that can be yielded"
  },
  {
    "objectID": "reference/utils.VidigiPriorityStore.html",
    "href": "reference/utils.VidigiPriorityStore.html",
    "title": "utils.VidigiPriorityStore",
    "section": "",
    "text": "utils.VidigiPriorityStore(self, env, capacity=float('inf'), init_items=None)\nAn optimized SimPy priority store that eliminates delays between resource release and acquisition by directly triggering waiting events.\nThis implementation provides the same API as the original VidigiPriorityStore but with immediate resource handoff between processes.\nAI USE DISCLOSURE: This code was generated by Claude 3.7 Sonnet. It has been evaluated and tested by a human.\n\n\n\n\n\nName\nDescription\n\n\n\n\nget\nCreate an event to get an item from the store.\n\n\nget_direct\nGet an item from the store without the context manager.\n\n\nput\nPut an item into the store.\n\n\nrequest\nRequest context manager for getting an item from the store.\n\n\nrequest_direct\nAlias for get_direct() to maintain consistent API.\n\n\nreturn_item\nReturn an item to the store and immediately process any waiting get requests.\n\n\n\n\n\nutils.VidigiPriorityStore.get(priority=0)\nCreate an event to get an item from the store.\nArgs: priority: Lower values indicate higher priority (default: 0)\nReturns: A get event that can be yielded\n\n\n\nutils.VidigiPriorityStore.get_direct(priority=0)\nGet an item from the store without the context manager. Use this if you don’t want to automatically return the item.\nReturns: A get event that can be yielded\n\n\n\nutils.VidigiPriorityStore.put(item)\nPut an item into the store.\nArgs: item: The item to put in the store\nReturns: A put event that can be yielded\n\n\n\nutils.VidigiPriorityStore.request(priority=0)\nRequest context manager for getting an item from the store. The item is automatically returned when exiting the context.\nArgs: priority: Lower values indicate higher priority (default: 0)\nReturns: A context manager that yields the get event and handles item return\n\n\n\nutils.VidigiPriorityStore.request_direct(priority=0)\nAlias for get_direct() to maintain consistent API.\nReturns: A get event that can be yielded\n\n\n\nutils.VidigiPriorityStore.return_item(item)\nReturn an item to the store and immediately process any waiting get requests.\nThis is the key to eliminating delays - it directly triggers waiting get requests without going through the normal put/get mechanism.\nArgs: item: The item to return to the store"
  },
  {
    "objectID": "reference/utils.VidigiPriorityStore.html#methods",
    "href": "reference/utils.VidigiPriorityStore.html#methods",
    "title": "utils.VidigiPriorityStore",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nget\nCreate an event to get an item from the store.\n\n\nget_direct\nGet an item from the store without the context manager.\n\n\nput\nPut an item into the store.\n\n\nrequest\nRequest context manager for getting an item from the store.\n\n\nrequest_direct\nAlias for get_direct() to maintain consistent API.\n\n\nreturn_item\nReturn an item to the store and immediately process any waiting get requests.\n\n\n\n\n\nutils.VidigiPriorityStore.get(priority=0)\nCreate an event to get an item from the store.\nArgs: priority: Lower values indicate higher priority (default: 0)\nReturns: A get event that can be yielded\n\n\n\nutils.VidigiPriorityStore.get_direct(priority=0)\nGet an item from the store without the context manager. Use this if you don’t want to automatically return the item.\nReturns: A get event that can be yielded\n\n\n\nutils.VidigiPriorityStore.put(item)\nPut an item into the store.\nArgs: item: The item to put in the store\nReturns: A put event that can be yielded\n\n\n\nutils.VidigiPriorityStore.request(priority=0)\nRequest context manager for getting an item from the store. The item is automatically returned when exiting the context.\nArgs: priority: Lower values indicate higher priority (default: 0)\nReturns: A context manager that yields the get event and handles item return\n\n\n\nutils.VidigiPriorityStore.request_direct(priority=0)\nAlias for get_direct() to maintain consistent API.\nReturns: A get event that can be yielded\n\n\n\nutils.VidigiPriorityStore.return_item(item)\nReturn an item to the store and immediately process any waiting get requests.\nThis is the key to eliminating delays - it directly triggers waiting get requests without going through the normal put/get mechanism.\nArgs: item: The item to return to the store"
  },
  {
    "objectID": "reference/utils.populate_store.html",
    "href": "reference/utils.populate_store.html",
    "title": "utils.populate_store",
    "section": "",
    "text": "utils.populate_store(num_resources, simpy_store, sim_env)\nPopulate a SimPy Store (or VidigiPriorityStore) with CustomResource objects.\nThis function creates a specified number of CustomResource objects and adds them to a SimPy Store, a VidigiStore, or VidigiPriorityStore.\nEach CustomResource is initialized with a capacity of 1 and a unique ID attribute, which is crucial for animation functions where you wish to show an individual entity consistently using the same resource.\nIf using VidigiPriorityStore, you will need to pass the relevant priority in to the .get() argument when pulling a resource out of the store.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nnum_resources\nint\nThe number of CustomResource objects to create and add to the store.\nrequired\n\n\nsimpy_store\nsimpy.Store or vidigi.utils.VidigiPriorityStore\nThe SimPy Store object to populate with resources.\nrequired\n\n\nsim_env\nsimpy.Environment\nThe SimPy environment in which the resources and store exist.\nrequired\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nNone\n\n\n\n\n\n\n\n\nEach CustomResource is created with a capacity of 1.\nThe ID attribute of each CustomResource is set to its index in the creation loop plus one, ensuring unique IDs starting from 1.\nThis function is typically used to initialize a pool of resources at the start of a simulation.\n\n\n\n\n&gt;&gt;&gt; import simpy\n&gt;&gt;&gt; env = simpy.Environment()\n&gt;&gt;&gt; resource_store = simpy.Store(env)\n&gt;&gt;&gt; populate_store(5, resource_store, env)\n&gt;&gt;&gt; len(resource_store.items)  # The store now contains 5 CustomResource objects\n5"
  },
  {
    "objectID": "reference/utils.populate_store.html#parameters",
    "href": "reference/utils.populate_store.html#parameters",
    "title": "utils.populate_store",
    "section": "",
    "text": "Name\nType\nDescription\nDefault\n\n\n\n\nnum_resources\nint\nThe number of CustomResource objects to create and add to the store.\nrequired\n\n\nsimpy_store\nsimpy.Store or vidigi.utils.VidigiPriorityStore\nThe SimPy Store object to populate with resources.\nrequired\n\n\nsim_env\nsimpy.Environment\nThe SimPy environment in which the resources and store exist.\nrequired"
  },
  {
    "objectID": "reference/utils.populate_store.html#returns",
    "href": "reference/utils.populate_store.html#returns",
    "title": "utils.populate_store",
    "section": "",
    "text": "Name\nType\nDescription\n\n\n\n\n\nNone"
  },
  {
    "objectID": "reference/utils.populate_store.html#notes",
    "href": "reference/utils.populate_store.html#notes",
    "title": "utils.populate_store",
    "section": "",
    "text": "Each CustomResource is created with a capacity of 1.\nThe ID attribute of each CustomResource is set to its index in the creation loop plus one, ensuring unique IDs starting from 1.\nThis function is typically used to initialize a pool of resources at the start of a simulation."
  },
  {
    "objectID": "reference/utils.populate_store.html#examples",
    "href": "reference/utils.populate_store.html#examples",
    "title": "utils.populate_store",
    "section": "",
    "text": "&gt;&gt;&gt; import simpy\n&gt;&gt;&gt; env = simpy.Environment()\n&gt;&gt;&gt; resource_store = simpy.Store(env)\n&gt;&gt;&gt; populate_store(5, resource_store, env)\n&gt;&gt;&gt; len(resource_store.items)  # The store now contains 5 CustomResource objects\n5"
  },
  {
    "objectID": "reference/utils.EventLogger.html",
    "href": "reference/utils.EventLogger.html",
    "title": "utils.EventLogger",
    "section": "",
    "text": "utils.EventLogger(self, event_model=BaseEvent, env=None)\n\n\n\n\n\nName\nDescription\n\n\n\n\nget_events_by_entity\nReturn all events associated with a specific entity_id.\n\n\nget_events_by_type\nReturn all events of a specific event_type.\n\n\nto_csv\nWrite the log to a CSV file.\n\n\nto_dataframe\nConvert the event log to a pandas DataFrame.\n\n\nto_json\nWrite the event log to a JSON file or file-like buffer.\n\n\nto_json_string\nReturn the event log as a pretty JSON string.\n\n\n\n\n\nutils.EventLogger.get_events_by_entity(entity_id, as_dataframe=True)\nReturn all events associated with a specific entity_id.\n\n\n\nutils.EventLogger.get_events_by_type(event_type, as_dataframe=True)\nReturn all events of a specific event_type.\n\n\n\nutils.EventLogger.to_csv(path_or_buffer)\nWrite the log to a CSV file.\n\n\n\nutils.EventLogger.to_dataframe()\nConvert the event log to a pandas DataFrame.\n\n\n\nutils.EventLogger.to_json(path_or_buffer, indent=2)\nWrite the event log to a JSON file or file-like buffer.\n\n\n\nutils.EventLogger.to_json_string(indent=2)\nReturn the event log as a pretty JSON string."
  },
  {
    "objectID": "reference/utils.EventLogger.html#methods",
    "href": "reference/utils.EventLogger.html#methods",
    "title": "utils.EventLogger",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nget_events_by_entity\nReturn all events associated with a specific entity_id.\n\n\nget_events_by_type\nReturn all events of a specific event_type.\n\n\nto_csv\nWrite the log to a CSV file.\n\n\nto_dataframe\nConvert the event log to a pandas DataFrame.\n\n\nto_json\nWrite the event log to a JSON file or file-like buffer.\n\n\nto_json_string\nReturn the event log as a pretty JSON string.\n\n\n\n\n\nutils.EventLogger.get_events_by_entity(entity_id, as_dataframe=True)\nReturn all events associated with a specific entity_id.\n\n\n\nutils.EventLogger.get_events_by_type(event_type, as_dataframe=True)\nReturn all events of a specific event_type.\n\n\n\nutils.EventLogger.to_csv(path_or_buffer)\nWrite the log to a CSV file.\n\n\n\nutils.EventLogger.to_dataframe()\nConvert the event log to a pandas DataFrame.\n\n\n\nutils.EventLogger.to_json(path_or_buffer, indent=2)\nWrite the event log to a JSON file or file-like buffer.\n\n\n\nutils.EventLogger.to_json_string(indent=2)\nReturn the event log as a pretty JSON string."
  },
  {
    "objectID": "reference/resources.VidigiStore.html",
    "href": "reference/resources.VidigiStore.html",
    "title": "resources.VidigiStore",
    "section": "",
    "text": "resources.VidigiStore(self, env, capacity=float('inf'), num_resources=None)\nA wrapper around SimPy’s Store that allows using a context manager pattern similar to resource requests.\nThis allows code like:\nwith store.request() as req: yield req # Use the item that was obtained yield env.timeout(10) # Item is automatically returned when exiting the context\nAI USE DISCLOSURE: This code was generated by Claude 3.7 Sonnet. It has been evaluated and tested by a human.\n\n\n\n\n\nName\nDescription\n\n\n\n\ncapacity\nGet the capacity of the store\n\n\nitems\nGet all items currently in the store\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nget\nAlias for request() to maintain compatibility with both patterns.\n\n\nget_direct\nGet an item from the store without the context manager.\n\n\npopulate\nPopulate this VidigiStore with VidigiResource objects.\n\n\nput\nPut an item into the store.\n\n\nrequest\nRequest context manager for getting an item from the store.\n\n\nrequest_direct\nAlias for get_direct() to maintain consistent API with SimPy resources.\n\n\n\n\n\nresources.VidigiStore.get()\nAlias for request() to maintain compatibility with both patterns.\nReturns: A context manager for getting an item\n\n\n\nresources.VidigiStore.get_direct()\nGet an item from the store without the context manager. Use this if you don’t want to automatically return the item.\nReturns: A get event that can be yielded\n\n\n\nresources.VidigiStore.populate(num_resources)\nPopulate this VidigiStore with VidigiResource objects.\nCreates num_resources VidigiResource objects and adds them to this store.\nEach VidigiResource is initialized with a capacity of 1 and a unique ID starting at 1.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nnum_resources\nint\nThe number of VidigiResource objects to create and add to the store.\nrequired\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nNone\n\n\n\n\n\n\n\n\nresources.VidigiStore.put(item)\nPut an item into the store.\nArgs: item: The item to put in the store\n\n\n\nresources.VidigiStore.request()\nRequest context manager for getting an item from the store. The item is automatically returned when exiting the context.\nUsage: with store.request() as req: yield req # This yields the get event # Now we have the item from the store yield env.timeout(10) # Item is automatically returned when exiting the context\nReturns: A context manager that returns the get event and handles returning the item\n\n\n\nresources.VidigiStore.request_direct()\nAlias for get_direct() to maintain consistent API with SimPy resources.\nReturns: A get event that can be yielded",
    "crumbs": [
      "vidigi Function Reference",
      "Simpy Resource Classes",
      "resources.VidigiStore"
    ]
  },
  {
    "objectID": "reference/resources.VidigiStore.html#attributes",
    "href": "reference/resources.VidigiStore.html#attributes",
    "title": "resources.VidigiStore",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\ncapacity\nGet the capacity of the store\n\n\nitems\nGet all items currently in the store",
    "crumbs": [
      "vidigi Function Reference",
      "Simpy Resource Classes",
      "resources.VidigiStore"
    ]
  },
  {
    "objectID": "reference/resources.VidigiStore.html#methods",
    "href": "reference/resources.VidigiStore.html#methods",
    "title": "resources.VidigiStore",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nget\nAlias for request() to maintain compatibility with both patterns.\n\n\nget_direct\nGet an item from the store without the context manager.\n\n\npopulate\nPopulate this VidigiStore with VidigiResource objects.\n\n\nput\nPut an item into the store.\n\n\nrequest\nRequest context manager for getting an item from the store.\n\n\nrequest_direct\nAlias for get_direct() to maintain consistent API with SimPy resources.\n\n\n\n\n\nresources.VidigiStore.get()\nAlias for request() to maintain compatibility with both patterns.\nReturns: A context manager for getting an item\n\n\n\nresources.VidigiStore.get_direct()\nGet an item from the store without the context manager. Use this if you don’t want to automatically return the item.\nReturns: A get event that can be yielded\n\n\n\nresources.VidigiStore.populate(num_resources)\nPopulate this VidigiStore with VidigiResource objects.\nCreates num_resources VidigiResource objects and adds them to this store.\nEach VidigiResource is initialized with a capacity of 1 and a unique ID starting at 1.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nnum_resources\nint\nThe number of VidigiResource objects to create and add to the store.\nrequired\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nNone\n\n\n\n\n\n\n\n\nresources.VidigiStore.put(item)\nPut an item into the store.\nArgs: item: The item to put in the store\n\n\n\nresources.VidigiStore.request()\nRequest context manager for getting an item from the store. The item is automatically returned when exiting the context.\nUsage: with store.request() as req: yield req # This yields the get event # Now we have the item from the store yield env.timeout(10) # Item is automatically returned when exiting the context\nReturns: A context manager that returns the get event and handles returning the item\n\n\n\nresources.VidigiStore.request_direct()\nAlias for get_direct() to maintain consistent API with SimPy resources.\nReturns: A get event that can be yielded",
    "crumbs": [
      "vidigi Function Reference",
      "Simpy Resource Classes",
      "resources.VidigiStore"
    ]
  },
  {
    "objectID": "reference/resources.VidigiPriorityStoreLegacy.html",
    "href": "reference/resources.VidigiPriorityStoreLegacy.html",
    "title": "resources.VidigiPriorityStoreLegacy",
    "section": "",
    "text": "resources.VidigiPriorityStoreLegacy()\nA SimPy store that processes requests with priority.\nThis class extends the SimPy Store to include a priority queue for handling requests. Requests are processed based on their priority, submission time, and preemption flag.\nAttributes: GetQueue (class): A reference to the sorted queue implementation used for handling prioritized requests. get (class): A reference to the PriorityGet class, which handles the creation of prioritized requests.\n\n\nCredit to arabinelli # https://stackoverflow.com/questions/58603000/how-do-i-make-a-priority-get-request-from-resource-store",
    "crumbs": [
      "vidigi Function Reference",
      "legacy Functions",
      "resources.VidigiPriorityStoreLegacy"
    ]
  },
  {
    "objectID": "reference/resources.VidigiPriorityStoreLegacy.html#notes",
    "href": "reference/resources.VidigiPriorityStoreLegacy.html#notes",
    "title": "resources.VidigiPriorityStoreLegacy",
    "section": "",
    "text": "Credit to arabinelli # https://stackoverflow.com/questions/58603000/how-do-i-make-a-priority-get-request-from-resource-store",
    "crumbs": [
      "vidigi Function Reference",
      "legacy Functions",
      "resources.VidigiPriorityStoreLegacy"
    ]
  },
  {
    "objectID": "reference/resources.populate_store.html",
    "href": "reference/resources.populate_store.html",
    "title": "resources.populate_store",
    "section": "",
    "text": "resources.populate_store(num_resources, simpy_store, sim_env)\nPopulate a SimPy Store (or VidigiPriorityStore) with VidigiResource objects.\nThis function creates a specified number of VidigiResource objects and adds them to a SimPy Store, a VidigiStore, or VidigiPriorityStore.\nEach VidigiResource is initialized with a capacity of 1 and a unique ID attribute, which is crucial for animation functions where you wish to show an individual entity consistently using the same resource.\nIf using VidigiPriorityStore, you will need to pass the relevant priority in to the .get() argument when pulling a resource out of the store.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nnum_resources\nint\nThe number of VidigiResource objects to create and add to the store.\nrequired\n\n\nsimpy_store\n(simpy.Store, vidigi.resources.VidigiStore or vidigi.resources.VidigiPriorityStore)\nThe SimPy Store object to populate with resources.\nrequired\n\n\nsim_env\nsimpy.Environment\nThe SimPy environment in which the resources and store exist.\nrequired\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nNone\n\n\n\n\n\n\n\n\nEach VidigiResource is created with a capacity of 1.\nThe ID attribute of each VidigiResource is set to its index in the creation loop plus one, ensuring unique IDs starting from 1.\nThis function is typically used to initialize a pool of resources at the start of a simulation.\n\n\n\n\n&gt;&gt;&gt; import simpy\n&gt;&gt;&gt; env = simpy.Environment()\n&gt;&gt;&gt; resource_store = simpy.Store(env)\n&gt;&gt;&gt; populate_store(5, resource_store, env)\n&gt;&gt;&gt; len(resource_store.items)  # The store now contains 5 VidigiResource objects\n5",
    "crumbs": [
      "vidigi Function Reference",
      "Simpy Resource Classes",
      "resources.populate_store"
    ]
  },
  {
    "objectID": "reference/resources.populate_store.html#parameters",
    "href": "reference/resources.populate_store.html#parameters",
    "title": "resources.populate_store",
    "section": "",
    "text": "Name\nType\nDescription\nDefault\n\n\n\n\nnum_resources\nint\nThe number of VidigiResource objects to create and add to the store.\nrequired\n\n\nsimpy_store\n(simpy.Store, vidigi.resources.VidigiStore or vidigi.resources.VidigiPriorityStore)\nThe SimPy Store object to populate with resources.\nrequired\n\n\nsim_env\nsimpy.Environment\nThe SimPy environment in which the resources and store exist.\nrequired",
    "crumbs": [
      "vidigi Function Reference",
      "Simpy Resource Classes",
      "resources.populate_store"
    ]
  },
  {
    "objectID": "reference/resources.populate_store.html#returns",
    "href": "reference/resources.populate_store.html#returns",
    "title": "resources.populate_store",
    "section": "",
    "text": "Name\nType\nDescription\n\n\n\n\n\nNone",
    "crumbs": [
      "vidigi Function Reference",
      "Simpy Resource Classes",
      "resources.populate_store"
    ]
  },
  {
    "objectID": "reference/resources.populate_store.html#notes",
    "href": "reference/resources.populate_store.html#notes",
    "title": "resources.populate_store",
    "section": "",
    "text": "Each VidigiResource is created with a capacity of 1.\nThe ID attribute of each VidigiResource is set to its index in the creation loop plus one, ensuring unique IDs starting from 1.\nThis function is typically used to initialize a pool of resources at the start of a simulation.",
    "crumbs": [
      "vidigi Function Reference",
      "Simpy Resource Classes",
      "resources.populate_store"
    ]
  },
  {
    "objectID": "reference/resources.populate_store.html#examples",
    "href": "reference/resources.populate_store.html#examples",
    "title": "resources.populate_store",
    "section": "",
    "text": "&gt;&gt;&gt; import simpy\n&gt;&gt;&gt; env = simpy.Environment()\n&gt;&gt;&gt; resource_store = simpy.Store(env)\n&gt;&gt;&gt; populate_store(5, resource_store, env)\n&gt;&gt;&gt; len(resource_store.items)  # The store now contains 5 VidigiResource objects\n5",
    "crumbs": [
      "vidigi Function Reference",
      "Simpy Resource Classes",
      "resources.populate_store"
    ]
  },
  {
    "objectID": "reference/prep.generate_animation_df.html",
    "href": "reference/prep.generate_animation_df.html",
    "title": "prep.generate_animation_df",
    "section": "",
    "text": "prep.generate_animation_df(\n    full_entity_df,\n    event_position_df,\n    wrap_queues_at=20,\n    wrap_resources_at=20,\n    step_snapshot_max=50,\n    gap_between_entities=10,\n    gap_between_resources=10,\n    gap_between_resource_rows=30,\n    gap_between_queue_rows=30,\n    time_col_name='time',\n    entity_col_name='entity_id',\n    event_type_col_name='event_type',\n    event_col_name='event',\n    debug_mode=False,\n    custom_entity_icon_list=None,\n    include_fun_emojis=False,\n)\nGenerate a DataFrame for animation purposes by adding position information to entity data.\nThis function takes entity event data and adds positional information for visualization, handling both queuing and resource use events.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nfull_entity_df\npd.DataFrame\nOutput of reshape_for_animation(), containing entity event data.\nrequired\n\n\nevent_position_df\npd.DataFrame\nDataFrame with columns ‘event’, ‘x’, and ‘y’, specifying initial positions for each event type.\nrequired\n\n\nwrap_queues_at\nint\nNumber of entities in a queue before wrapping to a new row (default is 20).\n20\n\n\nwrap_resources_at\nint\nNumber of resources to show before wrapping to a new row (default is 20).\n20\n\n\nstep_snapshot_max\nint\nMaximum number of patients to show in each snapshot (default is 50).\n50\n\n\ngap_between_entities\nint\nHorizontal spacing between entities in pixels (default is 10).\n10\n\n\ngap_between_resources\nint\nHorizontal spacing between resources in pixels (default is 10).\n10\n\n\ngap_between_queue_rows\nint\nVertical spacing between rows in pixels (default is 30).\n30\n\n\ngap_between_resource_rows\nint\nVertical spacing between rows in pixels (default is 30).\n30\n\n\ntime_col_name\nstr\nName of the column in event_log that contains the timestamp of each event. Timestamps should represent the number of time units since the simulation began.\n\"time\"\n\n\nentity_col_name\nstr\nName of the column in event_log that contains the unique identifier for each entity (e.g., “entity_id”, “entity”, “patient”, “patient_id”, “customer”, “ID”).\n\"entity_id\"\n\n\nevent_type_col_name\nstr\nName of the column in event_log that specifies the category of the event. Supported event types include ‘arrival_departure’, ‘resource_use’, ‘resource_use_end’, and ‘queue’.\n\"event_type\"\n\n\nevent_col_name\nstr\nName of the column in event_log that specifies the actual event that occurred.\n\"event\"\n\n\ndebug_mode\nbool\nIf True, print debug information during processing (default is False).\nFalse\n\n\ncustom_entity_icon_list\nlist\nIf provided, will be used as the list for entity icons. Once the end of the list is reached, it will loop back around to the beginning (so e.g. if a list of 8 icons is provided, entities 1 to 8 will use the provided emoji list, and then entity 9 will use the same icon as entity 1, and so on.)\nNone\n\n\ninclude_fun_emojis\nbool\nIf True, include the more ‘fun’ emojis, such as Santa Claus. Ignored if a custom entity icon list is passed.\nFalse\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\npd.DataFrame\nA DataFrame with added columns for x and y positions, and icons for each entity.\n\n\n\n\n\n\n\nThe function handles both queuing and resource use events differently.\nIt assigns unique icons to entities for visualization.\nQueues can be wrapped to multiple rows if they exceed a specified length.\nThe function adds a visual indicator for additional entities when exceeding the snapshot limit.\n\n\n\n\n\nWrite a test to ensure that no entity ID appears in multiple places at a single time unit.",
    "crumbs": [
      "vidigi Function Reference",
      "Step-By-Step Functions",
      "prep.generate_animation_df"
    ]
  },
  {
    "objectID": "reference/prep.generate_animation_df.html#parameters",
    "href": "reference/prep.generate_animation_df.html#parameters",
    "title": "prep.generate_animation_df",
    "section": "",
    "text": "Name\nType\nDescription\nDefault\n\n\n\n\nfull_entity_df\npd.DataFrame\nOutput of reshape_for_animation(), containing entity event data.\nrequired\n\n\nevent_position_df\npd.DataFrame\nDataFrame with columns ‘event’, ‘x’, and ‘y’, specifying initial positions for each event type.\nrequired\n\n\nwrap_queues_at\nint\nNumber of entities in a queue before wrapping to a new row (default is 20).\n20\n\n\nwrap_resources_at\nint\nNumber of resources to show before wrapping to a new row (default is 20).\n20\n\n\nstep_snapshot_max\nint\nMaximum number of patients to show in each snapshot (default is 50).\n50\n\n\ngap_between_entities\nint\nHorizontal spacing between entities in pixels (default is 10).\n10\n\n\ngap_between_resources\nint\nHorizontal spacing between resources in pixels (default is 10).\n10\n\n\ngap_between_queue_rows\nint\nVertical spacing between rows in pixels (default is 30).\n30\n\n\ngap_between_resource_rows\nint\nVertical spacing between rows in pixels (default is 30).\n30\n\n\ntime_col_name\nstr\nName of the column in event_log that contains the timestamp of each event. Timestamps should represent the number of time units since the simulation began.\n\"time\"\n\n\nentity_col_name\nstr\nName of the column in event_log that contains the unique identifier for each entity (e.g., “entity_id”, “entity”, “patient”, “patient_id”, “customer”, “ID”).\n\"entity_id\"\n\n\nevent_type_col_name\nstr\nName of the column in event_log that specifies the category of the event. Supported event types include ‘arrival_departure’, ‘resource_use’, ‘resource_use_end’, and ‘queue’.\n\"event_type\"\n\n\nevent_col_name\nstr\nName of the column in event_log that specifies the actual event that occurred.\n\"event\"\n\n\ndebug_mode\nbool\nIf True, print debug information during processing (default is False).\nFalse\n\n\ncustom_entity_icon_list\nlist\nIf provided, will be used as the list for entity icons. Once the end of the list is reached, it will loop back around to the beginning (so e.g. if a list of 8 icons is provided, entities 1 to 8 will use the provided emoji list, and then entity 9 will use the same icon as entity 1, and so on.)\nNone\n\n\ninclude_fun_emojis\nbool\nIf True, include the more ‘fun’ emojis, such as Santa Claus. Ignored if a custom entity icon list is passed.\nFalse",
    "crumbs": [
      "vidigi Function Reference",
      "Step-By-Step Functions",
      "prep.generate_animation_df"
    ]
  },
  {
    "objectID": "reference/prep.generate_animation_df.html#returns",
    "href": "reference/prep.generate_animation_df.html#returns",
    "title": "prep.generate_animation_df",
    "section": "",
    "text": "Name\nType\nDescription\n\n\n\n\n\npd.DataFrame\nA DataFrame with added columns for x and y positions, and icons for each entity.",
    "crumbs": [
      "vidigi Function Reference",
      "Step-By-Step Functions",
      "prep.generate_animation_df"
    ]
  },
  {
    "objectID": "reference/prep.generate_animation_df.html#notes",
    "href": "reference/prep.generate_animation_df.html#notes",
    "title": "prep.generate_animation_df",
    "section": "",
    "text": "The function handles both queuing and resource use events differently.\nIt assigns unique icons to entities for visualization.\nQueues can be wrapped to multiple rows if they exceed a specified length.\nThe function adds a visual indicator for additional entities when exceeding the snapshot limit.",
    "crumbs": [
      "vidigi Function Reference",
      "Step-By-Step Functions",
      "prep.generate_animation_df"
    ]
  },
  {
    "objectID": "reference/prep.generate_animation_df.html#todo",
    "href": "reference/prep.generate_animation_df.html#todo",
    "title": "prep.generate_animation_df",
    "section": "",
    "text": "Write a test to ensure that no entity ID appears in multiple places at a single time unit.",
    "crumbs": [
      "vidigi Function Reference",
      "Step-By-Step Functions",
      "prep.generate_animation_df"
    ]
  },
  {
    "objectID": "reference/index.html#all-in-one-animation-functions",
    "href": "reference/index.html#all-in-one-animation-functions",
    "title": "All Functions",
    "section": "All-In-One Animation Functions",
    "text": "All-In-One Animation Functions\n\n\n\nanimation.animate_activity_log\nGenerate an animated visualization of patient flow through a system.",
    "crumbs": [
      "vidigi Function Reference",
      "All Functions"
    ]
  },
  {
    "objectID": "reference/index.html#step-by-step-functions",
    "href": "reference/index.html#step-by-step-functions",
    "title": "All Functions",
    "section": "Step-By-Step Functions",
    "text": "Step-By-Step Functions\n\n\n\nprep.reshape_for_animations\nReshape event log data for animation purposes.\n\n\nprep.generate_animation_df\nGenerate a DataFrame for animation purposes by adding position information to entity data.\n\n\nanimation.generate_animation\nGenerate an animated visualization of patient flow through a system.",
    "crumbs": [
      "vidigi Function Reference",
      "All Functions"
    ]
  },
  {
    "objectID": "reference/index.html#simpy-resource-classes",
    "href": "reference/index.html#simpy-resource-classes",
    "title": "All Functions",
    "section": "Simpy Resource Classes",
    "text": "Simpy Resource Classes\n\n\n\nresources.VidigiResource\nA custom resource class that extends simpy.Resource with an additional ID attribute.\n\n\nresources.VidigiStore\nA wrapper around SimPy’s Store that allows using a context manager pattern\n\n\nresources.VidigiPriorityStore\nAn optimized SimPy priority store that eliminates delays between resource\n\n\nresources.populate_store\nPopulate a SimPy Store (or VidigiPriorityStore) with VidigiResource objects.",
    "crumbs": [
      "vidigi Function Reference",
      "All Functions"
    ]
  },
  {
    "objectID": "reference/index.html#event-logging-utility-functions-and-classes",
    "href": "reference/index.html#event-logging-utility-functions-and-classes",
    "title": "All Functions",
    "section": "Event Logging Utility Functions and Classes",
    "text": "Event Logging Utility Functions and Classes\n\n\n\nlogging.EventLogger",
    "crumbs": [
      "vidigi Function Reference",
      "All Functions"
    ]
  },
  {
    "objectID": "reference/index.html#streamlit-utility-functions",
    "href": "reference/index.html#streamlit-utility-functions",
    "title": "All Functions",
    "section": "Streamlit Utility Functions",
    "text": "Streamlit Utility Functions\n\n\n\nutils.streamlit_play_all",
    "crumbs": [
      "vidigi Function Reference",
      "All Functions"
    ]
  },
  {
    "objectID": "reference/index.html#ciw-utility-functions",
    "href": "reference/index.html#ciw-utility-functions",
    "title": "All Functions",
    "section": "ciw Utility Functions",
    "text": "ciw Utility Functions\n\n\n\nciw.event_log_from_ciw_recs\nGiven the ciw recs object, return a dataframe in the format expected by the vidigi",
    "crumbs": [
      "vidigi Function Reference",
      "All Functions"
    ]
  },
  {
    "objectID": "reference/index.html#legacy-functions",
    "href": "reference/index.html#legacy-functions",
    "title": "All Functions",
    "section": "legacy Functions",
    "text": "legacy Functions\n\n\n\nresources.VidigiPriorityStoreLegacy\nA SimPy store that processes requests with priority.",
    "crumbs": [
      "vidigi Function Reference",
      "All Functions"
    ]
  },
  {
    "objectID": "reference/animation.generate_animation.html",
    "href": "reference/animation.generate_animation.html",
    "title": "animation.generate_animation",
    "section": "",
    "text": "animation.generate_animation(\n    full_entity_df_plus_pos,\n    event_position_df,\n    scenario=None,\n    time_col_name='time',\n    entity_col_name='entity_id',\n    event_col_name='event',\n    resource_col_name='resource_id',\n    pathway_col_name=None,\n    simulation_time_unit='minutes',\n    plotly_height=900,\n    plotly_width=None,\n    include_play_button=True,\n    add_background_image=None,\n    display_stage_labels=True,\n    entity_icon_size=24,\n    text_size=24,\n    resource_icon_size=24,\n    override_x_max=None,\n    override_y_max=None,\n    time_display_units=None,\n    start_date=None,\n    start_time=None,\n    resource_opacity=0.8,\n    custom_resource_icon=None,\n    wrap_resources_at=20,\n    gap_between_resources=10,\n    gap_between_resource_rows=30,\n    setup_mode=False,\n    frame_duration=400,\n    frame_transition_duration=600,\n    debug_mode=False,\n)\nGenerate an animated visualization of patient flow through a system.\n\nThis function creates an interactive Plotly animation based on patient data and event positions.\n\n\nfull_entity_df_plus_pos : pd.DataFrame\n    DataFrame containing entity data with position information.\n    This will be the output of passing an event log through the reshape_for_animations()\n    and generate_animation_df() functions\nevent_position_df : pd.DataFrame\n    DataFrame specifying the positions of different events.\nscenario : object, optional\n    Object containing attributes for resource counts at different steps.\n    time_col_name : str, default=\"time\"\n    Name of the column in `event_log` that contains the timestamp of each event.\n    Timestamps should represent the number of time units since the simulation began.\nentity_col_name : str, default=\"entity_id\"\n    Name of the column in `event_log` that contains the unique identifier for each entity\n    (e.g., \"entity_id\", \"entity\", \"patient\", \"patient_id\", \"customer\", \"ID\").\nevent_col_name : str, default=\"event\"\n    Name of the column in `event_log` that specifies the actual event that occurred.\npathway_col_name : str, optional, default=None\n    Name of the column in `event_log` that identifies the specific pathway or\n    process flow the entity is following. If `None`, it is assumed that pathway\n    information is not present.\nresource_col_name : str, default=\"resource_id\"\n    Name of the column for the resource identifier. Used for 'resource_use' events.\nsimulation_time_unit: string, optional\n    Time unit used within the simulation (default is minutes).\n    Possible values are 'seconds', 'minutes', 'hours', 'days', 'weeks', 'years'\nplotly_height : int, optional\n    Height of the Plotly figure in pixels (default is 900).\nplotly_width : int, optional\n    Width of the Plotly figure in pixels (default is None).\ninclude_play_button : bool, optional\n    Whether to include a play button in the animation (default is True).\nadd_background_image : str, optional\n    Path to a background image file to add to the animation (default is None).\ndisplay_stage_labels : bool, optional\n    Whether to display labels for each stage (default is True).\nentity_icon_size : int, optional\n    Size of entity icons in the animation (default is 24).\ntext_size : int, optional\n    Size of text labels in the animation (default is 24).\nresource_icon_size : int, optional\n    Size of resource icons in the animation (default is 24).\noverride_x_max : int, optional\n    Override the maximum x-coordinate (default is None).\noverride_y_max : int, optional\n    Override the maximum y-coordinate (default is None).\n    time_display_units : str, optional\n    Format for displaying time on the animation timeline. This affects how simulation time is\n    converted into human-readable dates or clock formats. If `None` (default), the raw simulation\n    time is used.\n\n    Predefined options:\n    - 'dhms' : Day Month Year + HH:MM:SS (e.g., \"06 June 2025\n14:23:45”) - ‘dhms_ampm’ : Same as ‘dhms’, but in 12-hour format with AM/PM (e.g., “06 June 2025 02:23:45 PM”) - ‘dhm’ : Day Month Year + HH:MM (e.g., “06 June 2025 14:23”) - ‘dhm_ampm’ : 12-hour format with AM/PM (e.g., “06 June 2025 02:23 PM”) - ‘dh’ : Day Month Year + HH (e.g., “06 June 2025 14”) - ‘dh_ampm’ : 12-hour format with AM/PM (e.g., “06 June 2025 02 PM”) - ‘d’ : Full weekday and date (e.g., “Friday 06 June 2025”) - ‘m’ : Month and year (e.g., “June 2025”) - ‘y’ : Year only (e.g., “2025”) - ‘day_clock’ or ‘simulation_day_clock’: Show simulation-relative day and time (e.g., “Simulation Day 3 14:15”) - ‘day_clock_ampm’ or ‘simulation_day_clock_ampm’: Same as above, but time is shown in 12-hour clock with AM/PM (e.g., “Simulation Day 3 02:15 PM”)\n    Alternatively, you can supply a custom [strftime](https://strftime.org/) format string\n    (e.g., '%Y-%m-%d %H') to control the display manually.\nstart_date : str, optional\n    Start date for the animation in 'YYYY-MM-DD' format. Only used when time_display_units is 'd' or 'dhm' (default is None).\nstart_time : str, optional\n    Start date for the animation in 'HH:MM:SS' format. Only used when time_display_units is 'd' or 'dhm' (default is None).\nresource_opacity : float, optional\n    Opacity of resource icons (default is 0.8).\ncustom_resource_icon : str, optional\n    Custom icon to use for resources (default is None).\nwrap_resources_at : int, optional\n    Number of resources to show before wrapping to a new row (default is 20).\n    If this has been set elsewhere, it is also important to set it in this function to ensure\n    the visual indicators of the resources wrap in the same way the entities using those\n    resources do.\ngap_between_resources : int, optional\n    Spacing between resources in pixels (default is 10).\ngap_between_resource_rows : int, optional\n    Vertical spacing between rows in pixels (default is 30).\nsetup_mode : bool, optional\n    Whether to run in setup mode, showing grid and tick marks (default is False).\nframe_duration : int, optional\n    Duration of each frame in milliseconds (default is 400).\nframe_transition_duration : int, optional\n    Duration of transition between frames in milliseconds (default is 600).\ndebug_mode : bool, optional\n    Whether to run in debug mode with additional output (default is False).\n\n\n\nplotly.graph_objs._figure.Figure\n    An animated Plotly figure object representing the patient flow.\n\n\n\n- The function uses Plotly Express to create an animated scatter plot.\n- Time can be displayed as actual dates or as model time units.\n- The animation supports customization of icon sizes, resource representation, and animation speed.\n- A background image can be added to provide context for the patient flow.\n- If `time_display_units` is specified, the simulation time is converted into real-world\n  datetimes using the `simulation_time_unit` and optionally `start_date` and `start_time`.\n- If `start_date` and/or `start_time` are not provided, a default offset from today's date\n  is used.\n- The `snapshot_time` column is transformed to datetime strings, and a `snapshot_time_display`\n  column is created for visual display.\n\n\n\n&gt;&gt;&gt; animation = generate_animation(patient_df, event_positions, scenario,\n...                                time_display_units='dhm',\n...                                add_background_image='path/to/image.png')\n&gt;&gt;&gt; animation.show()",
    "crumbs": [
      "vidigi Function Reference",
      "Step-By-Step Functions",
      "animation.generate_animation"
    ]
  },
  {
    "objectID": "reference/animation.generate_animation.html#parameters",
    "href": "reference/animation.generate_animation.html#parameters",
    "title": "animation.generate_animation",
    "section": "",
    "text": "full_entity_df_plus_pos : pd.DataFrame\n    DataFrame containing entity data with position information.\n    This will be the output of passing an event log through the reshape_for_animations()\n    and generate_animation_df() functions\nevent_position_df : pd.DataFrame\n    DataFrame specifying the positions of different events.\nscenario : object, optional\n    Object containing attributes for resource counts at different steps.\n    time_col_name : str, default=\"time\"\n    Name of the column in `event_log` that contains the timestamp of each event.\n    Timestamps should represent the number of time units since the simulation began.\nentity_col_name : str, default=\"entity_id\"\n    Name of the column in `event_log` that contains the unique identifier for each entity\n    (e.g., \"entity_id\", \"entity\", \"patient\", \"patient_id\", \"customer\", \"ID\").\nevent_col_name : str, default=\"event\"\n    Name of the column in `event_log` that specifies the actual event that occurred.\npathway_col_name : str, optional, default=None\n    Name of the column in `event_log` that identifies the specific pathway or\n    process flow the entity is following. If `None`, it is assumed that pathway\n    information is not present.\nresource_col_name : str, default=\"resource_id\"\n    Name of the column for the resource identifier. Used for 'resource_use' events.\nsimulation_time_unit: string, optional\n    Time unit used within the simulation (default is minutes).\n    Possible values are 'seconds', 'minutes', 'hours', 'days', 'weeks', 'years'\nplotly_height : int, optional\n    Height of the Plotly figure in pixels (default is 900).\nplotly_width : int, optional\n    Width of the Plotly figure in pixels (default is None).\ninclude_play_button : bool, optional\n    Whether to include a play button in the animation (default is True).\nadd_background_image : str, optional\n    Path to a background image file to add to the animation (default is None).\ndisplay_stage_labels : bool, optional\n    Whether to display labels for each stage (default is True).\nentity_icon_size : int, optional\n    Size of entity icons in the animation (default is 24).\ntext_size : int, optional\n    Size of text labels in the animation (default is 24).\nresource_icon_size : int, optional\n    Size of resource icons in the animation (default is 24).\noverride_x_max : int, optional\n    Override the maximum x-coordinate (default is None).\noverride_y_max : int, optional\n    Override the maximum y-coordinate (default is None).\n    time_display_units : str, optional\n    Format for displaying time on the animation timeline. This affects how simulation time is\n    converted into human-readable dates or clock formats. If `None` (default), the raw simulation\n    time is used.\n\n    Predefined options:\n    - 'dhms' : Day Month Year + HH:MM:SS (e.g., \"06 June 2025\n14:23:45”) - ‘dhms_ampm’ : Same as ‘dhms’, but in 12-hour format with AM/PM (e.g., “06 June 2025 02:23:45 PM”) - ‘dhm’ : Day Month Year + HH:MM (e.g., “06 June 2025 14:23”) - ‘dhm_ampm’ : 12-hour format with AM/PM (e.g., “06 June 2025 02:23 PM”) - ‘dh’ : Day Month Year + HH (e.g., “06 June 2025 14”) - ‘dh_ampm’ : 12-hour format with AM/PM (e.g., “06 June 2025 02 PM”) - ‘d’ : Full weekday and date (e.g., “Friday 06 June 2025”) - ‘m’ : Month and year (e.g., “June 2025”) - ‘y’ : Year only (e.g., “2025”) - ‘day_clock’ or ‘simulation_day_clock’: Show simulation-relative day and time (e.g., “Simulation Day 3 14:15”) - ‘day_clock_ampm’ or ‘simulation_day_clock_ampm’: Same as above, but time is shown in 12-hour clock with AM/PM (e.g., “Simulation Day 3 02:15 PM”)\n    Alternatively, you can supply a custom [strftime](https://strftime.org/) format string\n    (e.g., '%Y-%m-%d %H') to control the display manually.\nstart_date : str, optional\n    Start date for the animation in 'YYYY-MM-DD' format. Only used when time_display_units is 'd' or 'dhm' (default is None).\nstart_time : str, optional\n    Start date for the animation in 'HH:MM:SS' format. Only used when time_display_units is 'd' or 'dhm' (default is None).\nresource_opacity : float, optional\n    Opacity of resource icons (default is 0.8).\ncustom_resource_icon : str, optional\n    Custom icon to use for resources (default is None).\nwrap_resources_at : int, optional\n    Number of resources to show before wrapping to a new row (default is 20).\n    If this has been set elsewhere, it is also important to set it in this function to ensure\n    the visual indicators of the resources wrap in the same way the entities using those\n    resources do.\ngap_between_resources : int, optional\n    Spacing between resources in pixels (default is 10).\ngap_between_resource_rows : int, optional\n    Vertical spacing between rows in pixels (default is 30).\nsetup_mode : bool, optional\n    Whether to run in setup mode, showing grid and tick marks (default is False).\nframe_duration : int, optional\n    Duration of each frame in milliseconds (default is 400).\nframe_transition_duration : int, optional\n    Duration of transition between frames in milliseconds (default is 600).\ndebug_mode : bool, optional\n    Whether to run in debug mode with additional output (default is False).",
    "crumbs": [
      "vidigi Function Reference",
      "Step-By-Step Functions",
      "animation.generate_animation"
    ]
  },
  {
    "objectID": "reference/animation.generate_animation.html#returns",
    "href": "reference/animation.generate_animation.html#returns",
    "title": "animation.generate_animation",
    "section": "",
    "text": "plotly.graph_objs._figure.Figure\n    An animated Plotly figure object representing the patient flow.",
    "crumbs": [
      "vidigi Function Reference",
      "Step-By-Step Functions",
      "animation.generate_animation"
    ]
  },
  {
    "objectID": "reference/animation.generate_animation.html#notes",
    "href": "reference/animation.generate_animation.html#notes",
    "title": "animation.generate_animation",
    "section": "",
    "text": "- The function uses Plotly Express to create an animated scatter plot.\n- Time can be displayed as actual dates or as model time units.\n- The animation supports customization of icon sizes, resource representation, and animation speed.\n- A background image can be added to provide context for the patient flow.\n- If `time_display_units` is specified, the simulation time is converted into real-world\n  datetimes using the `simulation_time_unit` and optionally `start_date` and `start_time`.\n- If `start_date` and/or `start_time` are not provided, a default offset from today's date\n  is used.\n- The `snapshot_time` column is transformed to datetime strings, and a `snapshot_time_display`\n  column is created for visual display.",
    "crumbs": [
      "vidigi Function Reference",
      "Step-By-Step Functions",
      "animation.generate_animation"
    ]
  },
  {
    "objectID": "reference/animation.generate_animation.html#examples",
    "href": "reference/animation.generate_animation.html#examples",
    "title": "animation.generate_animation",
    "section": "",
    "text": "&gt;&gt;&gt; animation = generate_animation(patient_df, event_positions, scenario,\n...                                time_display_units='dhm',\n...                                add_background_image='path/to/image.png')\n&gt;&gt;&gt; animation.show()",
    "crumbs": [
      "vidigi Function Reference",
      "Step-By-Step Functions",
      "animation.generate_animation"
    ]
  },
  {
    "objectID": "notes.html",
    "href": "notes.html",
    "title": "4. Iterating through the logs to make a minute-by-minute picture of the position of every patient (or any desired interval)",
    "section": "",
    "text": "Current mechanism\nIn short, the final plot is an animated plotly scatterplot.\nIn theory, there’s nothing to stop it using an alternative mode of action (e.g. svg), but one benefit of plotly is that it nicely deals with the intermediate paths of patients. It is also available in both Python and R with minimal changes and has extensive compatability with other tools - e.g. Streamlit, Dash.\nThere are a couple of key steps to setting up the visualisation 1. Adding logging steps to the model 2. Swapping the use of resources for simpy stores containing resources 3. Creating an object that stores resources - a ‘scenario’ object - which then informs the number of resources displayed 4. Iterating through the logs to make a minute-by-minute picture of the position of every patient (or any desired interval) 5. Using Plotly to display these logs"
  },
  {
    "objectID": "notes.html#adding-logging-steps-to-the-model",
    "href": "notes.html#adding-logging-steps-to-the-model",
    "title": "4. Iterating through the logs to make a minute-by-minute picture of the position of every patient (or any desired interval)",
    "section": "1. Adding logging steps to the model",
    "text": "1. Adding logging steps to the model\nFive key classes of events need to be logged for every patient: - arrival - queue - resource use start - resource use end (could possibly be removed) - depart\nSimple improvements required include applying consistency to naming (e.g. arrival and departure, arrive and depart, not a mixture of the two)\nAt present, five to six things are recorded per log. ‘Pathway’ could potentially be removed.\nThis whole structure could be rewritten to be significantly less verbose. It is written like this at present because of the ease of transforming this structure of dictionary to a dataframe and the flexibility of the structure, but exploring alternatives like key:value pairs of event:time could be explored.\nCurrenly, the key logs take the following format\nArrival:\nself.full_event_log.append({\n    'patient': self.identifier,\n    'pathway': 'Simplest',\n    'event_type': 'arrival_departure',\n    'event': 'arrival',\n    'time': self.env.now\n})\nQueueing:\nself.full_event_log.append({\n    'patient': self.identifier,\n    'pathway': 'Simplest',\n    'event': 'treatment_wait_begins',\n    'event_type': 'queue',\n    'time': self.env.now\n})\nResource Use Start:\nself.full_event_log.append({\n    'patient': self.identifier,\n    'pathway': 'Simplest',\n    'event': 'treatment_begins',\n    'event_type': 'resource_use',\n    'time': self.env.now,\n    'resource_id': treatment_resource.id_attribute\n})\nResource Use End:\nself.full_event_log.append({\n    'patient': self.identifier,\n    'pathway': 'Simplest',\n    'event': 'treatment_complete',\n    'event_type': 'resource_use_end',\n    'time': self.env.now,\n    'resource_id': treatment_resource.id_attribute\n})\nDeparture:\nself.full_event_log.append({\n    'patient': self.identifier,\n    'pathway': 'Simplest',\n    'event': 'depart',\n    'event_type': 'arrival_departure',\n    'time': self.env.now\n})"
  },
  {
    "objectID": "notes.html#swapping-the-use-of-resources-for-simpy-stores-containing-resources",
    "href": "notes.html#swapping-the-use-of-resources-for-simpy-stores-containing-resources",
    "title": "4. Iterating through the logs to make a minute-by-minute picture of the position of every patient (or any desired interval)",
    "section": "2. Swapping the use of resources for simpy stores containing resources",
    "text": "2. Swapping the use of resources for simpy stores containing resources\nWhen a resource is in use, we need to be able to show a single entity consistently hogging the same resource throughout the full time they are using it.\nSimpy resources do not inherently have any ID attribute. After exploring options like monkey patching the resource class, a better alternative seemed to be using a simpy store - which does have an ID - instead of a straight resource.\nWithout this ID attribute, the default logic used to move entities through the steps results in them visually behaving like a queue, which makes it hard to understand how long someone has been using a resource for and is visually confusing.\nFortunately the code changes required are minimal. We initialise the store, then use a loop to create as many resources within that store as required.\ndef init_resources(self):\n    '''\n    Init the number of resources\n    and store in the arguments container object\n\n    Resource list:\n        1. Nurses/treatment bays (same thing in this model)\n\n    '''\n    self.args.treatment = simpy.Store(self.env)\n\n    for i in range(self.args.n_cubicles_1):\n        self.args.treatment.put(\n            CustomResource(\n                self.env,\n                capacity=1,\n                id_attribute = i+1)\n            )\nUse of the resource then becomes\n# Seize a treatment resource when available\ntreatment_resource = yield self.args.treatment.get()\nWhen the timeout has elapsed, we then use the following code.\n# Resource is no longer in use, so put it back in\nself.args.treatment.put(treatment_resource)\nThis has additional benefits of making it easier to monitor the use of individual resources.\nOne thing that has been noticed is that the resources seem to be cycled through in order. For example, if you have 4 resources and all are available, but the last resource to be in use was resource 2, resource 3 will be seized the next time someone requires a resource. This may not be entirely realistic, and code to ‘shake up’ the resources after use may be worth exploring."
  },
  {
    "objectID": "notes.html#creating-an-object-that-stores-resources---a-scenario-object---which-then-informs-the-number-of-resources-displayed",
    "href": "notes.html#creating-an-object-that-stores-resources---a-scenario-object---which-then-informs-the-number-of-resources-displayed",
    "title": "4. Iterating through the logs to make a minute-by-minute picture of the position of every patient (or any desired interval)",
    "section": "3. Creating an object that stores resources - a ‘scenario’ object - which then informs the number of resources displayed",
    "text": "3. Creating an object that stores resources - a ‘scenario’ object - which then informs the number of resources displayed\nAt present this part of the code expects a scenario object. This could be changed to - expect a dictionary instead - work with either a scenario or dictionary object (maybe if the route of expanding TM’s approach to simpy modelling into an opinionated framework)\nIf going with the first option, the scenario class used in TM’s work routinely could be expanded to include a method to export the required data to a dictionary format.\n\nevents_with_resources = event_position_df[event_position_df['resource'].notnull()].copy()\nevents_with_resources['resource_count'] = events_with_resources['resource'].apply(lambda x: getattr(scenario, x))\n\nevents_with_resources = events_with_resources.join(events_with_resources.apply(\n    lambda r: pd.Series({'x_final': [r['x']-(10*(i+1)) for i in range(r['resource_count'])]}), axis=1).explode('x_final'),\n    how='right')\n\nfig.add_trace(go.Scatter(\n    x=events_with_resources['x_final'].to_list(),\n    # Place these slightly below the y position for each entity\n    # that will be using the resource\n    y=[i-10 for i in events_with_resources['y'].to_list()],\n    mode=\"markers\",\n    # Define what the marker will look like\n    marker=dict(\n        color='LightSkyBlue',\n        size=15),\n    opacity=0.8,\n    hoverinfo='none'\n))\n\nThe function reshape_for_animations()"
  },
  {
    "objectID": "notes.html#using-plotly-to-display-these-logs",
    "href": "notes.html#using-plotly-to-display-these-logs",
    "title": "4. Iterating through the logs to make a minute-by-minute picture of the position of every patient (or any desired interval)",
    "section": "5. Using Plotly to display these logs",
    "text": "5. Using Plotly to display these logs\nThe function animate_activity_log currently takes 3 mandatory parameters: - full_patient_df - event_position_df - scenario\nfull_patient_df is the output of the function reshape_for_animations\nThe graph is a plotly scatterplot. The initial animated plot is created using plotly express, with additional static layers added afterwards.\nEach individual is a scatter point. The actual points are fully transparent, and what we see is a text label - the emoji.\nA list of any length of emojis is required. This will then be joined with a distinct patient table to provide a list of patients."
  },
  {
    "objectID": "notes.html#already-created",
    "href": "notes.html#already-created",
    "title": "4. Iterating through the logs to make a minute-by-minute picture of the position of every patient (or any desired interval)",
    "section": "Already created",
    "text": "Already created\n\nSimple pathway (units: minutes)\nPathway with branching and optional steps (units: weeks)"
  },
  {
    "objectID": "notes.html#not-yet-created---additional-features-possibly-required",
    "href": "notes.html#not-yet-created---additional-features-possibly-required",
    "title": "4. Iterating through the logs to make a minute-by-minute picture of the position of every patient (or any desired interval)",
    "section": "Not yet created - additional features possibly required",
    "text": "Not yet created - additional features possibly required\n\nSimple pathway (units: days, weeks)\nResource numbers that change at different points of the day\nPrioritised queueing\nShared resources\nMultiple resources required for a step (e.g. doctor + cubicle - how to display this?)\nReneging\nJockeying\nBalking"
  },
  {
    "objectID": "notes.html#known-areas-for-attention",
    "href": "notes.html#known-areas-for-attention",
    "title": "4. Iterating through the logs to make a minute-by-minute picture of the position of every patient (or any desired interval)",
    "section": "Known areas for attention",
    "text": "Known areas for attention\n\nThe code is not written in an object oriented manner.\nThere’s a bug in the wrapping code that results in queues building out in a diagonal manner (shifted 1 to the left) from the 3rd row onwards (2nd row counts to 11 instead of 10, and then subsequent rows correctly include 10 but start too far over)"
  },
  {
    "objectID": "notes.html#required-enhancements",
    "href": "notes.html#required-enhancements",
    "title": "4. Iterating through the logs to make a minute-by-minute picture of the position of every patient (or any desired interval)",
    "section": "Required enhancements",
    "text": "Required enhancements\n\nAt present, the queue of users will continue to grow indefinitely until it leaves the boundary."
  },
  {
    "objectID": "notes.html#friction-points",
    "href": "notes.html#friction-points",
    "title": "4. Iterating through the logs to make a minute-by-minute picture of the position of every patient (or any desired interval)",
    "section": "Friction points",
    "text": "Friction points\n\nSetting up the background image can be a fiddly process"
  },
  {
    "objectID": "notes.html#other-limitations",
    "href": "notes.html#other-limitations",
    "title": "4. Iterating through the logs to make a minute-by-minute picture of the position of every patient (or any desired interval)",
    "section": "Other limitations",
    "text": "Other limitations\n\nBy avoiding emojis that were released after v12.0 of the emoji standard (released in early 2019), we can ensure compatability with most major OSs. Windows 10 has not been updated past this point. However, due to the nature of emojis, we cannot absolutely ensure full compatability across all systems."
  },
  {
    "objectID": "notes.html#concerns",
    "href": "notes.html#concerns",
    "title": "4. Iterating through the logs to make a minute-by-minute picture of the position of every patient (or any desired interval)",
    "section": "Concerns",
    "text": "Concerns\n\nCurrently, logging can cope with ~5 minute snapshots for 5 days of logs in a system that has ~10-60 people in the system at any given point in time. This results in a self-contained plot of ~20mb when exported (for comparison, a self-contained line chart with some additional rectangles is &lt;20kb).\n\n5 days was chosen as a good limit for the streamlit teaching app as it offered a good balance between speed and minimized the risk of crashing across different choices of parameters.\n\nIf significantly too few resources are provided at a given step, the size of the animation dataframe quickly gets out of hand (as people aren’t getting through the system so the number of people in the system at each snapshot is very large)\n\nWorking on a way of displaying queues after a threshold number of people is reached will help significantly"
  },
  {
    "objectID": "examples/feat_changing_sim_time/feat_changing_sim_time.html",
    "href": "examples/feat_changing_sim_time/feat_changing_sim_time.html",
    "title": "Feature Breakdown: Changing how the date and time are displayed",
    "section": "",
    "text": "We can change the start time of our simulation to best reflect our simulation’s parameters.\n\nfrom examples.example_6_simplest_case_storewrapper.ex_6_model_classes_with_vidigi_logging import Trial, g\nfrom vidigi.animation import animate_activity_log\nfrom vidigi.utils import EventPosition, create_event_position_df\nimport pandas as pd\nimport plotly.io as pio\npio.renderers.default = \"notebook\"\nimport os\n\n\n\n\n\n\n\nView Imported Code, which has had logging steps added at the appropriate points in the ‘model’ class\n\n\n\n\n\nimport random\nimport numpy as np\nimport pandas as pd\nimport simpy\nfrom sim_tools.distributions import Exponential, Lognormal\nfrom vidigi.resources import VidigiStore\n\n\n# Class to store global parameter values.  We don't create an instance of this\n# class - we just refer to the class blueprint itself to access the numbers\n# inside.\nclass g:\n    '''\n    Create a scenario to parameterise the simulation model\n\n    Parameters:\n    -----------\n    random_number_set: int, optional (default=DEFAULT_RNG_SET)\n        Set to control the initial seeds of each stream of pseudo\n        random numbers used in the model.\n\n    n_cubicles: int\n        The number of treatment cubicles\n\n    trauma_treat_mean: float\n        Mean of the trauma cubicle treatment distribution (Lognormal)\n\n    trauma_treat_var: float\n        Variance of the trauma cubicle treatment distribution (Lognormal)\n\n    arrival_rate: float\n        Set the mean of the exponential distribution that is used to sample the\n        inter-arrival time of patients\n\n    sim_duration: int\n        The number of time units the simulation will run for\n\n    number_of_runs: int\n        The number of times the simulation will be run with different random number streams\n\n    '''\n    random_number_set = 42\n\n    n_cubicles = 4\n    trauma_treat_mean = 40\n    trauma_treat_var = 5\n\n    arrival_rate = 5\n\n    sim_duration = 600\n    number_of_runs = 100\n\n# Class representing patients coming in to the clinic.\nclass Patient:\n    '''\n    Class defining details for a patient entity\n    '''\n    def __init__(self, p_id):\n        '''\n        Constructor method\n\n        Params:\n        -----\n        identifier: int\n            a numeric identifier for the patient.\n        '''\n        self.identifier = p_id\n        self.arrival = -np.inf\n        self.wait_treat = -np.inf\n        self.total_time = -np.inf\n        self.treat_duration = -np.inf\n\n# Class representing our model of the clinic.\nclass Model:\n    '''\n    Simulates the simplest minor treatment process for a patient\n\n    1. Arrive\n    2. Examined/treated by nurse when one available\n    3. Discharged\n    '''\n    # Constructor to set up the model for a run.  We pass in a run number when\n    # we create a new model.\n    def __init__(self, run_number):\n        # Create a SimPy environment in which everything will live\n        self.env = simpy.Environment()\n\n        self.event_log = []\n\n        # Create a patient counter (which we'll use as a patient ID)\n        self.patient_counter = 0\n\n        self.patients = []\n\n        # Create our resources\n        self.init_resources()\n\n        # Store the passed in run number\n        self.run_number = run_number\n\n        # Create a new Pandas DataFrame that will store some results against\n        # the patient ID (which we'll use as the index).\n        self.results_df = pd.DataFrame()\n        self.results_df[\"Patient ID\"] = [1]\n        self.results_df[\"Queue Time Cubicle\"] = [0.0]\n        self.results_df[\"Time with Nurse\"] = [0.0]\n        self.results_df.set_index(\"Patient ID\", inplace=True)\n\n        # Create an attribute to store the mean queuing times across this run of\n        # the model\n        self.mean_q_time_cubicle = 0\n\n        self.patient_inter_arrival_dist = Exponential(mean = g.arrival_rate,\n                                                      random_seed = self.run_number*g.random_number_set)\n        self.treat_dist = Lognormal(mean = g.trauma_treat_mean,\n                                    stdev = g.trauma_treat_var,\n                                    random_seed = self.run_number*g.random_number_set)\n\n    def init_resources(self):\n        '''\n        Init the number of resources\n        and store in the arguments container object\n\n        Resource list:\n            1. Nurses/treatment bays (same thing in this model)\n\n        '''\n        self.treatment_cubicles = VidigiStore(self.env, num_resources=g.n_cubicles)\n\n    # A generator function that represents the DES generator for patient\n    # arrivals\n    def generator_patient_arrivals(self):\n        # We use an infinite loop here to keep doing this indefinitely whilst\n        # the simulation runs\n        while True:\n            # Increment the patient counter by 1 (this means our first patient\n            # will have an ID of 1)\n            self.patient_counter += 1\n\n            # Create a new patient - an instance of the Patient Class we\n            # defined above.  Remember, we pass in the ID when creating a\n            # patient - so here we pass the patient counter to use as the ID.\n            p = Patient(self.patient_counter)\n\n            # Store patient in list for later easy access\n            self.patients.append(p)\n\n            # Tell SimPy to start up the attend_clinic generator function with\n            # this patient (the generator function that will model the\n            # patient's journey through the system)\n            self.env.process(self.attend_clinic(p))\n\n            # Randomly sample the time to the next patient arriving.  Here, we\n            # sample from an exponential distribution (common for inter-arrival\n            # times), and pass in a lambda value of 1 / mean.  The mean\n            # inter-arrival time is stored in the g class.\n            sampled_inter = self.patient_inter_arrival_dist.sample()\n\n            # Freeze this instance of this function in place until the\n            # inter-arrival time we sampled above has elapsed.  Note - time in\n            # SimPy progresses in \"Time Units\", which can represent anything\n            # you like (just make sure you're consistent within the model)\n            yield self.env.timeout(sampled_inter)\n\n    # A generator function that represents the pathway for a patient going\n    # through the clinic.\n    # The patient object is passed in to the generator function so we can\n    # extract information from / record information to it\n    def attend_clinic(self, patient):\n        self.arrival = self.env.now\n        self.event_log.append(\n            {'patient': patient.identifier,\n             'pathway': 'Simplest',\n             'event_type': 'arrival_departure',\n             'event': 'arrival',\n             'time': self.env.now}\n        )\n\n        # request examination resource\n        start_wait = self.env.now\n        self.event_log.append(\n            {'patient': patient.identifier,\n             'pathway': 'Simplest',\n             'event': 'treatment_wait_begins',\n             'event_type': 'queue',\n             'time': self.env.now}\n        )\n\n        # Seize a treatment resource when available\n        with self.treatment_cubicles.request() as req:\n            treatment_resource = yield req\n            # record the waiting time for registration\n            self.wait_treat = self.env.now - start_wait\n            self.event_log.append(\n                {'patient': patient.identifier,\n                    'pathway': 'Simplest',\n                    'event': 'treatment_begins',\n                    'event_type': 'resource_use',\n                    'time': self.env.now,\n                    'resource_id': treatment_resource.id_attribute\n                    }\n            )\n\n            # sample treatment duration\n            self.treat_duration = self.treat_dist.sample()\n            yield self.env.timeout(self.treat_duration)\n\n            self.event_log.append(\n                {'patient': patient.identifier,\n                    'pathway': 'Simplest',\n                    'event': 'treatment_complete',\n                    'event_type': 'resource_use_end',\n                    'time': self.env.now,\n                    'resource_id': treatment_resource.id_attribute}\n            )\n\n\n        # total time in system\n        self.total_time = self.env.now - self.arrival\n        self.event_log.append(\n            {'patient': patient.identifier,\n            'pathway': 'Simplest',\n            'event': 'depart',\n            'event_type': 'arrival_departure',\n            'time': self.env.now}\n        )\n\n\n    # This method calculates results over a single run.  Here we just calculate\n    # a mean, but in real world models you'd probably want to calculate more.\n    def calculate_run_results(self):\n        # Take the mean of the queuing times across patients in this run of the\n        # model.\n        self.mean_q_time_cubicle = self.results_df[\"Queue Time Cubicle\"].mean()\n\n    # The run method starts up the DES entity generators, runs the simulation,\n    # and in turns calls anything we need to generate results for the run\n    def run(self):\n        # Start up our DES entity generators that create new patients.  We've\n        # only got one in this model, but we'd need to do this for each one if\n        # we had multiple generators.\n        self.env.process(self.generator_patient_arrivals())\n\n        # Run the model for the duration specified in g class\n        self.env.run(until=g.sim_duration)\n\n        # Now the simulation run has finished, call the method that calculates\n        # run results\n        self.calculate_run_results()\n\n        self.event_log = pd.DataFrame(self.event_log)\n\n        self.event_log[\"run\"] = self.run_number\n\n        return {'results': self.results_df, 'event_log': self.event_log}\n\n# Class representing a Trial for our simulation - a batch of simulation runs.\nclass Trial:\n    # The constructor sets up a pandas dataframe that will store the key\n    # results from each run against run number, with run number as the index.\n    def  __init__(self):\n        self.df_trial_results = pd.DataFrame()\n        self.df_trial_results[\"Run Number\"] = [0]\n        self.df_trial_results[\"Arrivals\"] = [0]\n        self.df_trial_results[\"Mean Queue Time Cubicle\"] = [0.0]\n        self.df_trial_results.set_index(\"Run Number\", inplace=True)\n\n        self.all_event_logs = []\n\n    # Method to run a trial\n    def run_trial(self):\n        print(f\"{g.n_cubicles} nurses\")\n        print(\"\") ## Print a blank line\n\n        # Run the simulation for the number of runs specified in g class.\n        # For each run, we create a new instance of the Model class and call its\n        # run method, which sets everything else in motion.  Once the run has\n        # completed, we grab out the stored run results (just mean queuing time\n        # here) and store it against the run number in the trial results\n        # dataframe.\n        for run in range(g.number_of_runs):\n            random.seed(run)\n\n            my_model = Model(run)\n            model_outputs = my_model.run()\n            patient_level_results = model_outputs[\"results\"]\n            event_log = model_outputs[\"event_log\"]\n\n            self.df_trial_results.loc[run] = [\n                len(patient_level_results),\n                my_model.mean_q_time_cubicle,\n            ]\n\n            # print(event_log)\n\n            self.all_event_logs.append(event_log)\n\n        self.all_event_logs = pd.concat(self.all_event_logs)\n\n\n\n\ng.sim_duration = 60 * 24 * 2 # 2 days (using unit of minutes)\n\nmy_trial = Trial()\n\nmy_trial.run_trial()\n\n4 nurses\n\n\n\n\nSIM_START_DATE = \"2024-01-01\"\nSIM_START_TIME = \"08:00:00\"\nSTEP_SNAPSHOT_MAX = 45\nLIMIT_DURATION = g.sim_duration\nWRAP_QUEUES_AT = 15\n\n\n# Create a list of EventPosition objects\nevent_position_df = create_event_position_df([\n    EventPosition(event='arrival', x=50, y=300, label=\"Arrival\"),\n    EventPosition(event='treatment_wait_begins', x=205, y=275, label=\"Waiting for Treatment\"),\n    EventPosition(event='treatment_begins', x=205, y=175, resource='n_cubicles', label=\"Being Treated\"),\n    EventPosition(event='depart', x=270, y=70, label=\"Exit\")\n])\n\n\nRun using the all-in-one animation function\nLet’s first look at the output if we don’t use the start date or ask for the data to displayed in days, hours and minutes.\n\nanimate_activity_log(\n        event_log=my_trial.all_event_logs[my_trial.all_event_logs['run']==1],\n        event_position_df= event_position_df,\n        scenario=g(),\n        entity_col_name=\"patient\",\n        every_x_time_units=10,\n        gap_between_entities=6,\n        plotly_height=700,\n        frame_duration=200,\n        plotly_width=1200,\n        override_x_max=300,\n        override_y_max=500,\n        limit_duration=g.sim_duration,\n        wrap_queues_at=25,\n        step_snapshot_max=100,\n        display_stage_labels=False,\n        add_background_image=\"https://raw.githubusercontent.com/Bergam0t/vidigi/refs/heads/main/examples/example_1_simplest_case/Simplest%20Model%20Background%20Image%20-%20Horizontal%20Layout.drawio.png\",\n        debug_mode=True\n    )\n\nAnimation function called at 13:11:40\nIteration through time-unit-by-time-unit logs complete 13:11:41\nSnapshot df concatenation complete at 13:11:41\nReshaped animation dataframe finished construction at 13:11:41\nPlacement dataframe finished construction at 13:11:41\nOutput animation generation complete at 13:11:43\nTotal Time Elapsed: 3.15 seconds\n\n\n        \n        \n        \n\n\n                                                    \n\n\nNext, let’s see what happens when we request it in days, hours and minutes using the time_display_units parameter, but don’t specify a simulation start date.\nThe default behaviour is that it will choose a date 6 months from the date the code is run, and set the starting time to 00:00:00 (midnight).\n\nanimate_activity_log(\n        time_display_units=\"dhm\",\n        event_log=my_trial.all_event_logs[my_trial.all_event_logs['run']==1],\n        event_position_df= event_position_df,\n        entity_col_name=\"patient\",\n        scenario=g(),\n        every_x_time_units=10,\n        gap_between_entities=6,\n        plotly_height=700,\n        frame_duration=200,\n        plotly_width=1200,\n        override_x_max=300,\n        override_y_max=500,\n        limit_duration=g.sim_duration,\n        wrap_queues_at=25,\n        step_snapshot_max=100,\n        display_stage_labels=False,\n        debug_mode=True,\n        add_background_image=\"https://raw.githubusercontent.com/Bergam0t/vidigi/refs/heads/main/examples/example_1_simplest_case/Simplest%20Model%20Background%20Image%20-%20Horizontal%20Layout.drawio.png\",\n    )\n\nAnimation function called at 13:11:43\nIteration through time-unit-by-time-unit logs complete 13:11:45\nSnapshot df concatenation complete at 13:11:45\nReshaped animation dataframe finished construction at 13:11:45\nPlacement dataframe finished construction at 13:11:45\nOutput animation generation complete at 13:11:46\nTotal Time Elapsed: 3.08 seconds\n\n\n                                                    \n\n\nLet’s now provide a start date of the 1st of January 2024.\nWe can see that with a start date provided but no start time, the simulation clock will start at 00:00.\n\nanimate_activity_log(\n        start_date=SIM_START_DATE,\n        event_log=my_trial.all_event_logs[my_trial.all_event_logs['run']==1],\n        event_position_df= event_position_df,\n        scenario=g(),\n        entity_col_name=\"patient\",\n        every_x_time_units=10,\n        include_play_button=True,\n        gap_between_entities=6,\n        plotly_height=700,\n        frame_duration=200,\n        plotly_width=1200,\n        override_x_max=300,\n        override_y_max=500,\n        limit_duration=g.sim_duration,\n        wrap_queues_at=25,\n        step_snapshot_max=100,\n        time_display_units=\"dhm\",\n        display_stage_labels=False,\n        add_background_image=\"https://raw.githubusercontent.com/Bergam0t/vidigi/refs/heads/main/examples/example_1_simplest_case/Simplest%20Model%20Background%20Image%20-%20Horizontal%20Layout.drawio.png\",\n    )\n\n                                                    \n\n\nFinally, we’ll provide a start date for the simulation to display too.\n\nanimate_activity_log(\n        entity_col_name=\"patient\",\n        time_display_units=\"dhm\",\n        start_date=SIM_START_DATE,\n        start_time=SIM_START_TIME,\n        event_log=my_trial.all_event_logs[my_trial.all_event_logs['run']==1],\n        event_position_df= event_position_df,\n        scenario=g(),\n        every_x_time_units=10,\n        gap_between_entities=6,\n        plotly_height=700,\n        frame_duration=200,\n        plotly_width=1200,\n        override_x_max=300,\n        override_y_max=500,\n        limit_duration=g.sim_duration,\n        wrap_queues_at=25,\n        step_snapshot_max=100,\n        display_stage_labels=False,\n        add_background_image=\"https://raw.githubusercontent.com/Bergam0t/vidigi/refs/heads/main/examples/example_1_simplest_case/Simplest%20Model%20Background%20Image%20-%20Horizontal%20Layout.drawio.png\",\n    )\n\n                                                    \n\n\nThere are a wide range of different acceptable parameters for the time_display_units parameter.\nThese include\n\n‘dhms’ : Day Month Year + HH:MM:SS (e.g., “06 June 2025:23:45”)\n‘dhms_ampm’ : Same as ‘dhms’, but in 12-hour format with AM/PM (e.g., “06 June 2025:23:45 PM”)\n‘dhm’ : Day Month Year + HH:MM (e.g., “06 June 2025:23”)\n‘dhm_ampm’ : 12-hour format with AM/PM (e.g., “06 June 2025:23 PM”)\n‘dh’ : Day Month Year + HH (e.g., “06 June 2025”)\n‘dh_ampm’ : 12-hour format with AM/PM (e.g., “06 June 2025 PM”)\n‘d’ : Full weekday and date (e.g., “Friday 06 June 2025”)\n‘m’ : Month and year (e.g., “June 2025”)\n‘y’ : Year only (e.g., “2025”)\n‘day_clock’ or ‘simulation_day_clock’: Show simulation-relative day and time (e.g., “Simulation Day 3:15”)\n‘day_clock_ampm’ or ‘simulation_day_clock_ampm’: Same as above, but time is shown in 12-hour clock with AM/PM (e.g., “Simulation Day 3:15 PM”)\n\nAlternatively, you can supply a custom strftime format string (e.g., ‘%Y-%m-%d %H’) to control the display manually.\nLet’s have a look at day_clock:\n\nanimate_activity_log(\n        simulation_time_unit=\"minutes\",\n        time_display_units=\"day_clock\",\n        entity_col_name=\"patient\",\n        start_date=SIM_START_DATE,\n        start_time=SIM_START_TIME,\n        event_log=my_trial.all_event_logs[my_trial.all_event_logs['run']==1],\n        event_position_df=event_position_df,\n        scenario=g(),\n        every_x_time_units=10, # Every minute\n        gap_between_entities=6,\n        plotly_height=700,\n        frame_duration=1000,\n        frame_transition_duration=1000,\n        plotly_width=1200,\n        override_x_max=300,\n        override_y_max=500,\n        limit_duration=g.sim_duration,\n        wrap_queues_at=25,\n        step_snapshot_max=100,\n        display_stage_labels=False,\n        add_background_image=\"https://raw.githubusercontent.com/Bergam0t/vidigi/refs/heads/main/examples/example_1_simplest_case/Simplest%20Model%20Background%20Image%20-%20Horizontal%20Layout.drawio.png\",\n    )\n\n                                                    \n\n\nAnd ‘day_clock_ampm’.\nNote that the suffix _ampm can be added to any of dhms, dhm, dh, and day_clock so that you display the time in a 12 hour format with AM/PM instead of the default 24 hour clock.\n\nanimate_activity_log(\n        simulation_time_unit=\"minutes\",\n        time_display_units=\"day_clock_ampm\",\n        entity_col_name=\"patient\",\n        start_date=SIM_START_DATE,\n        start_time=SIM_START_TIME,\n        event_log=my_trial.all_event_logs[my_trial.all_event_logs['run']==1],\n        event_position_df=event_position_df,\n        scenario=g(),\n        every_x_time_units=10, # Every minute\n        gap_between_entities=6,\n        plotly_height=700,\n        frame_duration=1000,\n        frame_transition_duration=1000,\n        plotly_width=1200,\n        override_x_max=300,\n        override_y_max=500,\n        limit_duration=g.sim_duration,\n        wrap_queues_at=25,\n        step_snapshot_max=100,\n        display_stage_labels=False,\n        add_background_image=\"https://raw.githubusercontent.com/Bergam0t/vidigi/refs/heads/main/examples/example_1_simplest_case/Simplest%20Model%20Background%20Image%20-%20Horizontal%20Layout.drawio.png\",\n    )\n\n                                                    \n\n\n\n\nChanging the timescale\nWe could also display the simulation at a daily level. Let’s imagine our simulation represents the number of patients being seen per day instead of per minute.\nNOTE: These example animations won’t make a lot of sense as the underlying simulation doesn’t really make sense at a higher resolution than daily! but it gives you some idea of how these parameters can change and their impact on how dates and times are displayed.\n\nanimate_activity_log(\n        simulation_time_unit=\"days\",\n        time_display_units=\"d\",\n        start_date=SIM_START_DATE,\n        entity_col_name=\"patient\",\n        event_log=my_trial.all_event_logs[my_trial.all_event_logs['run']==1],\n        event_position_df= event_position_df,\n        scenario=g(),\n        every_x_time_units=10,\n        gap_between_entities=6,\n        plotly_height=700,\n        frame_duration=2000,\n        frame_transition_duration=1000,\n        plotly_width=1200,\n        override_x_max=300,\n        override_y_max=500,\n        limit_duration=g.sim_duration,\n        wrap_queues_at=25,\n        step_snapshot_max=100,\n        display_stage_labels=False,\n        add_background_image=\"https://raw.githubusercontent.com/Bergam0t/vidigi/refs/heads/main/examples/example_1_simplest_case/Simplest%20Model%20Background%20Image%20-%20Horizontal%20Layout.drawio.png\",\n    )\n\n                                                    \n\n\nOr per month…\n\nanimate_activity_log(\n        simulation_time_unit=\"months\",\n        time_display_units=\"m\",\n        entity_col_name=\"patient\",\n        start_date=SIM_START_DATE,\n        start_time=SIM_START_TIME,\n        event_log=my_trial.all_event_logs[my_trial.all_event_logs['run']==1],\n        event_position_df=event_position_df,\n        scenario=g(),\n        every_x_time_units=10, # Every day\n        gap_between_entities=6,\n        plotly_height=700,\n        frame_duration=1000,\n        frame_transition_duration=1000,\n        plotly_width=1200,\n        override_x_max=300,\n        override_y_max=500,\n        limit_duration=g.sim_duration,\n        wrap_queues_at=25,\n        step_snapshot_max=100,\n        display_stage_labels=False,\n        add_background_image=\"https://raw.githubusercontent.com/Bergam0t/vidigi/refs/heads/main/examples/example_1_simplest_case/Simplest%20Model%20Background%20Image%20-%20Horizontal%20Layout.drawio.png\",\n    )\n\n                                                    \n\n\nOr even per year (though we don’t have a simulation set up to demo this at this time!).",
    "crumbs": [
      "Feature Breakdowns",
      "Feature Breakdown: Changing how the date and time are displayed"
    ]
  },
  {
    "objectID": "examples/example_8_wide_resource_spacing/ex_8_model.html",
    "href": "examples/example_8_wide_resource_spacing/ex_8_model.html",
    "title": "Creative Layouts - Single Hospital Ward Example",
    "section": "",
    "text": "import numpy as np\nimport pandas as pd\n\nfrom examples.example_8_wide_resource_spacing.ex_8_model_classes import g, Trial\n\nfrom vidigi.animation import animate_activity_log\n\nimport plotly.io as pio\npio.renderers.default = \"notebook\"\n\n\nclinic_simulation = Trial()\n\n\nclinic_simulation.trial_results\n\n\n\n\n\n\n\n\nentity_id\nevent_type\nevent\ntime\npathway\nrun_number\ntimestamp\nresource_id\n\n\n\n\n0\n1\narrival_departure\narrival\n0.000000\nNone\n1\nNone\nNaN\n\n\n1\n1\nqueue\nbed_wait_begins\n0.000000\nNone\n1\nNone\nNaN\n\n\n2\n1\nresource_use\nstay_begins\n0.000000\nNone\n1\nNone\n1.0\n\n\n3\n2\narrival_departure\narrival\n2.337500\nNone\n1\nNone\nNaN\n\n\n4\n2\nqueue\nbed_wait_begins\n2.337500\nNone\n1\nNone\nNaN\n\n\n...\n...\n...\n...\n...\n...\n...\n...\n...\n\n\n2272\n453\nresource_use_end\nstay_complete\n8719.027185\nNone\n100\nNone\n2.0\n\n\n2273\n453\narrival_departure\ndepart\n8719.027185\nNone\n100\nNone\nNaN\n\n\n2274\n457\narrival_departure\narrival\n8719.147321\nNone\n100\nNone\nNaN\n\n\n2275\n457\nqueue\nbed_wait_begins\n8719.147321\nNone\n100\nNone\nNaN\n\n\n2276\n457\nresource_use\nstay_begins\n8719.147321\nNone\n100\nNone\n1.0\n\n\n\n\n242708 rows × 8 columns\n\n\n\n\nevent_position_df = pd.DataFrame([\n                    {'event': 'arrival',\n                     'x':  50, 'y': 800,\n                     'label': \"Arrival\" },\n\n                    # Triage - minor and trauma\n                    {'event': 'bed_wait_begins',\n                     'x':  205, 'y': 700,\n                     'label': \"Waiting for Bed\"},\n\n                    {'event': 'stay_begins',\n                     'x':  205, 'y': 175,\n                     'resource':'number_of_beds',\n                     'label': \"In Ward\"},\n\n                    {'event': 'depart',\n                     'x':  270, 'y': 70,\n                     'label': \"Exit\"}\n\n                ])\n\n\nanimate_activity_log(\n        event_log=clinic_simulation.trial_results[clinic_simulation.trial_results['run_number']==1],\n        event_position_df= event_position_df,\n        scenario=g(),\n        # Key animation prep parameters\n        every_x_time_units=6,\n        simulation_time_unit=\"hours\",\n        limit_duration=g.sim_duration,\n        step_snapshot_max=125,\n        # Animation display parameters\n        time_display_units=\"dhm\",\n        include_play_button=True,\n        setup_mode=True,\n        debug_mode=True,\n        frame_duration=200,\n        # Text parameters\n        display_stage_labels=True,\n        text_size=20,\n        # Entity and queue size and spacing\n        entity_icon_size=20,\n        wrap_queues_at=25,\n        gap_between_entities=6,\n        gap_between_queue_rows=30,\n        # Resource size and spacing\n        gap_between_resources=150,\n        gap_between_resource_rows=100,\n        resource_icon_size=50,\n        wrap_resources_at=2,\n        custom_resource_icon='🛏️',\n        # Plot size\n        plotly_height=700,\n        plotly_width=1200,\n        # Internal plot coordinates\n        override_x_max=300,\n        override_y_max=900,\n        )\n\nAnimation function called at 11:36:31\nIteration through time-unit-by-time-unit logs complete 11:36:36\nSnapshot df concatenation complete at 11:36:37\nReshaped animation dataframe finished construction at 11:36:37\nPlacement dataframe finished construction at 11:36:37\nOutput animation generation complete at 11:36:42\nTotal Time Elapsed: 10.29 seconds",
    "crumbs": [
      "SimPy Examples",
      "Creative Layouts - Single Hospital Ward Example"
    ]
  },
  {
    "objectID": "examples/example_6_simplest_case_storewrapper/ex_6_simplest_case.html",
    "href": "examples/example_6_simplest_case_storewrapper/ex_6_simplest_case.html",
    "title": "Using the VidigiStore to Simplify Model Code Changes",
    "section": "",
    "text": "In vidigi 0.0.5, a new class VidigiStore has been added that can be used almost exactly like a resource - reducing the amount of rewriting required to incorporate vidigi into your model.\nThis allows us to use the pattern\nwith self.treatment_cubicles.request() as req:\n\n    treatment_resource = yield req\n\n    ### Continue all code in the indented portion that requires the resource, with the resource\n    ### automatically being returned to the store when the indented portion completes\nInstead of\ntreatment_resource = yield self.treatment_cubicles.get()\n\n### Continue all code that requires the resource\n\nself.treatment_cubicles.put(treatment_resource)\n(even though we are still using a Store behind the scenes)\nThis minimizes the syntax changes and rewriting that are required when converting an existing model built using resources to a vidigi-compatible state.\nWhen setting up the resources, we simply use the pattern\nfrom vidigi.resources import VidigiStore\n\n...\n\nself.treatment_cubicles = VidigiStore(\n    self.env,\n    num_resources=g.n_cubicles, # or wherever you are storing your resource counts\n    )\n\nfrom examples.example_6_simplest_case_storewrapper.ex_6_model_classes_with_vidigi_logging import Trial, g\nfrom vidigi.animation import animate_activity_log\nimport pandas as pd\nimport plotly.io as pio\npio.renderers.default = \"notebook\"\nimport os\n\n\n\n\n\n\n\nView Imported Code, which has had logging steps added at the appropriate points in the ‘model’ class\n\n\n\n\n\nimport random\nimport numpy as np\nimport pandas as pd\nimport simpy\nfrom sim_tools.distributions import Exponential, Lognormal\nfrom vidigi.resources import VidigiStore\n\n\n# Class to store global parameter values.  We don't create an instance of this\n# class - we just refer to the class blueprint itself to access the numbers\n# inside.\nclass g:\n    '''\n    Create a scenario to parameterise the simulation model\n\n    Parameters:\n    -----------\n    random_number_set: int, optional (default=DEFAULT_RNG_SET)\n        Set to control the initial seeds of each stream of pseudo\n        random numbers used in the model.\n\n    n_cubicles: int\n        The number of treatment cubicles\n\n    trauma_treat_mean: float\n        Mean of the trauma cubicle treatment distribution (Lognormal)\n\n    trauma_treat_var: float\n        Variance of the trauma cubicle treatment distribution (Lognormal)\n\n    arrival_rate: float\n        Set the mean of the exponential distribution that is used to sample the\n        inter-arrival time of patients\n\n    sim_duration: int\n        The number of time units the simulation will run for\n\n    number_of_runs: int\n        The number of times the simulation will be run with different random number streams\n\n    '''\n    random_number_set = 42\n\n    n_cubicles = 4\n    trauma_treat_mean = 40\n    trauma_treat_var = 5\n\n    arrival_rate = 5\n\n    sim_duration = 600\n    number_of_runs = 100\n\n# Class representing patients coming in to the clinic.\nclass Patient:\n    '''\n    Class defining details for a patient entity\n    '''\n    def __init__(self, p_id):\n        '''\n        Constructor method\n\n        Params:\n        -----\n        identifier: int\n            a numeric identifier for the patient.\n        '''\n        self.identifier = p_id\n        self.arrival = -np.inf\n        self.wait_treat = -np.inf\n        self.total_time = -np.inf\n        self.treat_duration = -np.inf\n\n# Class representing our model of the clinic.\nclass Model:\n    '''\n    Simulates the simplest minor treatment process for a patient\n\n    1. Arrive\n    2. Examined/treated by nurse when one available\n    3. Discharged\n    '''\n    # Constructor to set up the model for a run.  We pass in a run number when\n    # we create a new model.\n    def __init__(self, run_number):\n        # Create a SimPy environment in which everything will live\n        self.env = simpy.Environment()\n\n        self.event_log = []\n\n        # Create a patient counter (which we'll use as a patient ID)\n        self.patient_counter = 0\n\n        self.patients = []\n\n        # Create our resources\n        self.init_resources()\n\n        # Store the passed in run number\n        self.run_number = run_number\n\n        # Create a new Pandas DataFrame that will store some results against\n        # the patient ID (which we'll use as the index).\n        self.results_df = pd.DataFrame()\n        self.results_df[\"Patient ID\"] = [1]\n        self.results_df[\"Queue Time Cubicle\"] = [0.0]\n        self.results_df[\"Time with Nurse\"] = [0.0]\n        self.results_df.set_index(\"Patient ID\", inplace=True)\n\n        # Create an attribute to store the mean queuing times across this run of\n        # the model\n        self.mean_q_time_cubicle = 0\n\n        self.patient_inter_arrival_dist = Exponential(mean = g.arrival_rate,\n                                                      random_seed = self.run_number*g.random_number_set)\n        self.treat_dist = Lognormal(mean = g.trauma_treat_mean,\n                                    stdev = g.trauma_treat_var,\n                                    random_seed = self.run_number*g.random_number_set)\n\n    def init_resources(self):\n        '''\n        Init the number of resources\n        and store in the arguments container object\n\n        Resource list:\n            1. Nurses/treatment bays (same thing in this model)\n\n        '''\n        self.treatment_cubicles = VidigiStore(self.env, num_resources=g.n_cubicles)\n\n    # A generator function that represents the DES generator for patient\n    # arrivals\n    def generator_patient_arrivals(self):\n        # We use an infinite loop here to keep doing this indefinitely whilst\n        # the simulation runs\n        while True:\n            # Increment the patient counter by 1 (this means our first patient\n            # will have an ID of 1)\n            self.patient_counter += 1\n\n            # Create a new patient - an instance of the Patient Class we\n            # defined above.  Remember, we pass in the ID when creating a\n            # patient - so here we pass the patient counter to use as the ID.\n            p = Patient(self.patient_counter)\n\n            # Store patient in list for later easy access\n            self.patients.append(p)\n\n            # Tell SimPy to start up the attend_clinic generator function with\n            # this patient (the generator function that will model the\n            # patient's journey through the system)\n            self.env.process(self.attend_clinic(p))\n\n            # Randomly sample the time to the next patient arriving.  Here, we\n            # sample from an exponential distribution (common for inter-arrival\n            # times), and pass in a lambda value of 1 / mean.  The mean\n            # inter-arrival time is stored in the g class.\n            sampled_inter = self.patient_inter_arrival_dist.sample()\n\n            # Freeze this instance of this function in place until the\n            # inter-arrival time we sampled above has elapsed.  Note - time in\n            # SimPy progresses in \"Time Units\", which can represent anything\n            # you like (just make sure you're consistent within the model)\n            yield self.env.timeout(sampled_inter)\n\n    # A generator function that represents the pathway for a patient going\n    # through the clinic.\n    # The patient object is passed in to the generator function so we can\n    # extract information from / record information to it\n    def attend_clinic(self, patient):\n        self.arrival = self.env.now\n        self.event_log.append(\n            {'patient': patient.identifier,\n             'pathway': 'Simplest',\n             'event_type': 'arrival_departure',\n             'event': 'arrival',\n             'time': self.env.now}\n        )\n\n        # request examination resource\n        start_wait = self.env.now\n        self.event_log.append(\n            {'patient': patient.identifier,\n             'pathway': 'Simplest',\n             'event': 'treatment_wait_begins',\n             'event_type': 'queue',\n             'time': self.env.now}\n        )\n\n        # Seize a treatment resource when available\n        with self.treatment_cubicles.request() as req:\n            treatment_resource = yield req\n            # record the waiting time for registration\n            self.wait_treat = self.env.now - start_wait\n            self.event_log.append(\n                {'patient': patient.identifier,\n                    'pathway': 'Simplest',\n                    'event': 'treatment_begins',\n                    'event_type': 'resource_use',\n                    'time': self.env.now,\n                    'resource_id': treatment_resource.id_attribute\n                    }\n            )\n\n            # sample treatment duration\n            self.treat_duration = self.treat_dist.sample()\n            yield self.env.timeout(self.treat_duration)\n\n            self.event_log.append(\n                {'patient': patient.identifier,\n                    'pathway': 'Simplest',\n                    'event': 'treatment_complete',\n                    'event_type': 'resource_use_end',\n                    'time': self.env.now,\n                    'resource_id': treatment_resource.id_attribute}\n            )\n\n\n        # total time in system\n        self.total_time = self.env.now - self.arrival\n        self.event_log.append(\n            {'patient': patient.identifier,\n            'pathway': 'Simplest',\n            'event': 'depart',\n            'event_type': 'arrival_departure',\n            'time': self.env.now}\n        )\n\n\n    # This method calculates results over a single run.  Here we just calculate\n    # a mean, but in real world models you'd probably want to calculate more.\n    def calculate_run_results(self):\n        # Take the mean of the queuing times across patients in this run of the\n        # model.\n        self.mean_q_time_cubicle = self.results_df[\"Queue Time Cubicle\"].mean()\n\n    # The run method starts up the DES entity generators, runs the simulation,\n    # and in turns calls anything we need to generate results for the run\n    def run(self):\n        # Start up our DES entity generators that create new patients.  We've\n        # only got one in this model, but we'd need to do this for each one if\n        # we had multiple generators.\n        self.env.process(self.generator_patient_arrivals())\n\n        # Run the model for the duration specified in g class\n        self.env.run(until=g.sim_duration)\n\n        # Now the simulation run has finished, call the method that calculates\n        # run results\n        self.calculate_run_results()\n\n        self.event_log = pd.DataFrame(self.event_log)\n\n        self.event_log[\"run\"] = self.run_number\n\n        return {'results': self.results_df, 'event_log': self.event_log}\n\n# Class representing a Trial for our simulation - a batch of simulation runs.\nclass Trial:\n    # The constructor sets up a pandas dataframe that will store the key\n    # results from each run against run number, with run number as the index.\n    def  __init__(self):\n        self.df_trial_results = pd.DataFrame()\n        self.df_trial_results[\"Run Number\"] = [0]\n        self.df_trial_results[\"Arrivals\"] = [0]\n        self.df_trial_results[\"Mean Queue Time Cubicle\"] = [0.0]\n        self.df_trial_results.set_index(\"Run Number\", inplace=True)\n\n        self.all_event_logs = []\n\n    # Method to run a trial\n    def run_trial(self):\n        print(f\"{g.n_cubicles} nurses\")\n        print(\"\") ## Print a blank line\n\n        # Run the simulation for the number of runs specified in g class.\n        # For each run, we create a new instance of the Model class and call its\n        # run method, which sets everything else in motion.  Once the run has\n        # completed, we grab out the stored run results (just mean queuing time\n        # here) and store it against the run number in the trial results\n        # dataframe.\n        for run in range(g.number_of_runs):\n            random.seed(run)\n\n            my_model = Model(run)\n            model_outputs = my_model.run()\n            patient_level_results = model_outputs[\"results\"]\n            event_log = model_outputs[\"event_log\"]\n\n            self.df_trial_results.loc[run] = [\n                len(patient_level_results),\n                my_model.mean_q_time_cubicle,\n            ]\n\n            # print(event_log)\n\n            self.all_event_logs.append(event_log)\n\n        self.all_event_logs = pd.concat(self.all_event_logs)\n\n\n\n\nmy_trial = Trial()\n\nmy_trial.run_trial()\n\n4 nurses\n\n\n\n\nmy_trial.all_event_logs.head(50)\n\n\n\n\n\n\n\n\npatient\npathway\nevent_type\nevent\ntime\nresource_id\nrun\n\n\n\n\n0\n1\nSimplest\narrival_departure\narrival\n0.000000\nNaN\n0\n\n\n1\n1\nSimplest\nqueue\ntreatment_wait_begins\n0.000000\nNaN\n0\n\n\n2\n1\nSimplest\nresource_use\ntreatment_begins\n0.000000\n1.0\n0\n\n\n3\n2\nSimplest\narrival_departure\narrival\n3.399660\nNaN\n0\n\n\n4\n2\nSimplest\nqueue\ntreatment_wait_begins\n3.399660\nNaN\n0\n\n\n5\n2\nSimplest\nresource_use\ntreatment_begins\n3.399660\n2.0\n0\n\n\n6\n3\nSimplest\narrival_departure\narrival\n8.497645\nNaN\n0\n\n\n7\n3\nSimplest\nqueue\ntreatment_wait_begins\n8.497645\nNaN\n0\n\n\n8\n3\nSimplest\nresource_use\ntreatment_begins\n8.497645\n3.0\n0\n\n\n9\n4\nSimplest\narrival_departure\narrival\n8.596678\nNaN\n0\n\n\n10\n4\nSimplest\nqueue\ntreatment_wait_begins\n8.596678\nNaN\n0\n\n\n11\n4\nSimplest\nresource_use\ntreatment_begins\n8.596678\n4.0\n0\n\n\n12\n5\nSimplest\narrival_departure\narrival\n8.608025\nNaN\n0\n\n\n13\n5\nSimplest\nqueue\ntreatment_wait_begins\n8.608025\nNaN\n0\n\n\n14\n6\nSimplest\narrival_departure\narrival\n11.359739\nNaN\n0\n\n\n15\n6\nSimplest\nqueue\ntreatment_wait_begins\n11.359739\nNaN\n0\n\n\n16\n7\nSimplest\narrival_departure\narrival\n19.509442\nNaN\n0\n\n\n17\n7\nSimplest\nqueue\ntreatment_wait_begins\n19.509442\nNaN\n0\n\n\n18\n8\nSimplest\narrival_departure\narrival\n22.877356\nNaN\n0\n\n\n19\n8\nSimplest\nqueue\ntreatment_wait_begins\n22.877356\nNaN\n0\n\n\n20\n9\nSimplest\narrival_departure\narrival\n26.653863\nNaN\n0\n\n\n21\n9\nSimplest\nqueue\ntreatment_wait_begins\n26.653863\nNaN\n0\n\n\n22\n1\nSimplest\nresource_use_end\ntreatment_complete\n40.317385\n1.0\n0\n\n\n23\n1\nSimplest\narrival_departure\ndepart\n40.317385\nNaN\n0\n\n\n24\n5\nSimplest\nresource_use\ntreatment_begins\n40.317385\n1.0\n0\n\n\n25\n10\nSimplest\narrival_departure\narrival\n40.737793\nNaN\n0\n\n\n26\n10\nSimplest\nqueue\ntreatment_wait_begins\n40.737793\nNaN\n0\n\n\n27\n2\nSimplest\nresource_use_end\ntreatment_complete\n42.443230\n2.0\n0\n\n\n28\n2\nSimplest\narrival_departure\ndepart\n42.443230\nNaN\n0\n\n\n29\n6\nSimplest\nresource_use\ntreatment_begins\n42.443230\n2.0\n0\n\n\n30\n4\nSimplest\nresource_use_end\ntreatment_complete\n48.809628\n4.0\n0\n\n\n31\n4\nSimplest\narrival_departure\ndepart\n48.809628\nNaN\n0\n\n\n32\n7\nSimplest\nresource_use\ntreatment_begins\n48.809628\n4.0\n0\n\n\n33\n3\nSimplest\nresource_use_end\ntreatment_complete\n51.483457\n3.0\n0\n\n\n34\n3\nSimplest\narrival_departure\ndepart\n51.483457\nNaN\n0\n\n\n35\n8\nSimplest\nresource_use\ntreatment_begins\n51.483457\n3.0\n0\n\n\n36\n11\nSimplest\narrival_departure\narrival\n71.026558\nNaN\n0\n\n\n37\n11\nSimplest\nqueue\ntreatment_wait_begins\n71.026558\nNaN\n0\n\n\n38\n5\nSimplest\nresource_use_end\ntreatment_complete\n77.447488\n1.0\n0\n\n\n39\n5\nSimplest\narrival_departure\ndepart\n77.447488\nNaN\n0\n\n\n40\n9\nSimplest\nresource_use\ntreatment_begins\n77.447488\n1.0\n0\n\n\n41\n6\nSimplest\nresource_use_end\ntreatment_complete\n83.962251\n2.0\n0\n\n\n42\n6\nSimplest\narrival_departure\ndepart\n83.962251\nNaN\n0\n\n\n43\n10\nSimplest\nresource_use\ntreatment_begins\n83.962251\n2.0\n0\n\n\n44\n12\nSimplest\narrival_departure\narrival\n87.458700\nNaN\n0\n\n\n45\n12\nSimplest\nqueue\ntreatment_wait_begins\n87.458700\nNaN\n0\n\n\n46\n13\nSimplest\narrival_departure\narrival\n87.465138\nNaN\n0\n\n\n47\n13\nSimplest\nqueue\ntreatment_wait_begins\n87.465138\nNaN\n0\n\n\n48\n7\nSimplest\nresource_use_end\ntreatment_complete\n95.498040\n4.0\n0\n\n\n49\n7\nSimplest\narrival_departure\ndepart\n95.498040\nNaN\n0\n\n\n\n\n\n\n\n\nevent_position_df = pd.DataFrame([\n                    {'event': 'arrival',\n                     'x':  50, 'y': 300,\n                     'label': \"Arrival\" },\n\n                    # Triage - minor and trauma\n                    {'event': 'treatment_wait_begins',\n                     'x':  205, 'y': 275,\n                     'label': \"Waiting for Treatment\"},\n\n                    {'event': 'treatment_begins',\n                     'x':  205, 'y': 175,\n                     'resource':'n_cubicles',\n                     'label': \"Being Treated\"},\n\n                    {'event': 'depart',\n                     'x':  270, 'y': 70,\n                     'label': \"Exit\"}\n\n                ])\n\n\nanimate_activity_log(\n        event_log=my_trial.all_event_logs[my_trial.all_event_logs['run']==1],\n        event_position_df= event_position_df,\n        scenario=g(),\n        entity_col_name=\"patient\",\n        debug_mode=True,\n        setup_mode=False,\n        every_x_time_units=1,\n        include_play_button=True,\n        entity_icon_size=20,\n        text_size=20,\n        gap_between_entities=6,\n        gap_between_queue_rows=25,\n        plotly_height=700,\n        frame_duration=200,\n        plotly_width=1200,\n        override_x_max=300,\n        override_y_max=500,\n        limit_duration=g.sim_duration,\n        wrap_queues_at=25,\n        step_snapshot_max=125,\n        time_display_units=\"dhm\",\n        display_stage_labels=False,\n        add_background_image=\"https://raw.githubusercontent.com/Bergam0t/vidigi/refs/heads/main/examples/example_1_simplest_case/Simplest%20Model%20Background%20Image%20-%20Horizontal%20Layout.drawio.png\",\n    )\n\nAnimation function called at 12:36:45\nIteration through time-unit-by-time-unit logs complete 12:36:48\nSnapshot df concatenation complete at 12:36:48\nReshaped animation dataframe finished construction at 12:36:48\nPlacement dataframe finished construction at 12:36:48\nOutput animation generation complete at 12:36:51\nTotal Time Elapsed: 5.62 seconds",
    "crumbs": [
      "SimPy Examples",
      "Using the VidigiStore to Simplify Model Code Changes"
    ]
  },
  {
    "objectID": "examples/example_4_ciw/notes.html",
    "href": "examples/example_4_ciw/notes.html",
    "title": "vidigi",
    "section": "",
    "text": "This is adapted from the following repository: Monks, T., Harper, A., & Heather, A. (2023). Towards Sharing Tools, Artefacts, and Reproducible Simulation: a ciw model example (v1.0.1). Zenodo. https://doi.org/10.5281/zenodo.10051494\nSee here for the adaptation embedded within that repo: https://github.com/Bergam0t/ciw-example-animation/tree/main\nPlease also note this model runs ciw 2.x\nIt will not run with 3.x - but could theoretically be adapted to do so"
  },
  {
    "objectID": "examples/example_3_simplest_case_priority_resource/ex_3_simplest_case_priority_resource.html",
    "href": "examples/example_3_simplest_case_priority_resource/ex_3_simplest_case_priority_resource.html",
    "title": "Visualising Entities with Different Priorities",
    "section": "",
    "text": "IMPORTANT NOTE!\nIn vidigi 0.0.5, the original implementation of VidigiPriorityStore was rewritten, with the version available in 0.0.4 renamed VidigiPriorityStoreLegacy.\nIf upgrading, you can change your import statement from\nfrom vidigi.utils import VidigiPriorityStore\nto\nfrom vidigi.resources import VidigiPriorityStoreLegacy as VidigiPriorityStore\nto allow your code to continue working in 0.0.5 with no other modifications.\nThe 0.0.5+ version of VidigiPriorityStore is designed to simplify the incorporation of vidigi into models that use simpy resources, minimizing the syntax changes required when requesting a resource. Take a look at example_7_simplest_case_priority_resource_storewrapper.ex_7_model_classes.py for an example of its use.\n\nfrom examples.example_3_simplest_case_priority_resource.ex_3_model_classes import Trial, g\nfrom vidigi.prep import reshape_for_animations, generate_animation_df\nfrom vidigi.animation import generate_animation, animate_activity_log\nimport pandas as pd\nimport plotly.io as pio\npio.renderers.default = \"notebook\"\nimport os\n\n\n\n\n\n\n\nView Imported Code, which has had logging steps added at the appropriate points in the ‘model’ class\n\n\n\n\n\nimport random\nimport numpy as np\nimport pandas as pd\nimport simpy\nfrom sim_tools.distributions import Exponential, Lognormal\nfrom vidigi.resources import populate_store, VidigiPriorityStoreLegacy as VidigiPriorityStore\n\nclass g:\n    '''\n    Create a scenario to parameterise the simulation model\n\n    Parameters:\n    -----------\n    random_number_set: int, optional (default=DEFAULT_RNG_SET)\n        Set to control the initial seeds of each stream of pseudo\n        random numbers used in the model.\n\n    n_cubicles: int\n        The number of treatment cubicles\n\n    trauma_treat_mean: float\n        Mean of the trauma cubicle treatment distribution (Lognormal)\n\n    trauma_treat_var: float\n        Variance of the trauma cubicle treatment distribution (Lognormal)\n\n        arrival_rate: float\n        Set the mean of the exponential distribution that is used to sample the\n        inter-arrival time of patients\n\n    '''\n    random_number_set = 42\n\n    n_cubicles = 4\n    trauma_treat_mean = 40\n    trauma_treat_var = 5\n\n    arrival_rate = 5\n    sim_duration = 600\n    number_of_runs = 100\n\nclass Patient:\n    '''\n    Class defining details for a patient entity\n    '''\n    def __init__(self, p_id):\n        '''\n        Constructor method\n\n        Params:\n        -----\n        identifier: int\n            a numeric identifier for the patient.\n        '''\n        self.identifier = p_id\n        self.arrival = -np.inf\n        self.wait_treat = -np.inf\n        self.total_time = -np.inf\n        self.treat_duration = -np.inf\n\n        # Randomly initialise a patient priority value\n        # Lower values will be prioritised - so priority 1 will be seen before priority 2\n        if random.uniform(0, 1) &lt; 0.2:\n            self.priority = 1\n        else:\n            self.priority = 2\n\nclass Model:\n    '''\n    Simulates the simplest minor treatment process for a patient\n\n    1. Arrive\n    2. Examined/treated by nurse when one available\n    3. Discharged\n    '''\n    # Constructor to set up the model for a run.  We pass in a run number when\n    # we create a new model.\n    def __init__(self, run_number):\n        # Create a SimPy environment in which everything will live\n        self.env = simpy.Environment()\n\n        self.event_log = []\n\n        # Create a patient counter (which we'll use as a patient ID)\n        self.patient_counter = 0\n\n        self.patients = []\n\n        # Create our resources\n        self.init_resources()\n\n        # Store the passed in run number\n        self.run_number = run_number\n\n        # Create a new Pandas DataFrame that will store some results against\n        # the patient ID (which we'll use as the index).\n        self.results_df = pd.DataFrame()\n        self.results_df[\"Patient ID\"] = [1]\n        self.results_df[\"Queue Time Cubicle\"] = [0.0]\n        self.results_df[\"Time with Nurse\"] = [0.0]\n        self.results_df.set_index(\"Patient ID\", inplace=True)\n\n        # Create an attribute to store the mean queuing times across this run of\n        # the model\n        self.mean_q_time_cubicle = 0\n\n        self.patient_inter_arrival_dist = Exponential(mean = g.arrival_rate,\n                                                      random_seed = self.run_number*g.random_number_set)\n        self.treat_dist = Lognormal(mean = g.trauma_treat_mean,\n                                    stdev = g.trauma_treat_var,\n                                    random_seed = self.run_number*g.random_number_set)\n\n    def init_resources(self):\n        '''\n        Init the number of resources\n        and store in the arguments container object\n\n        Resource list:\n            1. Nurses/treatment bays (same thing in this model)\n\n        '''\n        self.treatment_cubicles = VidigiPriorityStore(self.env)\n\n        populate_store(num_resources=g.n_cubicles,\n                       simpy_store=self.treatment_cubicles,\n                       sim_env=self.env)\n\n    # A generator function that represents the DES generator for patient arrivals\n    def generator_patient_arrivals(self):\n        # Use an infinite loop here to keep doing this indefinitely while the simulation runs\n        while True:\n            # Increment the patient counter by 1 (first patient will have an ID of 1)\n            self.patient_counter += 1\n\n            p = Patient(self.patient_counter)\n\n            # Store patient in list for later easy access\n            self.patients.append(p)\n\n            # Tell SimPy to start up the attend_clinic generator function with this patient\n            # (the generator function that will model the patient's journey through the system)\n            self.env.process(self.attend_clinic(p))\n\n            # Randomly sample the time to the next patient arriving\n            sampled_inter = self.patient_inter_arrival_dist.sample()\n\n            # Freeze this instance of this function in place until the inter-arrival time\n            # sampled above has elapsed\n            yield self.env.timeout(sampled_inter)\n\n    def attend_clinic(self, patient):\n        \"\"\"\n        A generator function that represents the pathway for a patient going through the clinic.\n\n        The patient object is passed in to the generator function so we can extract information\n        from / record information to it\n        \"\"\"\n        self.arrival = self.env.now\n\n        # ===== LOGGING FOR VIDIGI ANIMATION  ===== #\n        self.event_log.append(\n            {'patient': patient.identifier,\n             'pathway': patient.priority,\n             'event_type': 'arrival_departure',\n             'event': 'arrival',\n             'time': self.env.now}\n        )\n        # ========================================= #\n\n        # request examination resource\n        start_wait = self.env.now\n\n        # ===== LOGGING FOR VIDIGI ANIMATION  ===== #\n        self.event_log.append(\n            {'patient': patient.identifier,\n             'pathway': patient.priority,\n             'event': 'treatment_wait_begins',\n             'event_type': 'queue',\n             'time': self.env.now}\n        )\n        # ========================================= #\n\n        # Seize a treatment resource when available\n        # Note that we must pass in the patient priority\n        treatment_resource = yield self.treatment_cubicles.get(priority=patient.priority)\n\n        # record the waiting time for registration\n        self.wait_treat = self.env.now - start_wait\n\n        # ===== LOGGING FOR VIDIGI ANIMATION  ===== #\n        self.event_log.append(\n            {'patient': patient.identifier,\n                'pathway': patient.priority,\n                'event': 'treatment_begins',\n                'event_type': 'resource_use',\n                'time': self.env.now,\n                'resource_id': treatment_resource.id_attribute\n                }\n        )\n        # ========================================= #\n\n        # sample treatment duration\n        self.treat_duration = self.treat_dist.sample()\n        yield self.env.timeout(self.treat_duration)\n\n        # ===== LOGGING FOR VIDIGI ANIMATION  ===== #\n        self.event_log.append(\n            {'patient': patient.identifier,\n                'pathway': patient.priority,\n                'event': 'treatment_complete',\n                'event_type': 'resource_use_end',\n                'time': self.env.now,\n                'resource_id': treatment_resource.id_attribute}\n        )\n        # ========================================= #\n\n        # Resource is no longer in use, so put it back in\n        self.treatment_cubicles.put(treatment_resource)\n\n        # total time in system\n        self.total_time = self.env.now - self.arrival\n\n        # ===== LOGGING FOR VIDIGI ANIMATION  ===== #\n        self.event_log.append(\n            {'patient': patient.identifier,\n            'pathway': patient.priority,\n            'event': 'depart',\n            'event_type': 'arrival_departure',\n            'time': self.env.now}\n        )\n        # ========================================= #\n\n\n    # This method calculates results over a single run.  Here we just calculate\n    # a mean, but in real world models you'd probably want to calculate more.\n    def calculate_run_results(self):\n        # Take the mean of the queuing times across patients in this run of the\n        # model.\n        self.mean_q_time_cubicle = self.results_df[\"Queue Time Cubicle\"].mean()\n\n    # The run method starts up the DES entity generators, runs the simulation,\n    # and in turns calls anything we need to generate results for the run\n    def run(self):\n        # Start up our DES entity generators that create new patients.  We've\n        # only got one in this model, but we'd need to do this for each one if\n        # we had multiple generators.\n        self.env.process(self.generator_patient_arrivals())\n\n        # Run the model for the duration specified in g class\n        self.env.run(until=g.sim_duration)\n\n        # Now the simulation run has finished, call the method that calculates\n        # run results\n        self.calculate_run_results()\n\n        self.event_log = pd.DataFrame(self.event_log)\n\n        self.event_log[\"run\"] = self.run_number\n\n        return {'results': self.results_df, 'event_log': self.event_log}\n\n# Class representing a Trial for our simulation - a batch of simulation runs.\nclass Trial:\n    # The constructor sets up a pandas dataframe that will store the key\n    # results from each run against run number, with run number as the index.\n    def  __init__(self):\n        self.df_trial_results = pd.DataFrame()\n        self.df_trial_results[\"Run Number\"] = [0]\n        self.df_trial_results[\"Arrivals\"] = [0]\n        self.df_trial_results[\"Mean Queue Time Cubicle\"] = [0.0]\n        self.df_trial_results.set_index(\"Run Number\", inplace=True)\n\n        self.all_event_logs = []\n\n    # Method to run a trial\n    def run_trial(self):\n        print(f\"{g.n_cubicles} nurses\")\n        print(\"\") ## Print a blank line\n\n        # Run the simulation for the number of runs specified in g class.\n        # For each run, we create a new instance of the Model class and call its\n        # run method, which sets everything else in motion.  Once the run has\n        # completed, we grab out the stored run results (just mean queuing time\n        # here) and store it against the run number in the trial results\n        # dataframe.\n        for run in range(g.number_of_runs):\n            random.seed(run)\n\n            my_model = Model(run)\n            model_outputs = my_model.run()\n            patient_level_results = model_outputs[\"results\"]\n            event_log = model_outputs[\"event_log\"]\n\n            self.df_trial_results.loc[run] = [\n                len(patient_level_results),\n                my_model.mean_q_time_cubicle,\n            ]\n\n            # print(event_log)\n\n            self.all_event_logs.append(event_log)\n\n        self.all_event_logs = pd.concat(self.all_event_logs)\n\n\n\n\nmy_trial = Trial()\n\nmy_trial.run_trial()\n\n4 nurses\n\n\n\n\nmy_trial.all_event_logs.head(50)\n\n\n\n\n\n\n\n\npatient\npathway\nevent_type\nevent\ntime\nresource_id\nrun\n\n\n\n\n0\n1\n2\narrival_departure\narrival\n0.000000\nNaN\n0\n\n\n1\n1\n2\nqueue\ntreatment_wait_begins\n0.000000\nNaN\n0\n\n\n2\n1\n2\nresource_use\ntreatment_begins\n0.000000\n1.0\n0\n\n\n3\n2\n2\narrival_departure\narrival\n3.399660\nNaN\n0\n\n\n4\n2\n2\nqueue\ntreatment_wait_begins\n3.399660\nNaN\n0\n\n\n5\n2\n2\nresource_use\ntreatment_begins\n3.399660\n2.0\n0\n\n\n6\n3\n2\narrival_departure\narrival\n8.497645\nNaN\n0\n\n\n7\n3\n2\nqueue\ntreatment_wait_begins\n8.497645\nNaN\n0\n\n\n8\n3\n2\nresource_use\ntreatment_begins\n8.497645\n3.0\n0\n\n\n9\n4\n2\narrival_departure\narrival\n8.596678\nNaN\n0\n\n\n10\n4\n2\nqueue\ntreatment_wait_begins\n8.596678\nNaN\n0\n\n\n11\n4\n2\nresource_use\ntreatment_begins\n8.596678\n4.0\n0\n\n\n12\n5\n2\narrival_departure\narrival\n8.608025\nNaN\n0\n\n\n13\n5\n2\nqueue\ntreatment_wait_begins\n8.608025\nNaN\n0\n\n\n14\n6\n2\narrival_departure\narrival\n11.359739\nNaN\n0\n\n\n15\n6\n2\nqueue\ntreatment_wait_begins\n11.359739\nNaN\n0\n\n\n16\n7\n2\narrival_departure\narrival\n19.509442\nNaN\n0\n\n\n17\n7\n2\nqueue\ntreatment_wait_begins\n19.509442\nNaN\n0\n\n\n18\n8\n2\narrival_departure\narrival\n22.877356\nNaN\n0\n\n\n19\n8\n2\nqueue\ntreatment_wait_begins\n22.877356\nNaN\n0\n\n\n20\n9\n2\narrival_departure\narrival\n26.653863\nNaN\n0\n\n\n21\n9\n2\nqueue\ntreatment_wait_begins\n26.653863\nNaN\n0\n\n\n22\n1\n2\nresource_use_end\ntreatment_complete\n40.317385\n1.0\n0\n\n\n23\n1\n2\narrival_departure\ndepart\n40.317385\nNaN\n0\n\n\n24\n5\n2\nresource_use\ntreatment_begins\n40.317385\n1.0\n0\n\n\n25\n10\n2\narrival_departure\narrival\n40.737793\nNaN\n0\n\n\n26\n10\n2\nqueue\ntreatment_wait_begins\n40.737793\nNaN\n0\n\n\n27\n2\n2\nresource_use_end\ntreatment_complete\n42.443230\n2.0\n0\n\n\n28\n2\n2\narrival_departure\ndepart\n42.443230\nNaN\n0\n\n\n29\n6\n2\nresource_use\ntreatment_begins\n42.443230\n2.0\n0\n\n\n30\n4\n2\nresource_use_end\ntreatment_complete\n48.809628\n4.0\n0\n\n\n31\n4\n2\narrival_departure\ndepart\n48.809628\nNaN\n0\n\n\n32\n7\n2\nresource_use\ntreatment_begins\n48.809628\n4.0\n0\n\n\n33\n3\n2\nresource_use_end\ntreatment_complete\n51.483457\n3.0\n0\n\n\n34\n3\n2\narrival_departure\ndepart\n51.483457\nNaN\n0\n\n\n35\n8\n2\nresource_use\ntreatment_begins\n51.483457\n3.0\n0\n\n\n36\n11\n2\narrival_departure\narrival\n71.026558\nNaN\n0\n\n\n37\n11\n2\nqueue\ntreatment_wait_begins\n71.026558\nNaN\n0\n\n\n38\n5\n2\nresource_use_end\ntreatment_complete\n77.447488\n1.0\n0\n\n\n39\n5\n2\narrival_departure\ndepart\n77.447488\nNaN\n0\n\n\n40\n9\n2\nresource_use\ntreatment_begins\n77.447488\n1.0\n0\n\n\n41\n6\n2\nresource_use_end\ntreatment_complete\n83.962251\n2.0\n0\n\n\n42\n6\n2\narrival_departure\ndepart\n83.962251\nNaN\n0\n\n\n43\n10\n2\nresource_use\ntreatment_begins\n83.962251\n2.0\n0\n\n\n44\n12\n2\narrival_departure\narrival\n87.458700\nNaN\n0\n\n\n45\n12\n2\nqueue\ntreatment_wait_begins\n87.458700\nNaN\n0\n\n\n46\n13\n2\narrival_departure\narrival\n87.465138\nNaN\n0\n\n\n47\n13\n2\nqueue\ntreatment_wait_begins\n87.465138\nNaN\n0\n\n\n48\n7\n2\nresource_use_end\ntreatment_complete\n95.498040\n4.0\n0\n\n\n49\n7\n2\narrival_departure\ndepart\n95.498040\nNaN\n0\n\n\n\n\n\n\n\n\nSTEP_SNAPSHOT_MAX = 45\nLIMIT_DURATION = g.sim_duration\nWRAP_QUEUES_AT = 15\n\n\nfull_patient_df = reshape_for_animations(\n    event_log=my_trial.all_event_logs[my_trial.all_event_logs['run']==1],\n    entity_col_name=\"patient\",\n    every_x_time_units=2,\n    step_snapshot_max=STEP_SNAPSHOT_MAX,\n    limit_duration=LIMIT_DURATION,\n    debug_mode=True\n    )\n\nfull_patient_df.head(15)\n\nIteration through time-unit-by-time-unit logs complete 12:14:03\nSnapshot df concatenation complete at 12:14:03\n\n\n\n\n\n\n\n\n\nindex\npatient\npathway\nevent_type\nevent\ntime\nresource_id\nrun\nrank\nsnapshot_time\nadditional\n\n\n\n\n0\n2\n1\n1\nresource_use\ntreatment_begins\n0.0\n1.0\n1\n1.0\n0\nNaN\n\n\n1\n2\n1\n1\nresource_use\ntreatment_begins\n0.0\n1.0\n1\n1.0\n2\nNaN\n\n\n2\n2\n1\n1\nresource_use\ntreatment_begins\n0.0\n1.0\n1\n1.0\n4\nNaN\n\n\n3\n2\n1\n1\nresource_use\ntreatment_begins\n0.0\n1.0\n1\n1.0\n6\nNaN\n\n\n4\n2\n1\n1\nresource_use\ntreatment_begins\n0.0\n1.0\n1\n1.0\n8\nNaN\n\n\n5\n2\n1\n1\nresource_use\ntreatment_begins\n0.0\n1.0\n1\n1.0\n10\nNaN\n\n\n6\n2\n1\n1\nresource_use\ntreatment_begins\n0.0\n1.0\n1\n1.0\n12\nNaN\n\n\n7\n2\n1\n1\nresource_use\ntreatment_begins\n0.0\n1.0\n1\n1.0\n14\nNaN\n\n\n8\n2\n1\n1\nresource_use\ntreatment_begins\n0.0\n1.0\n1\n1.0\n16\nNaN\n\n\n9\n2\n1\n1\nresource_use\ntreatment_begins\n0.0\n1.0\n1\n1.0\n18\nNaN\n\n\n10\n2\n1\n1\nresource_use\ntreatment_begins\n0.0\n1.0\n1\n1.0\n20\nNaN\n\n\n11\n2\n1\n1\nresource_use\ntreatment_begins\n0.0\n1.0\n1\n1.0\n22\nNaN\n\n\n12\n2\n1\n1\nresource_use\ntreatment_begins\n0.0\n1.0\n1\n1.0\n24\nNaN\n\n\n13\n2\n1\n1\nresource_use\ntreatment_begins\n0.0\n1.0\n1\n1.0\n26\nNaN\n\n\n14\n2\n1\n1\nresource_use\ntreatment_begins\n0.0\n1.0\n1\n1.0\n28\nNaN\n\n\n\n\n\n\n\n\nevent_position_df = pd.DataFrame([\n                    {'event': 'arrival',\n                     'x':  50, 'y': 300,\n                     'label': \"Arrival\" },\n\n                    # Triage - minor and trauma\n                    {'event': 'treatment_wait_begins',\n                     'x':  205, 'y': 275,\n                     'label': \"Waiting for Treatment\"},\n\n                    {'event': 'treatment_begins',\n                     'x':  205, 'y': 175,\n                     'resource':'n_cubicles',\n                     'label': \"Being Treated\"},\n\n                    {'event': 'depart',\n                     'x':  270, 'y': 70,\n                     'label': \"Exit\"}\n\n                ])\n\n\nGenerate animation using the step-by-step functions\nUsing the three step-by-step functions allows us to intervene in the produced dataframe and manually take control of the icons in use.\nThis will allow us to show the high-priority patients with a unique icon so we can see their frequency and how they are handled in the final model.\n\nfull_patient_df_plus_pos = generate_animation_df(\n    full_entity_df=full_patient_df,\n    event_position_df=event_position_df,\n    entity_col_name=\"patient\",\n    wrap_queues_at=WRAP_QUEUES_AT,\n    step_snapshot_max=STEP_SNAPSHOT_MAX,\n    gap_between_entities=10,\n    gap_between_resources=10,\n    gap_between_queue_rows=30,\n    debug_mode=True\n    )\n\nfull_patient_df_plus_pos.sort_values(['patient', 'snapshot_time']).head(15)\n\nPlacement dataframe finished construction at 12:14:29\n\n\n\n\n\n\n\n\n\nindex\npatient\npathway\nevent_type\nevent\ntime\nresource_id\nrun\nrank\nsnapshot_time\nadditional\nx\ny_final\nlabel\nresource\nx_final\nrow\nicon\n\n\n\n\n10186\n2\n1\n1\nresource_use\ntreatment_begins\n0.0\n1.0\n1\n1.0\n0\nNaN\n205\n175.0\nBeing Treated\nn_cubicles\n205.0\n0.0\n🧔🏼\n\n\n10187\n2\n1\n1\nresource_use\ntreatment_begins\n0.0\n1.0\n1\n1.0\n2\nNaN\n205\n175.0\nBeing Treated\nn_cubicles\n205.0\n0.0\n🧔🏼\n\n\n10188\n2\n1\n1\nresource_use\ntreatment_begins\n0.0\n1.0\n1\n1.0\n4\nNaN\n205\n175.0\nBeing Treated\nn_cubicles\n205.0\n0.0\n🧔🏼\n\n\n10189\n2\n1\n1\nresource_use\ntreatment_begins\n0.0\n1.0\n1\n1.0\n6\nNaN\n205\n175.0\nBeing Treated\nn_cubicles\n205.0\n0.0\n🧔🏼\n\n\n10190\n2\n1\n1\nresource_use\ntreatment_begins\n0.0\n1.0\n1\n1.0\n8\nNaN\n205\n175.0\nBeing Treated\nn_cubicles\n205.0\n0.0\n🧔🏼\n\n\n10191\n2\n1\n1\nresource_use\ntreatment_begins\n0.0\n1.0\n1\n1.0\n10\nNaN\n205\n175.0\nBeing Treated\nn_cubicles\n205.0\n0.0\n🧔🏼\n\n\n10192\n2\n1\n1\nresource_use\ntreatment_begins\n0.0\n1.0\n1\n1.0\n12\nNaN\n205\n175.0\nBeing Treated\nn_cubicles\n205.0\n0.0\n🧔🏼\n\n\n10193\n2\n1\n1\nresource_use\ntreatment_begins\n0.0\n1.0\n1\n1.0\n14\nNaN\n205\n175.0\nBeing Treated\nn_cubicles\n205.0\n0.0\n🧔🏼\n\n\n10194\n2\n1\n1\nresource_use\ntreatment_begins\n0.0\n1.0\n1\n1.0\n16\nNaN\n205\n175.0\nBeing Treated\nn_cubicles\n205.0\n0.0\n🧔🏼\n\n\n10195\n2\n1\n1\nresource_use\ntreatment_begins\n0.0\n1.0\n1\n1.0\n18\nNaN\n205\n175.0\nBeing Treated\nn_cubicles\n205.0\n0.0\n🧔🏼\n\n\n10196\n2\n1\n1\nresource_use\ntreatment_begins\n0.0\n1.0\n1\n1.0\n20\nNaN\n205\n175.0\nBeing Treated\nn_cubicles\n205.0\n0.0\n🧔🏼\n\n\n10197\n2\n1\n1\nresource_use\ntreatment_begins\n0.0\n1.0\n1\n1.0\n22\nNaN\n205\n175.0\nBeing Treated\nn_cubicles\n205.0\n0.0\n🧔🏼\n\n\n10198\n2\n1\n1\nresource_use\ntreatment_begins\n0.0\n1.0\n1\n1.0\n24\nNaN\n205\n175.0\nBeing Treated\nn_cubicles\n205.0\n0.0\n🧔🏼\n\n\n10199\n2\n1\n1\nresource_use\ntreatment_begins\n0.0\n1.0\n1\n1.0\n26\nNaN\n205\n175.0\nBeing Treated\nn_cubicles\n205.0\n0.0\n🧔🏼\n\n\n10200\n2\n1\n1\nresource_use\ntreatment_begins\n0.0\n1.0\n1\n1.0\n28\nNaN\n205\n175.0\nBeing Treated\nn_cubicles\n205.0\n0.0\n🧔🏼\n\n\n\n\n\n\n\n\ndef show_priority_icon(row):\n            if \"more\" not in row[\"icon\"]:\n                if row[\"pathway\"] == 1:\n                        return \"🚨\"\n                else:\n                    return row[\"icon\"]\n            else:\n                return row[\"icon\"]\n\n\nfull_patient_df_plus_pos = full_patient_df_plus_pos.assign(\n            icon=full_patient_df_plus_pos.apply(show_priority_icon, axis=1)\n            )\n\n\nfull_patient_df_plus_pos.head(15)\n\n\n\n\n\n\n\n\nindex\npatient\npathway\nevent_type\nevent\ntime\nresource_id\nrun\nrank\nsnapshot_time\nadditional\nx\ny_final\nlabel\nresource\nx_final\nrow\nicon\n\n\n\n\n0\n155\n49\n2\nqueue\nexit\n208.540636\nNaN\n1\n1.0\n598\nNaN\n270\n70.0\nExit\nNaN\n270.0\n0.0\n🧕🏾\n\n\n1\n155\n49\n2\nqueue\ntreatment_wait_begins\n206.540636\nNaN\n1\n27.0\n208\nNaN\n205\n305.0\nWaiting for Treatment\nNaN\n95.0\n1.0\n🧕🏾\n\n\n2\n155\n49\n2\nqueue\ntreatment_wait_begins\n206.540636\nNaN\n1\n27.0\n210\nNaN\n205\n305.0\nWaiting for Treatment\nNaN\n95.0\n1.0\n🧕🏾\n\n\n3\n155\n49\n2\nqueue\ntreatment_wait_begins\n206.540636\nNaN\n1\n27.0\n212\nNaN\n205\n305.0\nWaiting for Treatment\nNaN\n95.0\n1.0\n🧕🏾\n\n\n4\n155\n49\n2\nqueue\ntreatment_wait_begins\n206.540636\nNaN\n1\n27.0\n214\nNaN\n205\n305.0\nWaiting for Treatment\nNaN\n95.0\n1.0\n🧕🏾\n\n\n5\n155\n49\n2\nqueue\ntreatment_wait_begins\n206.540636\nNaN\n1\n27.0\n216\nNaN\n205\n305.0\nWaiting for Treatment\nNaN\n95.0\n1.0\n🧕🏾\n\n\n6\n155\n49\n2\nqueue\ntreatment_wait_begins\n206.540636\nNaN\n1\n27.0\n218\nNaN\n205\n305.0\nWaiting for Treatment\nNaN\n95.0\n1.0\n🧕🏾\n\n\n7\n155\n49\n2\nqueue\ntreatment_wait_begins\n206.540636\nNaN\n1\n27.0\n220\nNaN\n205\n305.0\nWaiting for Treatment\nNaN\n95.0\n1.0\n🧕🏾\n\n\n8\n155\n49\n2\nqueue\ntreatment_wait_begins\n206.540636\nNaN\n1\n27.0\n222\nNaN\n205\n305.0\nWaiting for Treatment\nNaN\n95.0\n1.0\n🧕🏾\n\n\n9\n155\n49\n2\nqueue\ntreatment_wait_begins\n206.540636\nNaN\n1\n27.0\n224\nNaN\n205\n305.0\nWaiting for Treatment\nNaN\n95.0\n1.0\n🧕🏾\n\n\n10\n155\n49\n2\nqueue\ntreatment_wait_begins\n206.540636\nNaN\n1\n27.0\n226\nNaN\n205\n305.0\nWaiting for Treatment\nNaN\n95.0\n1.0\n🧕🏾\n\n\n11\n155\n49\n2\nqueue\ntreatment_wait_begins\n206.540636\nNaN\n1\n27.0\n228\nNaN\n205\n305.0\nWaiting for Treatment\nNaN\n95.0\n1.0\n🧕🏾\n\n\n12\n155\n49\n2\nqueue\ntreatment_wait_begins\n206.540636\nNaN\n1\n27.0\n230\nNaN\n205\n305.0\nWaiting for Treatment\nNaN\n95.0\n1.0\n🧕🏾\n\n\n13\n155\n49\n2\nqueue\ntreatment_wait_begins\n206.540636\nNaN\n1\n27.0\n232\nNaN\n205\n305.0\nWaiting for Treatment\nNaN\n95.0\n1.0\n🧕🏾\n\n\n14\n155\n49\n2\nqueue\ntreatment_wait_begins\n206.540636\nNaN\n1\n26.0\n234\nNaN\n205\n305.0\nWaiting for Treatment\nNaN\n105.0\n1.0\n🧕🏾\n\n\n\n\n\n\n\n\ngenerate_animation(\n        full_entity_df_plus_pos=full_patient_df_plus_pos.sort_values(['patient', 'snapshot_time']),\n        event_position_df= event_position_df,\n        scenario=g(),\n        entity_col_name=\"patient\",\n        debug_mode=True,\n        setup_mode=False,\n        include_play_button=True,\n        entity_icon_size=20,\n        plotly_height=700,\n        frame_duration=800,\n        frame_transition_duration=200,\n        plotly_width=1200,\n        override_x_max=300,\n        override_y_max=500,\n        time_display_units=\"dhm\",\n        display_stage_labels=False,\n        add_background_image=\"https://raw.githubusercontent.com/Bergam0t/vidigi/refs/heads/main/examples/example_1_simplest_case/Simplest%20Model%20Background%20Image%20-%20Horizontal%20Layout.drawio.png\",\n    )\n\nOutput animation generation complete at 12:14:56\n\n\n        \n        \n        \n\n\n                                                    \n\n\n\n\nRerun, but using the all-in-one animation function (which will not show different priority icons)\n\nanimate_activity_log(\n        event_log=my_trial.all_event_logs[my_trial.all_event_logs['run']==1],\n        event_position_df= event_position_df,\n        scenario=g(),\n        entity_col_name=\"patient\",\n        debug_mode=True,\n        setup_mode=False,\n        every_x_time_units=1,\n        include_play_button=True,\n        entity_icon_size=20,\n        gap_between_entities=6,\n        gap_between_queue_rows=25,\n        plotly_height=700,\n        frame_duration=200,\n        plotly_width=1200,\n        override_x_max=300,\n        override_y_max=500,\n        limit_duration=g.sim_duration,\n        wrap_queues_at=25,\n        step_snapshot_max=125,\n        time_display_units=\"dhm\",\n        display_stage_labels=False,\n        add_background_image=\"https://raw.githubusercontent.com/Bergam0t/vidigi/refs/heads/main/examples/example_1_simplest_case/Simplest%20Model%20Background%20Image%20-%20Horizontal%20Layout.drawio.png\",\n    )\n\nAnimation function called at 12:14:57\nIteration through time-unit-by-time-unit logs complete 12:15:00\nSnapshot df concatenation complete at 12:15:00\nReshaped animation dataframe finished construction at 12:15:00\nPlacement dataframe finished construction at 12:15:00\nOutput animation generation complete at 12:15:03\nTotal Time Elapsed: 6.22 seconds",
    "crumbs": [
      "SimPy Examples",
      "Visualising Entities with Different Priorities"
    ]
  },
  {
    "objectID": "examples/example_1_simplest_case/ex_1_simplest_case.html",
    "href": "examples/example_1_simplest_case/ex_1_simplest_case.html",
    "title": "A Simple Animation of a One-step SimPy Model",
    "section": "",
    "text": "from examples.example_1_simplest_case.ex_1_model_classes_with_vidigi_logging import Trial, g\nfrom vidigi.animation import animate_activity_log\nfrom vidigi.utils import EventPosition, create_event_position_df\nimport pandas as pd\nimport plotly.io as pio\npio.renderers.default = \"notebook\"\nimport os\n\n\n\n\n\n\n\nView Imported Code, which has had logging steps added at the appropriate points in the ‘model’ class\n\n\n\n\n\nimport random\nimport numpy as np\nimport pandas as pd\nimport simpy\nfrom sim_tools.distributions import Exponential, Lognormal\nfrom vidigi.resources import populate_store\n\n\n# Class to store global parameter values.  We don't create an instance of this\n# class - we just refer to the class blueprint itself to access the numbers\n# inside.\nclass g:\n    '''\n    Create a scenario to parameterise the simulation model\n\n    Parameters:\n    -----------\n    random_number_set: int, optional (default=DEFAULT_RNG_SET)\n        Set to control the initial seeds of each stream of pseudo\n        random numbers used in the model.\n\n    n_cubicles: int\n        The number of treatment cubicles\n\n    trauma_treat_mean: float\n        Mean of the trauma cubicle treatment distribution (Lognormal)\n\n    trauma_treat_var: float\n        Variance of the trauma cubicle treatment distribution (Lognormal)\n\n    arrival_rate: float\n        Set the mean of the exponential distribution that is used to sample the\n        inter-arrival time of patients\n\n    sim_duration: int\n        The number of time units the simulation will run for\n\n    number_of_runs: int\n        The number of times the simulation will be run with different random number streams\n\n    '''\n    random_number_set = 42\n\n    n_cubicles = 4\n    trauma_treat_mean = 40\n    trauma_treat_var = 5\n\n    arrival_rate = 5\n\n    sim_duration = 600\n    number_of_runs = 100\n\n# Class representing patients coming in to the clinic.\nclass Patient:\n    '''\n    Class defining details for a patient entity\n    '''\n    def __init__(self, p_id):\n        '''\n        Constructor method\n\n        Params:\n        -----\n        identifier: int\n            a numeric identifier for the patient.\n        '''\n        self.identifier = p_id\n        self.arrival = -np.inf\n        self.wait_treat = -np.inf\n        self.total_time = -np.inf\n        self.treat_duration = -np.inf\n\n# Class representing our model of the clinic.\nclass Model:\n    '''\n    Simulates the simplest minor treatment process for a patient\n\n    1. Arrive\n    2. Examined/treated by nurse when one available\n    3. Discharged\n    '''\n    # Constructor to set up the model for a run.  We pass in a run number when\n    # we create a new model.\n    def __init__(self, run_number):\n        # Create a SimPy environment in which everything will live\n        self.env = simpy.Environment()\n\n        self.event_log = []\n\n        # Create a patient counter (which we'll use as a patient ID)\n        self.patient_counter = 0\n\n        self.patients = []\n\n        # Create our resources\n        self.init_resources()\n\n        # Store the passed in run number\n        self.run_number = run_number\n\n        # Create a new Pandas DataFrame that will store some results against\n        # the patient ID (which we'll use as the index).\n        self.results_df = pd.DataFrame()\n        self.results_df[\"Patient ID\"] = [1]\n        self.results_df[\"Queue Time Cubicle\"] = [0.0]\n        self.results_df[\"Time with Nurse\"] = [0.0]\n        self.results_df.set_index(\"Patient ID\", inplace=True)\n\n        # Create an attribute to store the mean queuing times across this run of\n        # the model\n        self.mean_q_time_cubicle = 0\n\n        self.patient_inter_arrival_dist = Exponential(mean = g.arrival_rate,\n                                                      random_seed = self.run_number*g.random_number_set)\n        self.treat_dist = Lognormal(mean = g.trauma_treat_mean,\n                                    stdev = g.trauma_treat_var,\n                                    random_seed = self.run_number*g.random_number_set)\n\n    def init_resources(self):\n        '''\n        Init the number of resources\n        and store in the arguments container object\n\n        Resource list:\n            1. Nurses/treatment bays (same thing in this model)\n\n        '''\n        self.treatment_cubicles = simpy.Store(self.env)\n\n        populate_store(num_resources=g.n_cubicles,\n                       simpy_store=self.treatment_cubicles,\n                       sim_env=self.env)\n\n    # A generator function that represents the DES generator for patient\n    # arrivals\n    def generator_patient_arrivals(self):\n        # We use an infinite loop here to keep doing this indefinitely whilst\n        # the simulation runs\n        while True:\n            # Increment the patient counter by 1 (this means our first patient\n            # will have an ID of 1)\n            self.patient_counter += 1\n\n            # Create a new patient - an instance of the Patient Class we\n            # defined above.  Remember, we pass in the ID when creating a\n            # patient - so here we pass the patient counter to use as the ID.\n            p = Patient(self.patient_counter)\n\n            # Store patient in list for later easy access\n            self.patients.append(p)\n\n            # Tell SimPy to start up the attend_clinic generator function with\n            # this patient (the generator function that will model the\n            # patient's journey through the system)\n            self.env.process(self.attend_clinic(p))\n\n            # Randomly sample the time to the next patient arriving.  Here, we\n            # sample from an exponential distribution (common for inter-arrival\n            # times), and pass in a lambda value of 1 / mean.  The mean\n            # inter-arrival time is stored in the g class.\n            sampled_inter = self.patient_inter_arrival_dist.sample()\n\n            # Freeze this instance of this function in place until the\n            # inter-arrival time we sampled above has elapsed.  Note - time in\n            # SimPy progresses in \"Time Units\", which can represent anything\n            # you like (just make sure you're consistent within the model)\n            yield self.env.timeout(sampled_inter)\n\n    # A generator function that represents the pathway for a patient going\n    # through the clinic.\n    # The patient object is passed in to the generator function so we can\n    # extract information from / record information to it\n    def attend_clinic(self, patient):\n        self.arrival = self.env.now\n        self.event_log.append(\n            {'patient': patient.identifier,\n             'pathway': 'Simplest',\n             'event_type': 'arrival_departure',\n             'event': 'arrival',\n             'time': self.env.now}\n        )\n\n        # request examination resource\n        start_wait = self.env.now\n        self.event_log.append(\n            {'patient': patient.identifier,\n             'pathway': 'Simplest',\n             'event': 'treatment_wait_begins',\n             'event_type': 'queue',\n             'time': self.env.now}\n        )\n\n        # Seize a treatment resource when available\n        treatment_resource = yield self.treatment_cubicles.get()\n\n        # record the waiting time for registration\n        self.wait_treat = self.env.now - start_wait\n        self.event_log.append(\n            {'patient': patient.identifier,\n                'pathway': 'Simplest',\n                'event': 'treatment_begins',\n                'event_type': 'resource_use',\n                'time': self.env.now,\n                'resource_id': treatment_resource.id_attribute\n                }\n        )\n\n        # sample treatment duration\n        self.treat_duration = self.treat_dist.sample()\n        yield self.env.timeout(self.treat_duration)\n\n        self.event_log.append(\n            {'patient': patient.identifier,\n                'pathway': 'Simplest',\n                'event': 'treatment_complete',\n                'event_type': 'resource_use_end',\n                'time': self.env.now,\n                'resource_id': treatment_resource.id_attribute}\n        )\n\n        # Resource is no longer in use, so put it back in\n        self.treatment_cubicles.put(treatment_resource)\n\n        # total time in system\n        self.total_time = self.env.now - self.arrival\n        self.event_log.append(\n            {'patient': patient.identifier,\n            'pathway': 'Simplest',\n            'event': 'depart',\n            'event_type': 'arrival_departure',\n            'time': self.env.now}\n        )\n\n\n    # This method calculates results over a single run.  Here we just calculate\n    # a mean, but in real world models you'd probably want to calculate more.\n    def calculate_run_results(self):\n        # Take the mean of the queuing times across patients in this run of the\n        # model.\n        self.mean_q_time_cubicle = self.results_df[\"Queue Time Cubicle\"].mean()\n\n    # The run method starts up the DES entity generators, runs the simulation,\n    # and in turns calls anything we need to generate results for the run\n    def run(self):\n        # Start up our DES entity generators that create new patients.  We've\n        # only got one in this model, but we'd need to do this for each one if\n        # we had multiple generators.\n        self.env.process(self.generator_patient_arrivals())\n\n        # Run the model for the duration specified in g class\n        self.env.run(until=g.sim_duration)\n\n        # Now the simulation run has finished, call the method that calculates\n        # run results\n        self.calculate_run_results()\n\n        self.event_log = pd.DataFrame(self.event_log)\n\n        self.event_log[\"run\"] = self.run_number\n\n        return {'results': self.results_df, 'event_log': self.event_log}\n\n# Class representing a Trial for our simulation - a batch of simulation runs.\nclass Trial:\n    # The constructor sets up a pandas dataframe that will store the key\n    # results from each run against run number, with run number as the index.\n    def  __init__(self):\n        self.df_trial_results = pd.DataFrame()\n        self.df_trial_results[\"Run Number\"] = [0]\n        self.df_trial_results[\"Arrivals\"] = [0]\n        self.df_trial_results[\"Mean Queue Time Cubicle\"] = [0.0]\n        self.df_trial_results.set_index(\"Run Number\", inplace=True)\n\n        self.all_event_logs = []\n\n    # Method to run a trial\n    def run_trial(self):\n        print(f\"{g.n_cubicles} nurses\")\n        print(\"\") ## Print a blank line\n\n        # Run the simulation for the number of runs specified in g class.\n        # For each run, we create a new instance of the Model class and call its\n        # run method, which sets everything else in motion.  Once the run has\n        # completed, we grab out the stored run results (just mean queuing time\n        # here) and store it against the run number in the trial results\n        # dataframe.\n        for run in range(g.number_of_runs):\n            random.seed(run)\n\n            my_model = Model(run)\n            model_outputs = my_model.run()\n            patient_level_results = model_outputs[\"results\"]\n            event_log = model_outputs[\"event_log\"]\n\n            self.df_trial_results.loc[run] = [\n                len(patient_level_results),\n                my_model.mean_q_time_cubicle,\n            ]\n\n            # print(event_log)\n\n            self.all_event_logs.append(event_log)\n\n        self.all_event_logs = pd.concat(self.all_event_logs)\n\n\n\n\nmy_trial = Trial()\n\nmy_trial.run_trial()\n\n4 nurses\n\n\n\n\nmy_trial.all_event_logs.head(50)\n\n\n\n\n\n\n\n\npatient\npathway\nevent_type\nevent\ntime\nresource_id\nrun\n\n\n\n\n0\n1\nSimplest\narrival_departure\narrival\n0.000000\nNaN\n0\n\n\n1\n1\nSimplest\nqueue\ntreatment_wait_begins\n0.000000\nNaN\n0\n\n\n2\n1\nSimplest\nresource_use\ntreatment_begins\n0.000000\n1.0\n0\n\n\n3\n2\nSimplest\narrival_departure\narrival\n3.399660\nNaN\n0\n\n\n4\n2\nSimplest\nqueue\ntreatment_wait_begins\n3.399660\nNaN\n0\n\n\n5\n2\nSimplest\nresource_use\ntreatment_begins\n3.399660\n2.0\n0\n\n\n6\n3\nSimplest\narrival_departure\narrival\n8.497645\nNaN\n0\n\n\n7\n3\nSimplest\nqueue\ntreatment_wait_begins\n8.497645\nNaN\n0\n\n\n8\n3\nSimplest\nresource_use\ntreatment_begins\n8.497645\n3.0\n0\n\n\n9\n4\nSimplest\narrival_departure\narrival\n8.596678\nNaN\n0\n\n\n10\n4\nSimplest\nqueue\ntreatment_wait_begins\n8.596678\nNaN\n0\n\n\n11\n4\nSimplest\nresource_use\ntreatment_begins\n8.596678\n4.0\n0\n\n\n12\n5\nSimplest\narrival_departure\narrival\n8.608025\nNaN\n0\n\n\n13\n5\nSimplest\nqueue\ntreatment_wait_begins\n8.608025\nNaN\n0\n\n\n14\n6\nSimplest\narrival_departure\narrival\n11.359739\nNaN\n0\n\n\n15\n6\nSimplest\nqueue\ntreatment_wait_begins\n11.359739\nNaN\n0\n\n\n16\n7\nSimplest\narrival_departure\narrival\n19.509442\nNaN\n0\n\n\n17\n7\nSimplest\nqueue\ntreatment_wait_begins\n19.509442\nNaN\n0\n\n\n18\n8\nSimplest\narrival_departure\narrival\n22.877356\nNaN\n0\n\n\n19\n8\nSimplest\nqueue\ntreatment_wait_begins\n22.877356\nNaN\n0\n\n\n20\n9\nSimplest\narrival_departure\narrival\n26.653863\nNaN\n0\n\n\n21\n9\nSimplest\nqueue\ntreatment_wait_begins\n26.653863\nNaN\n0\n\n\n22\n1\nSimplest\nresource_use_end\ntreatment_complete\n40.317385\n1.0\n0\n\n\n23\n1\nSimplest\narrival_departure\ndepart\n40.317385\nNaN\n0\n\n\n24\n5\nSimplest\nresource_use\ntreatment_begins\n40.317385\n1.0\n0\n\n\n25\n10\nSimplest\narrival_departure\narrival\n40.737793\nNaN\n0\n\n\n26\n10\nSimplest\nqueue\ntreatment_wait_begins\n40.737793\nNaN\n0\n\n\n27\n2\nSimplest\nresource_use_end\ntreatment_complete\n42.443230\n2.0\n0\n\n\n28\n2\nSimplest\narrival_departure\ndepart\n42.443230\nNaN\n0\n\n\n29\n6\nSimplest\nresource_use\ntreatment_begins\n42.443230\n2.0\n0\n\n\n30\n4\nSimplest\nresource_use_end\ntreatment_complete\n48.809628\n4.0\n0\n\n\n31\n4\nSimplest\narrival_departure\ndepart\n48.809628\nNaN\n0\n\n\n32\n7\nSimplest\nresource_use\ntreatment_begins\n48.809628\n4.0\n0\n\n\n33\n3\nSimplest\nresource_use_end\ntreatment_complete\n51.483457\n3.0\n0\n\n\n34\n3\nSimplest\narrival_departure\ndepart\n51.483457\nNaN\n0\n\n\n35\n8\nSimplest\nresource_use\ntreatment_begins\n51.483457\n3.0\n0\n\n\n36\n11\nSimplest\narrival_departure\narrival\n71.026558\nNaN\n0\n\n\n37\n11\nSimplest\nqueue\ntreatment_wait_begins\n71.026558\nNaN\n0\n\n\n38\n5\nSimplest\nresource_use_end\ntreatment_complete\n77.447488\n1.0\n0\n\n\n39\n5\nSimplest\narrival_departure\ndepart\n77.447488\nNaN\n0\n\n\n40\n9\nSimplest\nresource_use\ntreatment_begins\n77.447488\n1.0\n0\n\n\n41\n6\nSimplest\nresource_use_end\ntreatment_complete\n83.962251\n2.0\n0\n\n\n42\n6\nSimplest\narrival_departure\ndepart\n83.962251\nNaN\n0\n\n\n43\n10\nSimplest\nresource_use\ntreatment_begins\n83.962251\n2.0\n0\n\n\n44\n12\nSimplest\narrival_departure\narrival\n87.458700\nNaN\n0\n\n\n45\n12\nSimplest\nqueue\ntreatment_wait_begins\n87.458700\nNaN\n0\n\n\n46\n13\nSimplest\narrival_departure\narrival\n87.465138\nNaN\n0\n\n\n47\n13\nSimplest\nqueue\ntreatment_wait_begins\n87.465138\nNaN\n0\n\n\n48\n7\nSimplest\nresource_use_end\ntreatment_complete\n95.498040\n4.0\n0\n\n\n49\n7\nSimplest\narrival_departure\ndepart\n95.498040\nNaN\n0\n\n\n\n\n\n\n\n\n# Create a list of EventPosition objects\nevent_position_df = create_event_position_df([\n    EventPosition(event='arrival', x=50, y=300, label=\"Arrival\"),\n    EventPosition(event='treatment_wait_begins', x=205, y=275, label=\"Waiting for Treatment\"),\n    EventPosition(event='treatment_begins', x=205, y=175, resource='n_cubicles', label=\"Being Treated\"),\n    EventPosition(event='depart', x=270, y=70, label=\"Exit\")\n])\n\n\nanimate_activity_log(\n        event_log=my_trial.all_event_logs[my_trial.all_event_logs['run']==1],\n        event_position_df= event_position_df,\n        entity_col_name=\"patient\",\n        scenario=g(),\n        debug_mode=True,\n        setup_mode=False,\n        every_x_time_units=1,\n        include_play_button=True,\n        resource_icon_size=20,\n        text_size=20,\n        entity_icon_size=20,\n        gap_between_entities=6,\n        gap_between_queue_rows=25,\n        gap_between_resource_rows=25,\n        plotly_height=700,\n        frame_duration=200,\n        plotly_width=1200,\n        override_x_max=300,\n        override_y_max=500,\n        limit_duration=g.sim_duration,\n        wrap_queues_at=25,\n        step_snapshot_max=125,\n        time_display_units=\"dhm\",\n        display_stage_labels=False,\n        add_background_image=\"https://raw.githubusercontent.com/Bergam0t/vidigi/refs/heads/main/examples/example_1_simplest_case/Simplest%20Model%20Background%20Image%20-%20Horizontal%20Layout.drawio.png\",\n    )\n\nAnimation function called at 14:39:54\nIteration through time-unit-by-time-unit logs complete 14:39:57\nSnapshot df concatenation complete at 14:39:57\nReshaped animation dataframe finished construction at 14:39:57\nPlacement dataframe finished construction at 14:39:57\nOutput animation generation complete at 14:40:00\nTotal Time Elapsed: 5.62 seconds",
    "crumbs": [
      "SimPy Examples",
      "A Simple Animation of a One-step SimPy Model"
    ]
  },
  {
    "objectID": "examples/example_13_additional_synchronised_traces_method_1/synchronised_traces.html",
    "href": "examples/example_13_additional_synchronised_traces_method_1/synchronised_traces.html",
    "title": "Additional Synchronised Traces - Orthopaedic Ward - Hospital Efficiency Project",
    "section": "",
    "text": "This is the orthopaedic surgery model developed as part of the hospital efficiency project.\noriginal model author = Harper, Alison and Monks, Thomas\nlicense = MIT\ntitle = Hospital Efficiency Project Orthopaedic Planning Model Discrete-Event Simulation\nurl = https://github.com/AliHarp/HEP\nIt has been used as a test case here to allow the development and testing of several key features of the event log animations:\n\nadding of logging to a model from scratch\nensuring the requirement to use simpy stores instead of simpy resources doesn’t prevent the uses of certain common modelling patterns (in this case, conditional logic where patients will leave the system if a bed is not available within a specified period of time)\ndisplaying different icons for different classes of patients\ndisplaying custom resource icons\ndisplaying additional static information as part of the icon (in this case, whether the client’s discharge is delayed)\ndisplaying information that updates with each animation step as part of the icon (in this case, the LoS of the patient at each time point)\n\n\nimport time\nimport pandas as pd\nimport plotly.express as px\nimport plotly.graph_objects as go\nfrom examples.example_13_additional_synchronised_traces_method_1.simulation_execution_functions import multiple_replications\nfrom examples.example_13_additional_synchronised_traces_method_1.model_classes import Scenario, Schedule\nfrom vidigi.prep import reshape_for_animations, generate_animation_df\nfrom vidigi.animation import generate_animation\nfrom plotly.subplots import make_subplots\n\nTRACE = True\ndebug_mode=True\n\nschedule = Schedule()\n\n4 theatres\n5 day/week\nEach theatre has three sessions per day:\nMorning: 1 revision OR 2 primary\nAfternoon: 1 revision OR 2 primary\nEvening: 1 primary\n40 ring-fenced beds for recovery from these operations\n\n(pd.DataFrame.from_dict(schedule.sessions_per_weekday, orient=\"index\")\n        .rename(columns={0: \"Sessions\"}).merge(\n\n        pd.DataFrame.from_dict(schedule.theatres_per_weekday, orient=\"index\")\n            .rename(columns={0: \"Theatre Capacity\"}),\n            left_index=True, right_index=True\n\n        ).merge(\n\n        pd.DataFrame.from_dict(schedule.allocation, orient=\"index\"),\n        left_index=True, right_index=True\n\n        ))\n\n\n\n\n\n\n\n\nSessions\nTheatre Capacity\n0\n1\n2\n\n\n\n\nMonday\n3\n4\n2P_or_1R\n2P_or_1R\n1P\n\n\nTuesday\n3\n4\n2P_or_1R\n2P_or_1R\n1P\n\n\nWednesday\n3\n4\n2P_or_1R\n2P_or_1R\n1P\n\n\nThursday\n3\n4\n2P_or_1R\n2P_or_1R\n1P\n\n\nFriday\n3\n4\n2P_or_1R\n2P_or_1R\n1P\n\n\nSaturday\n0\n0\nNone\nNone\nNone\n\n\nSunday\n0\n0\nNone\nNone\nNone\n\n\n\n\n\n\n\n\nn_beds = 40\n\nprimary_hip_los = 4.4\n\nprimary_knee_los = 4.7\n\nrevision_hip_los = 6.9\n\nrevision_knee_los = 7.2\n\nunicompart_knee_los = 2.9\n\nlos_delay = 16.5\nlos_delay_sd = 15.2\n\nprop_delay = 0.076\n\nreplications = 30\nruntime = 60\nwarmup=7\n\nargs = Scenario(schedule=schedule,\n                primary_hip_mean_los=primary_hip_los,\n                primary_knee_mean_los=primary_knee_los,\n                revision_hip_mean_los=revision_hip_los,\n                revision_knee_mean_los=revision_knee_los,\n                unicompart_knee_mean_los=unicompart_knee_los,\n                prob_ward_delay=prop_delay,\n                n_beds=n_beds,\n                delay_post_los_mean=los_delay,\n                delay_post_los_sd=los_delay_sd\n                )\n\n\nresults = multiple_replications(\n                return_detailed_logs=True,\n                scenario=args,\n                n_reps=replications,\n                results_collection=runtime\n            )\n\n\n\n\n# Join the event log with a list of patients to add a column that will determine\n# the icon set used for a patient (in this case, we want to distinguish between the\n# knee/hip patients)\nevent_log = results[4]\nevent_log = event_log[event_log['rep'] == 1]\nevent_log['patient'] = event_log['patient'].astype('str') + event_log['pathway']\n\nprimary_patients = results[2]\nprimary_patients = primary_patients[primary_patients['rep'] == 1]\nprimary_patients['patient class'] = primary_patients['patient class'].str.title()\nprimary_patients['ID'] = primary_patients['ID'].astype('str') + primary_patients['patient class']\n\nrevision_patients = results[3]\nrevision_patients = revision_patients[revision_patients['rep'] == 1]\nrevision_patients['patient class'] = revision_patients['patient class'].str.title()\nrevision_patients['ID'] = revision_patients['ID'].astype('str') + revision_patients['patient class']\n\nfull_log_with_patient_details = event_log.merge(pd.concat([primary_patients, revision_patients]),\n                                                    how=\"left\",\n                                                left_on=[\"patient\", \"pathway\"],\n                                                right_on=[\"ID\", \"patient class\"]).reset_index(drop=True).drop(columns=\"ID\")\n\npid_table = full_log_with_patient_details[['patient']].drop_duplicates().reset_index(drop=True).reset_index(drop=False).rename(columns={'index': 'pid'})\n\nfull_log_with_patient_details = full_log_with_patient_details.merge(pid_table, how='left', on='patient').drop(columns='patient').rename(columns={'pid':'patient'})\n\nC:\\Users\\Sammi\\AppData\\Local\\Temp\\ipykernel_50528\\3505082114.py:50: SettingWithCopyWarning:\n\n\nA value is trying to be set on a copy of a slice from a DataFrame.\nTry using .loc[row_indexer,col_indexer] = value instead\n\nSee the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n\nC:\\Users\\Sammi\\AppData\\Local\\Temp\\ipykernel_50528\\3505082114.py:54: SettingWithCopyWarning:\n\n\nA value is trying to be set on a copy of a slice from a DataFrame.\nTry using .loc[row_indexer,col_indexer] = value instead\n\nSee the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n\nC:\\Users\\Sammi\\AppData\\Local\\Temp\\ipykernel_50528\\3505082114.py:55: SettingWithCopyWarning:\n\n\nA value is trying to be set on a copy of a slice from a DataFrame.\nTry using .loc[row_indexer,col_indexer] = value instead\n\nSee the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n\nC:\\Users\\Sammi\\AppData\\Local\\Temp\\ipykernel_50528\\3505082114.py:59: SettingWithCopyWarning:\n\n\nA value is trying to be set on a copy of a slice from a DataFrame.\nTry using .loc[row_indexer,col_indexer] = value instead\n\nSee the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n\nC:\\Users\\Sammi\\AppData\\Local\\Temp\\ipykernel_50528\\3505082114.py:60: SettingWithCopyWarning:\n\n\nA value is trying to be set on a copy of a slice from a DataFrame.\nTry using .loc[row_indexer,col_indexer] = value instead\n\nSee the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n\n\n\n\n\nevent_position_df = pd.DataFrame([\n            # {'event': 'arrival', 'x':  10, 'y': 250, 'label': \"Arrival\" },\n\n            # Triage - minor and trauma\n            {'event': 'enter_queue_for_bed',\n                'x':  300, 'y': 625, 'label': \"Waiting for&lt;br&gt;Availability of&lt;br&gt;Bed to be Confirmed&lt;br&gt;Before Surgery\" },\n\n            {'event': 'no_bed_available',\n                'x':  700, 'y': 625, 'label': \"No Bed&lt;br&gt;Available:&lt;br&gt;Surgery Cancelled\" },\n\n            {'event': 'post_surgery_stay_begins',\n                'x':  750, 'y': 220, 'resource':'n_beds', 'label': \"In Bed:&lt;br&gt;Recovering from&lt;br&gt;Surgery\" },\n\n            {'event': 'discharged_after_stay',\n                'x':  770, 'y': 50, 'label': \"Discharged from Hospital&lt;br&gt;After Recovery\"}\n            # {'event': 'exit',\n            #  'x':  670, 'y': 100, 'label': \"Exit\"}\n\n            ])\n\n\nfull_patient_df = reshape_for_animations(full_log_with_patient_details,\n                                         entity_col_name=\"patient\",\n                                            every_x_time_units=1,\n                                            limit_duration=runtime,\n                                            step_snapshot_max=50,\n                                            debug_mode=debug_mode\n                                            )\n\nif debug_mode:\n    print(f'Reshaped animation dataframe finished construction at {time.strftime(\"%H:%M:%S\", time.localtime())}')\n\nIteration through time-unit-by-time-unit logs complete 13:21:53\nSnapshot df concatenation complete at 13:21:53\nReshaped animation dataframe finished construction at 13:21:53\n\n\n\nfull_patient_df_plus_pos = generate_animation_df(\n                            full_entity_df=full_patient_df,\n                            entity_col_name=\"patient\",\n                            event_position_df=event_position_df,\n                            wrap_queues_at=20,\n                            wrap_resources_at=40,\n                            step_snapshot_max=50,\n                            gap_between_entities=20,\n                            gap_between_resources=20,\n                            gap_between_queue_rows=175,\n                            gap_between_resource_rows=175,\n                            debug_mode=debug_mode\n                    )\n\nPlacement dataframe finished construction at 13:21:54\n\n\n\ndef set_icon(row):\n    if row[\"surgery type\"] == \"p_knee\":\n        return \"🦵&lt;br&gt;1️⃣&lt;br&gt; \"\n    elif row[\"surgery type\"] == \"r_knee\":\n        return \"🦵&lt;br&gt;♻️&lt;br&gt; \"\n    elif row[\"surgery type\"] == \"p_hip\":\n        return \"🕺&lt;br&gt;1️⃣&lt;br&gt; \"\n    elif row[\"surgery type\"] == \"r_hip\":\n        return \"🕺&lt;br&gt;♻️&lt;br&gt; \"\n    elif row[\"surgery type\"] == \"uni_knee\":\n        return \"🦵&lt;br&gt;✳️&lt;br&gt; \"\n    else:\n        return f\"CHECK&lt;br&gt;{row['icon']}\"\n\nfull_patient_df_plus_pos = full_patient_df_plus_pos.assign(icon=full_patient_df_plus_pos.apply(set_icon, axis=1))\n\n# TODO: Check why this doesn't seem to be working quite right for the 'discharged after stay'\n# step. e.g. 194Primary is discharged on 28th July showing a LOS of 1 but prior to this shows a LOS of 9.\ndef add_los_to_icon(row):\n    if row[\"event\"] == \"post_surgery_stay_begins\":\n        return f'{row[\"icon\"]}&lt;br&gt;&lt;br&gt;{row[\"snapshot_time\"]-row[\"time\"]:.0f}'\n    elif row[\"event\"] == \"discharged_after_stay\":\n        return f'{row[\"icon\"]}&lt;br&gt;{row[\"los\"]:.0f}'\n    else:\n        return row[\"icon\"]\n\nfull_patient_df_plus_pos = full_patient_df_plus_pos.assign(icon=full_patient_df_plus_pos.apply(add_los_to_icon, axis=1))\n\n\ndef indicate_delay_via_icon(row):\n    if row[\"delayed discharge\"] is True:\n        return f'{row[\"icon\"]}&lt;br&gt;*'\n    else:\n        return f'{row[\"icon\"]}&lt;br&gt; '\n\nfull_patient_df_plus_pos = full_patient_df_plus_pos.assign(icon=full_patient_df_plus_pos.apply(indicate_delay_via_icon, axis=1))\n\ncancelled_due_to_no_bed_available = len(full_log_with_patient_details[full_log_with_patient_details['event'] == \"no_bed_available\"][\"patient\"].unique())\ntotal_patients = len(full_log_with_patient_details[\"patient\"].unique())\n\ncancelled_perc = cancelled_due_to_no_bed_available/total_patients\n\n# st.markdown(f\"Surgeries cancelled due to no bed being available in time: {cancelled_perc:.2%} ({cancelled_due_to_no_bed_available} of {total_patients})\")\n\n# st.markdown(\n#     \"\"\"\n#     **Key**:\n\n#     🦵1️⃣: Primary Knee\n\n#     🦵♻️: Revision Knee\n\n#     🕺1️⃣: Primary Hip\n\n#     🕺♻️: Revision Hip\n\n#     🦵✳️: Primary Unicompartment Knee\n\n#     An asterisk (*) indicates that the patient has a delayed discharge from the ward.\n\n#     The numbers below patients indicate their length of stay.\n\n#     Note that the \"No Bed Available: Surgery Cancelled\" and \"Discharged from Hospital after Recovery\" stages in the animation are lagged by one day.\n#     For example, on the 2nd of July, this will show the patients who had their surgery cancelled on 1st July or were discharged on 1st July.\n#     These steps are included to make it easier to understand the destinations of different clients, but due to the size of the simulation step shown (1 day) it is difficult to demonstrate this differently.\n#     \"\"\"\n# )\n\n\ncounts_not_avail = full_patient_df_plus_pos[full_patient_df_plus_pos['event']=='no_bed_available'][['snapshot_time','patient']].groupby('snapshot_time').agg('count')\ncounts_not_avail = counts_not_avail.reset_index().merge(full_patient_df_plus_pos[['snapshot_time']].drop_duplicates(), how='right').sort_values('snapshot_time')\ncounts_not_avail['patient'] = counts_not_avail['patient'].fillna(0)\ncounts_not_avail['running_total'] = counts_not_avail['patient'].cumsum()\n\ncounts_not_avail = counts_not_avail.reset_index(drop=True)\n\ncounts_not_avail\n\n\n\n\n\n\n\n\nsnapshot_time\npatient\nrunning_total\n\n\n\n\n0\n0\n0.0\n0.0\n\n\n1\n1\n0.0\n0.0\n\n\n2\n2\n0.0\n0.0\n\n\n3\n3\n5.0\n5.0\n\n\n4\n4\n5.0\n10.0\n\n\n...\n...\n...\n...\n\n\n56\n56\n0.0\n244.0\n\n\n57\n57\n0.0\n244.0\n\n\n58\n58\n8.0\n252.0\n\n\n59\n59\n2.0\n254.0\n\n\n60\n60\n11.0\n265.0\n\n\n\n\n61 rows × 3 columns\n\n\n\n\n\ncounts_ops_completed = full_patient_df_plus_pos[full_patient_df_plus_pos['event']=='post_surgery_stay_begins'][['snapshot_time','patient']].drop_duplicates('patient').groupby('snapshot_time').agg('count')\ncounts_ops_completed = counts_ops_completed.reset_index().merge(full_patient_df_plus_pos[['snapshot_time']].drop_duplicates(), how='right').sort_values('snapshot_time')\ncounts_ops_completed['patient'] = counts_ops_completed['patient'].fillna(0)\ncounts_ops_completed['running_total'] = counts_ops_completed['patient'].cumsum()\n\ncounts_ops_completed = counts_ops_completed.reset_index(drop=True)\n\ncounts_ops_completed\n\n\n\n\n\n\n\n\nsnapshot_time\npatient\nrunning_total\n\n\n\n\n0\n0\n16.0\n16.0\n\n\n1\n1\n16.0\n32.0\n\n\n2\n2\n9.0\n41.0\n\n\n3\n3\n4.0\n45.0\n\n\n4\n4\n10.0\n55.0\n\n\n...\n...\n...\n...\n\n\n56\n56\n12.0\n390.0\n\n\n57\n57\n5.0\n395.0\n\n\n58\n58\n6.0\n401.0\n\n\n59\n59\n13.0\n414.0\n\n\n60\n60\n4.0\n418.0\n\n\n\n\n61 rows × 3 columns\n\n\n\n\ncounts_not_avail = counts_not_avail.merge(counts_ops_completed.rename(columns={'running_total':'completed'}), how=\"left\", on=\"snapshot_time\")\ncounts_not_avail['perc_slots_lost'] = counts_not_avail['running_total'] / (counts_not_avail['running_total'] + counts_not_avail['completed'])\n\ncounts_not_avail = counts_not_avail.reset_index(drop=True)\n\ncounts_not_avail\n\n\n\n\n\n\n\n\nsnapshot_time\npatient_x\nrunning_total\npatient_y\ncompleted\nperc_slots_lost\n\n\n\n\n0\n0\n0.0\n0.0\n16.0\n16.0\n0.000000\n\n\n1\n1\n0.0\n0.0\n16.0\n32.0\n0.000000\n\n\n2\n2\n0.0\n0.0\n9.0\n41.0\n0.000000\n\n\n3\n3\n5.0\n5.0\n4.0\n45.0\n0.100000\n\n\n4\n4\n5.0\n10.0\n10.0\n55.0\n0.153846\n\n\n...\n...\n...\n...\n...\n...\n...\n\n\n56\n56\n0.0\n244.0\n12.0\n390.0\n0.384858\n\n\n57\n57\n0.0\n244.0\n5.0\n395.0\n0.381847\n\n\n58\n58\n8.0\n252.0\n6.0\n401.0\n0.385911\n\n\n59\n59\n2.0\n254.0\n13.0\n414.0\n0.380240\n\n\n60\n60\n11.0\n265.0\n4.0\n418.0\n0.387994\n\n\n\n\n61 rows × 6 columns\n\n\n\n\nfig = generate_animation(\n        full_entity_df_plus_pos=full_patient_df_plus_pos,\n        entity_col_name=\"patient\",\n        event_position_df=event_position_df,\n        scenario=args,\n        plotly_height=950,\n        plotly_width=1400,\n        override_x_max=1000,\n        override_y_max=700,\n        entity_icon_size=14,\n        text_size=14,\n        wrap_resources_at=40,\n        gap_between_resources=20,\n        include_play_button=True,\n        add_background_image=None,\n        # we want the stage labels, but due to a bug\n        # when we add in additional animated traces later,\n        # they will disappear - so better to leave them out here\n        # and then re-add them manually\n        display_stage_labels=True,\n        custom_resource_icon=\"🛏️\",\n        time_display_units=\"d\",\n        simulation_time_unit=\"days\",\n        start_date=\"2022-06-27\",\n        setup_mode=False,\n        frame_duration=1500, #milliseconds\n        frame_transition_duration=1000, #milliseconds\n        debug_mode=False\n    )\n\nfig\n\nUnable to display output for mime type(s): application/vnd.plotly.v1+json\n\n\n\n# Set up the desired subplot layout\nROWS = 4\n\nsp = make_subplots(\n    rows=ROWS,\n    cols=1,\n    row_heights=[0.75, 0.05, 0.05, 0.15],\n    vertical_spacing=0.05,\n    subplot_titles=(\n        \"\", # Original Animation\n        \"\", # Completed Operations\n        \"\", # Lost Slot Cumulative Counts\n        \"\" # Daily Lost Slots Plot\n        )\n    )\n\n# Overwrite the domain of our original x and y axis with domain from the new axis\nfig.layout['xaxis']['domain'] = sp.layout['xaxis']['domain']\nfig.layout['yaxis']['domain'] = sp.layout['yaxis']['domain']\n\nfor i in range(2, ROWS+1):\n\n    # Add in the attributes for the secondary axis from our subplot\n    fig.layout[f'xaxis{i}'] = sp.layout[f'xaxis{i}']\n    fig.layout[f'yaxis{i}'] = sp.layout[f'yaxis{i}']\n\n# Final key step - copy over the _grid_ref attribute\n# This isn't meant to be something we modify but it's an essential\n# part of the subplot code because otherwise plotly doesn't truly know\n# how the different subplots are arranged and referenced\nfig._grid_ref = sp._grid_ref\n\nfig.update_layout(\n    xaxis2=dict(\n        showgrid=False,\n        zeroline=False,\n        showline=False,\n        showticklabels=False,\n    ),\n    yaxis2=dict(\n        showgrid=False,\n        zeroline=False,\n        showline=False,\n        showticklabels=False,\n    ),\n    xaxis3=dict(\n        showgrid=False,\n        zeroline=False,\n        showline=False,\n        showticklabels=False,\n    ),\n    yaxis3=dict(\n        showgrid=False,\n        zeroline=False,\n        showline=False,\n        showticklabels=False,\n    ),\n    xaxis4=dict(\n        showticklabels=False\n    )\n)\n\nUnable to display output for mime type(s): application/vnd.plotly.v1+json\n\n\n\nprint(len(fig.data))\n\n3\n\n\n\n#####################################################\n# Adding additional animation traces\n#####################################################\n\n#####################################################\n# Initialize static and animated traces\n#####################################################\n\n## First, add each trace so it will show up initially\n\n# Plotly requires that all traces that will appear in animation frames are first\n# defined in `fig.data`. Otherwise, they appear to \"fly in\" from undefined positions,\n# or exhibit flickering due to missing interpolation references.\n\n# We add each trace in order, with placeholder data and correct styling,\n# so the animation engine has full knowledge of the traces from the outset.\n\n# Due to issues detailed in the following SO threads, it's essential to initialize the traces\n# outside of the frames argument else they will not show up at all (or show up intermittently)\n# https://stackoverflow.com/questions/69867334/multiple-traces-per-animation-frame-in-plotly\n# https://stackoverflow.com/questions/69367344/plotly-animating-a-variable-number-of-traces-in-each-frame-in-r\n# TODO: More explanation and investigation needed of why sometimes traces do and don't show up after being added in\n# via this method. Behaviour seems very inconsistent and not always logical (e.g. order you put traces in to the later\n# loop sometimes seems to make a difference but sometimes doesn't; making initial trace transparent sometimes seems to\n# stop it showing up when added in the frames but not always; sometimes the initial trace doesn't disappear).\n\n# First, extract the trace containing the resource icons\nposition_label_trace = fig.data[1]\nicon_trace = fig.data[2]\n\n# Now keep our figure data as just the initial trace.\nfig.data = (fig.data[0],)\n\n# 1. BED ICONS TRACE\n# Readd the bed icons trace in a consistent manner\n# Confusingly, when we start messing with the naimation frames, we lose the bed/resource icon trace\n# even though it appeared fine until this point - so we have to handle it here\nfig.add_trace(icon_trace)\n\nprint(f\"Length after adding bed trace: {len(fig.data)}\")\n\n# 2. EVENT LABELS (static position text, but added dynamically per frame to avoid disappearing)\n# This is a similar thing to the fig labels - except we never added them in the first place!\n# Add trace for the event labels (as these get lost from the animation once we start trying to add other things in,\n# so need manually re-adding)\n# fig.add_trace(go.Scatter(\n#         x=[pos+10 for pos in event_position_df['x'].to_list()],\n#         y=event_position_df['y'].to_list(),\n#         mode=\"text\",\n#         name=\"\",\n#         text=event_position_df['label'].to_list(),\n#         textposition=\"middle right\",\n#         hoverinfo='none'\n#     ))\n\nfig.add_trace(position_label_trace)\n\n# Finally, match the font size for the position labels\nfig.data[-1].textfont.size\n\nprint(f\"Length after adding 'position labels:' trace: {len(fig.data)}\")\n\n# 3. OPERATIONS COMPLETED TEXT (animated text annotation)\n# Add animated text trace that gives running total of operations completed\nfig.add_trace(go.Scatter(\n                x=[5],\n                y=[10],\n                # text=\"\",\n                text=f\"Operations Completed: {int(counts_ops_completed['running_total'][0])}\",\n                mode='text',\n                textposition=\"middle left\",\n                textfont=dict(size=20),\n                # opacity=0,\n                showlegend=False,\n                xaxis=\"x2\",\n                yaxis=\"y2\"\n        ), row=2, col=1)\n\nprint(f\"Length after adding 'operations completed:' trace: {len(fig.data)}\")\n\n# 4. SLOTS LOST TEXT (animated text annotation)\n# Add animated trace giving running total of slots lost and percentage of total slots this represents\nfig.add_trace(go.Scatter(\n    x=[5],\n    y=[10],\n    # text=\"\",\n    text=f\"Total slots lost: {int(counts_not_avail['running_total'][0])} ({counts_not_avail['perc_slots_lost'][0]:.1%})\",\n    mode='text',\n    textfont=dict(size=20),\n    # opacity=0,\n    showlegend=False,\n    textposition=\"middle left\",\n    xaxis=\"x3\",\n    yaxis=\"y3\"\n), row=3, col=1)\n\nprint(f\"Length after adding 'slots lost:' trace: {len(fig.data)}\")\n\n\n# # 5. LINE PLOT ON SECONDARY AXIS (animated line in subplot)\n# Initialize with a single point and assign it to subplot axes (x2/y2)\nfig.add_trace(go.Scatter(\n    x=[counts_not_avail['snapshot_time'].iloc[0]],\n    y=[counts_not_avail['patient_x'].iloc[0]],\n    mode=\"lines\",\n    line=dict(color=\"rgba(255,0,0,1)\"),  # semi-transparent initial\n    showlegend=False,\n    name=\"slots_lost_line\",\n    xaxis=\"x4\",\n    yaxis=\"y4\"\n    # We place it in our new subplot using the following line\n), row=4, col=1)\n\n\n# Add an initial trace to our secondary line chart\nfig.add_trace(go.Scatter(\n    x=counts_not_avail['snapshot_time'],\n    y=counts_not_avail['patient_x'],\n    mode='lines',\n    showlegend=False,\n    # name='line',\n    opacity=0.2,\n    xaxis=\"x4\",\n    yaxis=\"y4\"\n    # We place it in our new subplot using the following line\n), row=4, col=1)\n\nprint(f\"Length after adding additional line plot trace: {len(fig.data)}\")\n\nLength after adding bed trace: 2\nLength after adding 'position labels:' trace: 3\nLength after adding 'operations completed:' trace: 4\nLength after adding 'slots lost:' trace: 5\nLength after adding additional line plot trace: 7\n\n\n\n\n##########################################################\n# Define animation frames: one per simulation time step\n##########################################################\n\n##########################################################\n# Now we need to add our traces to each individual frame\n##########################################################\n# IMPORTANT: To work correctly, these need to be provided in the same order as the traces above\n\n# This includes:\n# 0: bed icons\n# 1: event labels\n# 2: operations completed text\n# 3: slots lost text\n# 4: time series line in subplot\n\n# # Now ensure we tell it which traces we are animating\n# # (as per https://chart-studio.plotly.com/~empet/15243/animating-traces-in-subplotsbr/#/)\nfor i, frame in enumerate(fig.frames):\n    # Your original frame.data\n    # This will be a tuple\n    # We'll ensure we only take the first entry\n    # original_data = (frame.data[0], )\n\n    original_data = frame.data\n\n    # if i == 5:\n    #     print(original_data)\n\n    # The new data you want to add for this specific frame\n    new_data = (\n        # 0: bed icons\n        icon_trace,\n\n        # 1: Position labels\n        go.Scatter(\n            x=[pos+10 for pos in event_position_df['x'].to_list()],\n            y=event_position_df['y'].to_list(),\n            mode=\"text\",\n            text=event_position_df['label'].to_list(),\n            textposition=\"middle right\",\n            hoverinfo='none',\n            showlegend=False,\n        ),\n\n        # 2: Slots used/operations occurred\n        go.Scatter(\n            x=[5],\n            y=[10],\n            text=f\"Operations Completed: {int(counts_ops_completed.sort_values('snapshot_time')['running_total'][i])}\",\n            mode='text',\n            textposition=\"middle left\",\n            textfont=dict(size=20),\n            showlegend=False,\n            xaxis='x2',\n            yaxis='y2'\n        ),\n\n        # 3: Slots lost\n        go.Scatter(\n            x=[5],\n            y=[10],\n            text=f\"Total slots lost: {int(counts_not_avail.sort_values('snapshot_time')['running_total'][i])} ({counts_not_avail.sort_values('snapshot_time')['perc_slots_lost'][i]:.1%})\",\n            mode='text',\n            textfont=dict(size=20),\n            textposition=\"middle left\",\n            showlegend=False,\n            xaxis='x3',\n            yaxis='y3'\n        ),\n\n        # 4: Line subplot\n        go.Scatter(\n            x=counts_not_avail.sort_values('snapshot_time')['snapshot_time'][0: i+1].values,\n            y=counts_not_avail.sort_values('snapshot_time')['patient_x'][0: i+1].values,\n            mode=\"lines\",\n            showlegend=False,\n            name=\"line_subplot\",\n            line=dict(color=\"rgba(255,0,0,1)\"),  # semi-transparent initial\n            xaxis='x4',\n            yaxis='y4'\n        ),\n    )\n\n    # print(f\"Type of new data: {type(new_data)}\")\n\n    # Combine the original frame data with your new data\n    frame.data = original_data + new_data\n\n    # if i == 5:\n    #     print(frame.data)\n\n    # print(f\"Type of final frame data: {type(frame.data)}\")\n\n# Finally, match the font size for the position labels\nfig.data[2].textfont.size\n\nfig\n\nUnable to display output for mime type(s): application/vnd.plotly.v1+json\n\n\n\n# After modifying the data in all frames, now correctly set the 'traces' property.\n\n# Get the total number of animated traces from the first (now updated) frame.\nnum_total_traces = len(fig.frames[0].data)\n\n# Create the list of indices that all traces will be mapped to.\n# This should be [0, 1, 2, ..., n-1] where n is the total number of animated traces.\ntrace_indices = list(range(num_total_traces))\n\n# Apply this correct list of indices to every frame.\nfor frame in fig.frames:\n    frame.traces = trace_indices\n\n\nfig\n\nUnable to display output for mime type(s): application/vnd.plotly.v1+json",
    "crumbs": [
      "SimPy Examples",
      "Additional Synchronised Traces - Orthopaedic Ward - Hospital Efficiency Project"
    ]
  },
  {
    "objectID": "examples/example_12_resourceless_with_back_and_forth/ex_12_resourceless_advanced.html",
    "href": "examples/example_12_resourceless_with_back_and_forth/ex_12_resourceless_advanced.html",
    "title": "More Resourceless Queues - Community Service Repeat Appointment Booking Model with Variable Follow-ups",
    "section": "",
    "text": "import math\n# Packages for data manipulation\nimport numpy as np\nimport pandas as pd\n# Packages for graphing\nimport plotly.express as px\nimport plotly.graph_objects as go\nfrom plotly.subplots import make_subplots\n# Model functions\nfrom examples.example_12_resourceless_with_back_and_forth.model_classes import Scenario, generate_seed_vector\nfrom examples.example_12_resourceless_with_back_and_forth.simulation_execution_functions import single_run\n# Animation functions\nfrom vidigi.prep import reshape_for_animations, generate_animation_df\nfrom vidigi.animation import generate_animation\nThis model is designed to mimic a simple community-based appointment service where clients have an initial appointment and then a variable number of follow-ups over an extended period of time.\nA client can have their first referral with any clinician - in practice, whoever has capacity and the soonest appointment - but all follow-on appointments will be with the same clinician.\nInstead of using simpy resources, an appointment book is set up. The model looks for an appointment that meets criteria, then books this in, reducing the available slots as appropriate. This allows for continuity of care in a way that is more difficult to achieve with a simpy resource, as well as allowing finer control over the number of appointments a clinician can undertake in a day.\nNote that some issues seem to be present with the caseload calculations, leading to some unexpected behaviour within the model over time.\nThe default is to aim to have as many people on caseload as you have maximum theoretical slots. This can be adjusted up or down to see the impact of changing the policy.\nNote that low intensity patients in this model take up 0.5 slots. High intensity patients take up 1 slot.\nnumber_of_clinicians = 8\n\nCASELOAD_TARGET_MULTIPLIER = 1.3\n\n# caseload_default_adjusted = pd.concat(\n#             [shifts.sum(),\n#             np.floor(shifts.sum() * CASELOAD_TARGET_MULTIPLIER)],\n#             axis=1\n#             )\n\n# caseload_default_adjusted.columns = [\"Default Caseload (Total Slots Per Week)\",\n#                                         \"Adjusted Caseload\"]\n\nANNUAL_DEMAND = 700\n\nPROP_HIGH_PRIORITY = 0.03\n\nWARM_UP = 60\n\nRESULTS_COLLECTION = 180\n\nRUN_LENGTH = RESULTS_COLLECTION + WARM_UP\n\nPROP_REFERRED_OUT = 0.12\n\nSEED = 42\n\nPROP_HIGH_PRIORITY_ONGOING_APPOINTMENTS = 0.95\n\nPROP_LOW_PRIORITY_ONGOING_APPOINTMENTS = 0.8\n\n# What proportion of people initially graded as *high*\n# priority go on to have high intensity therapy?\nPROP_HIGH_PRIORITY_HIGH_INTENSITY = 0.7\n# What proportion of people initially graded as *low*\n# priority go on to have high intensity therapy?\nPROP_LOW_PRIORITY_HIGH_INTENSITY = 0.2\n\nMEAN_FOLLOW_UPS_HIGH_INTENSITY = 10\nMEAN_FOLLOW_UPS_LOW_INTENSITY = 6\n\nSD_FOLLOW_UPS_HIGH_INTENSITY = 18\nSD_FOLLOW_UPS_HIGH_INTENSITY = SD_FOLLOW_UPS_HIGH_INTENSITY/3\nSD_FOLLOW_UPS_LOW_INTENSITY = 9\nSD_FOLLOW_UPS_LOW_INTENSITY = SD_FOLLOW_UPS_LOW_INTENSITY/3\n\nscenarios = {}\nWe define the parameters of the clinics in csv files.\nshifts = (pd.read_csv(\"data/shifts.csv\")\n           .iloc[:,:number_of_clinicians])\n\nshifts\n\n\n\n\n\n\n\n\nclinic_1\nclinic_2\nclinic_3\nclinic_4\nclinic_5\nclinic_6\nclinic_7\nclinic_8\n\n\n\n\n0\n0\n5\n4\n4\n0\n5\n3\n3\n\n\n1\n0\n3\n5\n4\n5\n5\n3\n3\n\n\n2\n4\n3\n5\n5\n3\n5\n4\n3\n\n\n3\n4\n5\n2\n1\n5\n5\n3\n3\n\n\n4\n4\n0\n1\n0\n5\n4\n3\n1\n\n\n5\n5\n0\n0\n0\n3\n0\n0\n0\n\n\n6\n0\n5\n0\n3\n0\n0\n0\n0\ncaseload = (pd.read_csv(\"data/caseload.csv\")\n            .iloc[:,:number_of_clinicians+1])\n\ncaseload\n\n\n\n\n\n\n\n\nUnnamed: 0\nclinic_1\nclinic_2\nclinic_3\nclinic_4\nclinic_5\nclinic_6\nclinic_7\nclinic_8\n\n\n\n\n0\ncurrent_caseload\n0\n0\n0\n0\n0\n0\n0\n0\nreferrals = (pd.read_csv(\"data/referrals.csv\")\n                .iloc[:number_of_clinicians])\n\nreferrals\n\n\n\n\n\n\n\n\nclinic\nprop\nreferred_out\ndna\n\n\n\n\n0\n1\n1.0\n0.120\n0.20\n\n\n1\n2\n0.0\n0.428\n0.25\n\n\n2\n3\n0.0\n0.489\n0.25\n\n\n3\n4\n0.0\n0.296\n0.20\n\n\n4\n5\n0.0\n0.275\n0.23\n\n\n5\n6\n0.0\n0.091\n0.21\n\n\n6\n7\n0.0\n0.162\n0.24\n\n\n7\n8\n0.0\n0.129\n0.17\npooling = (pd.read_csv(\"data/partial_pooling.csv\")\n            .iloc[:number_of_clinicians,:number_of_clinicians+1])\n\n\n\nscenarios['pooled'] = Scenario(RUN_LENGTH,\n                                       WARM_UP,\n                                      #  prop_carve_out=prop_carve_out,\n                                       seeds=generate_seed_vector(SEED),\n                                       slots_file=shifts,\n                                       pooling_file=pooling,\n                                       existing_caseload_file=caseload,\n                                       demand_file=referrals,\n                                       caseload_multiplier=CASELOAD_TARGET_MULTIPLIER,\n                                       prop_high_priority=PROP_HIGH_PRIORITY,\n                                       prop_high_priority_ongoing_appointments=PROP_HIGH_PRIORITY_ONGOING_APPOINTMENTS,\n                                       prop_low_priority_ongoing_appointments=PROP_LOW_PRIORITY_ONGOING_APPOINTMENTS,\n                                       prop_high_priority_assessed_high_intensity=PROP_HIGH_PRIORITY_HIGH_INTENSITY,\n                                       prop_low_priority_assessed_high_intensity=PROP_LOW_PRIORITY_HIGH_INTENSITY,\n                                       mean_follow_ups_high_intensity=MEAN_FOLLOW_UPS_HIGH_INTENSITY,\n                                       sd_follow_ups_high_intensity=SD_FOLLOW_UPS_HIGH_INTENSITY,\n                                       mean_follow_ups_low_intensity=MEAN_FOLLOW_UPS_LOW_INTENSITY,\n                                       sd_follow_ups_low_intensity=SD_FOLLOW_UPS_LOW_INTENSITY,\n                                       annual_demand=ANNUAL_DEMAND,\n                                       prop_referred_out=PROP_REFERRED_OUT)\n# Run the model and unpack the outputs\nresults_all, results_low, results_high, event_log, \\\nbookings, available_slots, daily_caseload_snapshots, \\\ndaily_waiting_for_booking_snapshots, \\\ndaily_arrivals = single_run(args = scenarios['pooled'])\nevent_log_df = pd.DataFrame(event_log)\n\nevent_log_df['event_original'] = event_log_df['event']\nevent_log_df['event'] = event_log_df.apply(\n    lambda x: f\"{x['event']}{f'_{int(x.booked_clinic)}'if pd.notna(x['booked_clinic']) and x['event'] != 'waiting_appointment_to_be_scheduled' else ''}\",\n    axis=1\n    )\n\nfull_patient_df = reshape_for_animations(event_log_df,\n                                         entity_col_name=\"patient\",\n                                            limit_duration=WARM_UP+RESULTS_COLLECTION,\n                                            every_x_time_units=1,\n                                            step_snapshot_max=30)\n\n# Remove the warm-up period from the event log\nfull_patient_df = full_patient_df[full_patient_df[\"snapshot_time\"] &gt;= WARM_UP]\nWe will automatically create a reasonable positioning dataframe that reflects the number of available clinicians.\n#####################################################\n# Create the positioning dataframe for the animation\n#####################################################\n\n# Create a list of clinics\nclinics =  [x for x\n            in event_log_df['booked_clinic'].sort_values().unique().tolist()\n            if not math.isnan(x)]\n\n# Create a column of positions for people waiting for their initial appointment with the clinic\nclinic_waits = [{'event': f'appointment_booked_waiting_{int(clinic)}',\n    'y':  950-(clinic+1)*80,\n    'x': 560,\n    'label': f\"Booked for&lt;br&gt;assessment with&lt;br&gt;clinician {int(clinic)}\",\n    'clinic': int(clinic)}\n    for clinic in clinics]\n\n# Create a column of positions for people having an appointment with the clinic\nclinic_attends = [{'event': f'have_appointment_{int(clinic)}',\n    'y':  950-(clinic+1)*80,\n    'x': 725,\n    'label': f\"Attending appointment&lt;br&gt;with clinician {int(clinic)}\"}\n    for clinic in clinics]\n\n# Join these dataframes\nevent_position_df = pd.concat(\n    [pd.DataFrame(clinic_waits),\n        (pd.DataFrame(clinic_attends))\n        ])\n\n# Create a column of positions for people who are put on a waiting list before being given their future\n# appointment\nwait_for_booking = [{\n    'event': 'waiting_appointment_to_be_scheduled',\n    'y':  250,\n    'x': 225,\n    'label': \"Waiting to be&lt;br&gt;scheduled with &lt;br&gt;clinician \"\n    }]\n\nevent_position_df = pd.concat([event_position_df,(pd.DataFrame(wait_for_booking))])\n\n# Create a column of positions for people being referred to another service (triaged as inappropriate\n# for this service after their initial referral and before an appointment is booked)\nreferred_out = [{\n    'event': 'referred_out',\n    'y':  700,\n    'x': 225,\n    'label': \"Referred Out:&lt;br&gt;Unsuitable for Service\"\n    }]\n\nevent_position_df = pd.concat([event_position_df,(pd.DataFrame(referred_out))])\n\n# Create a column of positions for people who have had their initial appointment and are now waiting for a\n# booked follow-up appointment to take place\nfollow_up_waiting = [{\n    'event': f'follow_up_appointment_booked_waiting_{int(clinic)}',\n    'y':  950-(clinic+1)*80,\n    'x': 1100,\n    'label': f\"On books - awaiting &lt;br&gt;next appointment&lt;br&gt;with clinician {int(clinic)}\"\n    } for clinic in clinics]\n\nevent_position_df = pd.concat([event_position_df,(pd.DataFrame(follow_up_waiting))])\n\nevent_position_df = event_position_df.drop(columns=\"clinic\")\nfull_patient_df_plus_pos = generate_animation_df(\n                            full_entity_df=full_patient_df,\n                            entity_col_name=\"patient\",\n                            event_position_df=event_position_df,\n                            wrap_queues_at=15,\n                            step_snapshot_max=30,\n                            gap_between_entities=15,\n                            gap_between_queue_rows=15,\n                            debug_mode=True\n                    )\n\nPlacement dataframe finished construction at 16:27:08\ndef show_priority_icon(row):\n            if \"more\" not in row[\"icon\"]:\n                if row[\"pathway\"] == 2:\n                    return \"🚨\"\n                else:\n                    return f\"{row['icon']}\"\n            else:\n                return row[\"icon\"]\n\ndef add_los_to_icon(row):\n    if row[\"event_original\"] == \"have_appointment\":\n        return f'{row[\"icon\"]}&lt;br&gt;{int(row[\"wait\"])}'\n    else:\n        return row[\"icon\"]\nfull_patient_df_plus_pos = full_patient_df_plus_pos.assign(\n            icon=full_patient_df_plus_pos.apply(show_priority_icon, axis=1)\n            )\n\nfig = generate_animation(\n    full_entity_df_plus_pos=full_patient_df_plus_pos,\n    event_position_df=event_position_df,\n    entity_col_name=\"patient\",\n    scenario=None,\n    plotly_height=1000,\n    plotly_width=1200,\n    override_x_max=1200,\n    override_y_max=1000,\n    entity_icon_size=10,\n    text_size=10,\n    include_play_button=True,\n    add_background_image=None,\n    display_stage_labels=True,\n    time_display_units=\"d\",\n    simulation_time_unit=\"days\",\n    start_date=\"2022-06-27\",\n    setup_mode=False,\n    frame_duration=1500, #milliseconds\n    frame_transition_duration=1000, #milliseconds\n    debug_mode=False\n)\n\nfig\n\nUnable to display output for mime type(s): application/vnd.plotly.v1+json",
    "crumbs": [
      "SimPy Examples",
      "More Resourceless Queues - Community Service Repeat Appointment Booking Model with Variable Follow-ups"
    ]
  },
  {
    "objectID": "examples/example_12_resourceless_with_back_and_forth/ex_12_resourceless_advanced.html#making-additional-plots-from-the-event-log",
    "href": "examples/example_12_resourceless_with_back_and_forth/ex_12_resourceless_advanced.html#making-additional-plots-from-the-event-log",
    "title": "More Resourceless Queues - Community Service Repeat Appointment Booking Model with Variable Follow-ups",
    "section": "Making additional plots from the event log",
    "text": "Making additional plots from the event log\nWe can also use the event log to make a wide range of additional plots for exploring our model. Here are just a few examples for this particular system.\n\ndaily_position_counts = []\n\nfor day in range(RUN_LENGTH):\n    # First limit to anyone who hasn't left the system yet\n    # Get a list of all people who have departed on or before the day\n    # of interest as we can then remove them from the dataframe\n    # at the next step\n    departed = event_log_df[\n        (event_log_df[\"time\"] &lt;= day) &\n        (event_log_df[\"event\"] == \"depart\")][\"patient\"].tolist()\n    # Filter down to events that have occurred at or before this day\n    upto_now = event_log_df[(event_log_df[\"time\"] &lt;= day)\n                            & (event_log_df[\"event\"] != \"arrival\")\n                            & (~event_log_df[\"patient\"].isin(departed))]\n    # Now take the latest event for each person\n    latest_event_upto_now = upto_now.sort_values(\"time\").groupby(\"patient\").tail(1)\n    for event_type in event_log_df[\"event_original\"].unique():\n        snapshot_count = len(latest_event_upto_now[(latest_event_upto_now[\"event_original\"] == event_type)])\n        daily_position_counts.append(\n            {\"day\": day,\n            \"event\": event_type,\n            \"count\": snapshot_count}\n        )\n\ndaily_position_counts = pd.DataFrame(daily_position_counts)\n\n\nfig_daily_position_counts = px.line(daily_position_counts[(daily_position_counts[\"event\"] == \"waiting_appointment_to_be_scheduled\") |\n                            (daily_position_counts[\"event\"] == \"appointment_booked_waiting\") |\n                            (daily_position_counts[\"event\"] == \"follow_up_appointment_booked_waiting\")  |\n                            (daily_position_counts[\"event\"] == \"have_appointment\")],\n    x=\"day\",\n    y=\"count\",\n    color=\"event\"\n)\nfig_daily_position_counts.update_layout(legend=dict(\n    orientation=\"h\",\n    yanchor=\"bottom\",\n    y=1.02,\n    xanchor=\"right\",\n    x=1\n))\n\nfig_daily_position_counts\n\nUnable to display output for mime type(s): application/vnd.plotly.v1+json\n\n\n\narrival_depart_df = event_log_df[(event_log_df[\"event\"] == \"arrival\") |\n                                      (event_log_df[\"event\"] == \"depart\")][[\"time\", \"event\"]].value_counts().reset_index(drop=False).sort_values('time')\n\narrival_depart_df_pivot = arrival_depart_df.pivot(index=\"time\", columns=\"event\", values=\"count\")\narrival_depart_df_pivot[\"difference (arrival-depart) - positive is more more arriving than departing\"] = arrival_depart_df_pivot[\"arrival\"] - arrival_depart_df_pivot[\"depart\"]\n\narrival_depart_balance_fig = px.scatter(\n        arrival_depart_df,\n        x=\"time\",\n        y=\"count\",\n        color=\"event\",\n        trendline=\"rolling\",\n        color_discrete_sequence=['#636EFA', '#EF553B'],\n        opacity=0.1,\n        trendline_options=dict(window=100)\n    )\n\narrival_depart_balance_fig\n\nUnable to display output for mime type(s): application/vnd.plotly.v1+json\n\n\n\nassessment_booking_waits = (event_log_df\n                      .dropna(subset='assessment_booking_wait')\n                      .drop_duplicates(subset='patient')\n                      [['time','pathway', 'assessment_booking_wait']]\n                      )\n\npx.box(\n                      assessment_booking_waits,\n                      y=\"assessment_booking_wait\", x=\"pathway\", color=\"pathway\"\n                          )\n\nUnable to display output for mime type(s): application/vnd.plotly.v1+json\n\n\n\npx.line(\n                      assessment_booking_waits,\n                      y=\"assessment_booking_wait\", x=\"time\", color=\"pathway\", line_group=\"pathway\"\n                    )\n\nUnable to display output for mime type(s): application/vnd.plotly.v1+json\n\n\n\npx.box(\n                event_log_df\n                .dropna(subset='wait')\n                .drop_duplicates(subset='patient')[['pathway', 'wait']],\n                y=\"wait\", x=\"pathway\", color=\"pathway\"\n                    )\n\nUnable to display output for mime type(s): application/vnd.plotly.v1+json\n\n\n\npx.line(\n                      event_log_df\n                      .dropna(subset='wait')\n                      .drop_duplicates(subset='patient')[['time','pathway', 'wait']],\n                      y=\"wait\", x=\"time\", color=\"pathway\", line_group=\"pathway\"\n                    )\n\nUnable to display output for mime type(s): application/vnd.plotly.v1+json\n\n\n\ninter_appointment_gaps = (event_log_df\n                .dropna(subset='interval')\n                .drop_duplicates('patient')\n                # .query('event_original == \"have_appointment\"')\n                [['time', 'follow_up_intensity','interval']]\n                )\n\n\npx.box(\n                      inter_appointment_gaps,\n                      y=\"interval\", x=\"follow_up_intensity\", color=\"follow_up_intensity\"\n                          )\n\nUnable to display output for mime type(s): application/vnd.plotly.v1+json\n\n\n\npx.line(\n                      inter_appointment_gaps,\n                      y=\"interval\", x=\"time\", color=\"follow_up_intensity\", line_group=\"follow_up_intensity\"\n                    )\n\nUnable to display output for mime type(s): application/vnd.plotly.v1+json\n\n\n\nfig_arrivals = go.Figure(make_subplots(rows=1, cols=1))\nfig_arrivals_1 = px.scatter(\n        pd.DataFrame(pd.Series(daily_arrivals).value_counts()).reset_index(drop=False),\n        x=\"index\",\n        y=\"count\",\n        trendline=\"rolling\",\n        opacity=0.4,\n        trendline_options=dict(window=7)#,\n    )\nfig_arrivals_2 = px.scatter(\n        pd.DataFrame(pd.Series(daily_arrivals).value_counts()).reset_index(drop=False),\n        x=\"index\",\n        y=\"count\",\n        trendline=\"rolling\",\n        trendline_options=dict(window=60),\n        color_discrete_sequence=['red']\n    )\nfig_arrivals_2.data = [t for t in fig_arrivals_2.data if t.mode == \"lines\"]\nfig_trace = []\n\nfor trace in range(len(fig_arrivals_1[\"data\"])):\n    fig_trace.append(fig_arrivals_1[\"data\"][trace])\nfor trace in range(len(fig_arrivals_2[\"data\"])):\n    fig_trace.append(fig_arrivals_2[\"data\"][trace])\n\nfor traces in fig_trace:\n    fig_arrivals.append_trace(traces, row=1, col=1)\n\nfig_arrivals\n\nUnable to display output for mime type(s): application/vnd.plotly.v1+json\n\n\n\npx.bar(\n                event_log_df\n                  .dropna(subset='follow_ups_intended')\n                  .drop_duplicates(subset='patient')[['pathway','follow_ups_intended']]\n                  .value_counts()\n                  .reset_index(drop=False),\n                x=\"follow_ups_intended\", y=\"count\",facet_row=\"pathway\"\n                )\n\nUnable to display output for mime type(s): application/vnd.plotly.v1+json\n\n\n\npx.bar(\n                event_log_df\n                .dropna(subset='assessment_booking_wait')\n                .drop_duplicates(subset='patient')\n                .groupby('pathway')[['pathway','assessment_booking_wait']]\n                .value_counts()\n                .reset_index(drop=False),\n                x=\"assessment_booking_wait\", y=\"count\", facet_row=\"pathway\"\n                )\n\nUnable to display output for mime type(s): application/vnd.plotly.v1+json\n\n\n\ncl = pd.DataFrame(daily_caseload_snapshots[\"caseload_day_end\"].tolist())\ncl_filtered = cl.iloc[WARM_UP:RUN_LENGTH,:]\ncl_plotting = cl_filtered.reset_index(drop=False).melt(id_vars=[\"index\"], var_name=\"clinician\", value_name=\"caseload\")\npx.line(\n    cl_plotting,\n    x=\"index\",\n    y= \"caseload\",\n    color=\"clinician\",\n    range_y=[0, max(cl_plotting[\"caseload\"])]\n    )\n\nUnable to display output for mime type(s): application/vnd.plotly.v1+json\n\n\n\npx.line((cl_filtered.sum(axis=1)/(np.floor(shifts.sum() * CASELOAD_TARGET_MULTIPLIER).sum())).reset_index(),\n        x=\"index\", y=0)\n\nUnable to display output for mime type(s): application/vnd.plotly.v1+json\n\n\n\npx.bar(\n    daily_position_counts[daily_position_counts[\"event\"] != \"depart\"],\n    x=\"event\",\n    y=\"count\",\n    animation_frame=\"day\",\n    range_y=[0, max(daily_position_counts[\"count\"])]\n)\n\nUnable to display output for mime type(s): application/vnd.plotly.v1+json",
    "crumbs": [
      "SimPy Examples",
      "More Resourceless Queues - Community Service Repeat Appointment Booking Model with Variable Follow-ups"
    ]
  },
  {
    "objectID": "examples/example_10_advanced_ciw/ex_10_ciw.html",
    "href": "examples/example_10_advanced_ciw/ex_10_ciw.html",
    "title": "A More Complex Ciw Example with Backgrounds",
    "section": "",
    "text": "import pandas as pd\n# Import the wrapper objects for model interaction.\nfrom examples.example_10_advanced_ciw.ex_10_ciw_model import N\nfrom vidigi.ciw import event_log_from_ciw_recs\nfrom vidigi.utils import EventPosition, create_event_position_df\nfrom vidigi.animation import animate_activity_log\nimport plotly.io as pio\npio.renderers.default = \"notebook\"\nimport os\nimport ciw\n\n\n\n\n\n\n\nView Imported Code for the ciw model\n\n\n\n\n\nimport ciw\n\n# From https://ciw.readthedocs.io/en/latest/Tutorial/tutorial_ii.html\n\nN = ciw.create_network(\n\n    arrival_distributions=[ciw.dists.Exponential(rate=0.3 / 60),\n\n                           ciw.dists.Exponential(rate=0.2 / 60),\n\n                           None],\n\n    service_distributions=[ciw.dists.Exponential(rate=2.0 / 60),\n\n                           ciw.dists.Exponential(rate=1.4 / 60),\n\n                           ciw.dists.Exponential(rate=1.0 / 60)],\n\n    routing=[[0.0, 0.3, 0.7],\n\n             [0.0, 0.0, 1.0],\n\n             [0.0, 0.0, 0.0]],\n\n    number_of_servers=[1, 2, 2]\n\n)\n\n\n\n\nciw.seed(42)\n\nQ = ciw.Simulation(N)\n\nRESULTS_COLLECTION_PERIOD = 180 * 60 # 180 minutes x 60 seconds\n\nQ.simulate_until_max_time(RESULTS_COLLECTION_PERIOD)\n\nrecs = Q.get_all_records()\n\npd.DataFrame(recs).sort_values(['id_number', 'service_start_date']).head(20)\n\n\n\n\n\n\n\n\nid_number\ncustomer_class\noriginal_customer_class\nnode\narrival_date\nwaiting_time\nservice_start_date\nservice_time\nservice_end_date\ntime_blocked\nexit_date\ndestination\nqueue_size_at_arrival\nqueue_size_at_departure\nserver_id\nrecord_type\n\n\n\n\n0\n1\nCustomer\nCustomer\n2\n7.598652\n0.000000\n7.598652\n13.783888\n21.382540\n0.0\n21.382540\n3\n0\n0\n1\nservice\n\n\n1\n1\nCustomer\nCustomer\n3\n21.382540\n0.000000\n21.382540\n67.750381\n89.132921\n0.0\n89.132921\n-1\n0\n0\n1\nservice\n\n\n6\n2\nCustomer\nCustomer\n2\n83.374507\n0.000000\n83.374507\n95.455204\n178.829712\n0.0\n178.829712\n3\n0\n0\n1\nservice\n\n\n7\n2\nCustomer\nCustomer\n3\n178.829712\n0.000000\n178.829712\n53.388522\n232.218234\n0.0\n232.218234\n-1\n1\n1\n1\nservice\n\n\n2\n3\nCustomer\nCustomer\n2\n110.660229\n0.000000\n110.660229\n23.487693\n134.147921\n0.0\n134.147921\n3\n1\n2\n2\nservice\n\n\n3\n3\nCustomer\nCustomer\n3\n134.147921\n0.000000\n134.147921\n13.301500\n147.449421\n0.0\n147.449421\n-1\n0\n1\n1\nservice\n\n\n4\n4\nCustomer\nCustomer\n2\n119.735282\n14.412639\n134.147921\n1.152617\n135.300539\n0.0\n135.300539\n3\n2\n1\n2\nservice\n\n\n5\n4\nCustomer\nCustomer\n3\n135.300539\n0.000000\n135.300539\n47.239755\n182.540294\n0.0\n182.540294\n-1\n1\n1\n2\nservice\n\n\n16\n5\nCustomer\nCustomer\n2\n193.750291\n0.000000\n193.750291\n71.045918\n264.796209\n0.0\n264.796209\n3\n0\n1\n1\nservice\n\n\n17\n5\nCustomer\nCustomer\n3\n264.796209\n0.000000\n264.796209\n216.972911\n481.769120\n0.0\n481.769120\n-1\n1\n0\n2\nservice\n\n\n12\n6\nCustomer\nCustomer\n2\n195.706281\n0.000000\n195.706281\n70.241394\n265.947675\n0.0\n265.947675\n3\n1\n0\n2\nservice\n\n\n13\n6\nCustomer\nCustomer\n3\n265.947675\n30.320583\n296.268259\n48.183165\n344.451423\n0.0\n344.451423\n-1\n2\n2\n1\nservice\n\n\n8\n7\nCustomer\nCustomer\n1\n204.012057\n0.000000\n204.012057\n12.476853\n216.488910\n0.0\n216.488910\n3\n0\n0\n1\nservice\n\n\n9\n7\nCustomer\nCustomer\n3\n216.488910\n0.000000\n216.488910\n24.622136\n241.111046\n0.0\n241.111046\n-1\n1\n1\n2\nservice\n\n\n10\n8\nCustomer\nCustomer\n1\n237.809311\n0.000000\n237.809311\n2.919980\n240.729291\n0.0\n240.729291\n3\n0\n0\n1\nservice\n\n\n11\n8\nCustomer\nCustomer\n3\n240.729291\n0.000000\n240.729291\n55.538968\n296.268259\n0.0\n296.268259\n-1\n1\n2\n1\nservice\n\n\n14\n9\nCustomer\nCustomer\n1\n258.153048\n0.000000\n258.153048\n49.371898\n307.524946\n0.0\n307.524946\n3\n0\n0\n1\nservice\n\n\n15\n9\nCustomer\nCustomer\n3\n307.524946\n36.926477\n344.451423\n57.821772\n402.273196\n0.0\n402.273196\n-1\n2\n1\n1\nservice\n\n\n20\n10\nCustomer\nCustomer\n1\n519.821134\n0.000000\n519.821134\n59.351398\n579.172532\n0.0\n579.172532\n2\n0\n0\n1\nservice\n\n\n21\n10\nCustomer\nCustomer\n2\n579.172532\n1.027521\n580.200053\n4.563164\n584.763217\n0.0\n584.763217\n3\n2\n1\n2\nservice\n\n\n\n\n\n\n\n\nevent_log = event_log_from_ciw_recs(\n    recs,\n    node_name_list=[\"cold_food\", \"hot_food\", \"till\"]\n    )\n\nevent_log[event_log[\"entity_id\"]==13]\n\n\n\n\n\n\n\n\nentity_id\npathway\nevent_type\nevent\ntime\nresource_id\n\n\n\n\n99\n13\nModel\narrival_departure\narrival\n671.604123\nNaN\n\n\n100\n13\nModel\nqueue\nhot_food_wait_begins\n671.604123\nNaN\n\n\n101\n13\nModel\nresource_use\nhot_food_begins\n671.604123\n1.0\n\n\n102\n13\nModel\nresource_use_end\nhot_food_ends\n684.914665\n1.0\n\n\n103\n13\nModel\nqueue\ntill_wait_begins\n684.914665\nNaN\n\n\n104\n13\nModel\nresource_use\ntill_begins\n684.914665\n1.0\n\n\n105\n13\nModel\nresource_use_end\ntill_ends\n741.277635\n1.0\n\n\n106\n13\nModel\narrival_departure\ndepart\n741.277635\nNaN\n\n\n\n\n\n\n\n\n# Create a suitable class to pass in the resource numbers to the animation function\nclass model_params():\n    def __init__(self):\n        self.cold_food_servers = 1\n        self.hot_food_servers = 2\n        self.tills = 2\n\nparams = model_params()\n\n\n# # Create required event_position_df for vidigi animation\n# event_position_df = pd.DataFrame([\n#                     {'event': 'arrival',\n#                      'x':  30, 'y': 550,\n#                      'label': \"Arrival\"},\n\n#                     {'event': 'cold_food_wait_begins',\n#                      'x':  200, 'y': 510,\n#                      'label': \"Waiting for Cold Food\"},\n\n#                     {'event': 'cold_food_begins',\n#                      'x':  210, 'y': 370,\n#                      'resource':'cold_food_servers',\n#                      'label': \"Being Served Cold Food\"},\n\n#                     {'event': 'hot_food_wait_begins',\n#                      'x':  505, 'y': 510,\n#                      'label': \"Waiting for Hot Food\"},\n\n#                     {'event': 'hot_food_begins',\n#                      'x':  505, 'y': 370,\n#                      'resource':'hot_food_servers',\n#                      'label': \"Being Served Hot Food\"},\n\n#                     {'event': 'till_wait_begins',\n#                      'x':  350, 'y': 170,\n#                      'label': \"Waiting for Till\"},\n\n#                     {'event': 'till_begins',\n#                      'x':  350, 'y': 120,\n#                      'resource':'tills',\n#                      'label': \"Being Served at Till\"},\n\n#                     {'event': 'depart',\n#                      'x':  600, 'y': 10,\n#                      'label': \"Exit\"}\n\n#                 ])\n\n# event_position_df\n\nevent_position_df = create_event_position_df( [\n    EventPosition(event='arrival', x=30, y=550, label=\"Arrival\"),\n    EventPosition(event='cold_food_wait_begins', x=200, y=510, label=\"Waiting for Cold Food\"),\n    EventPosition(event='cold_food_begins', x=210, y=370, resource='cold_food_servers', label=\"Being Served Cold Food\"),\n    EventPosition(event='hot_food_wait_begins', x=505, y=510, label=\"Waiting for Hot Food\"),\n    EventPosition(event='hot_food_begins', x=505, y=370, resource='hot_food_servers', label=\"Being Served Hot Food\"),\n    EventPosition(event='till_wait_begins', x=350, y=170, label=\"Waiting for Till\"),\n    EventPosition(event='till_begins', x=350, y=120, resource='tills', label=\"Being Served at Till\"),\n    EventPosition(event='depart', x=600, y=10, label=\"Exit\")\n]\n)\n\n\n# Create animation\nparams = model_params()\n\nanimate_activity_log(\n        event_log=event_log,\n        event_position_df=event_position_df,\n        scenario=model_params(),\n        simulation_time_unit=\"seconds\",\n        time_display_units=\"dhms\",\n        debug_mode=True,\n        setup_mode=False,\n        every_x_time_units=5, # 20 seconds\n        include_play_button=True,\n        entity_icon_size=20,\n        gap_between_entities=15,\n        gap_between_queue_rows=25,\n        gap_between_resources=30,\n        plotly_height=700,\n        frame_duration=200,\n        frame_transition_duration=600,\n        plotly_width=1200,\n        override_x_max=700,\n        override_y_max=600,\n        limit_duration=RESULTS_COLLECTION_PERIOD,\n        wrap_queues_at=25,\n        wrap_resources_at=50,\n        step_snapshot_max=75,\n        start_time=\"12:00:00\",\n        text_size=20,\n        display_stage_labels=False,\n        add_background_image=\"cafe_floorplan.drawio (1).png\"\n    )\n\nAnimation function called at 11:30:43\nIteration through time-unit-by-time-unit logs complete 11:30:47\nSnapshot df concatenation complete at 11:30:47\nReshaped animation dataframe finished construction at 11:30:48\nPlacement dataframe finished construction at 11:30:48\nOutput animation generation complete at 11:30:55\nTotal Time Elapsed: 12.58 seconds",
    "crumbs": [
      "Ciw Examples",
      "A More Complex Ciw Example with Backgrounds"
    ]
  },
  {
    "objectID": "examples/example_11_resourceless_animation/ex_11_resourceless.html",
    "href": "examples/example_11_resourceless_animation/ex_11_resourceless.html",
    "title": "Mental Health - Appointment Booking Model",
    "section": "",
    "text": "Sometimes you may want to display models without having a clear concept of a ‘resource’ that you track.\nIn this case, vidigi can cope perfectly fine with just having ‘queue’ steps implemented.\nIn this instance, this model looks at a simple mental health pathway. Here, we are only concerned with the booking of an initial appointment. Each clinician has a certain number of slots available per day, but the number of available slots varies significantly across the course of the week for each individual clinician. Changing the available resources over the course of a simulation is not currently supported - though you could demonstrate resources being ‘unavailable’ by blocking them for a certain duration with an icon indicating unavailability. In this case, where the focus is on the buildup of queues,\nThis example also shows the automatic generation of the appropriate number of event positioning entries, which would support the use of the animation in a front-end where the number of clinicains could be varied.\nBy default, the model uses an appointment book with some slots held back for high-priority patients. Each patient in the default scenario can only go to their ‘home’/most local clinic.\nHowever, it is possible to switch to other scenarios - a ‘pooling’ system where patients can choose between one of several linked clinics in their local area (with the assumption that they will choose the clinic of the group with the soonest available appointment) - the pooling system described above, but with no slots held back for high-priority patients (i.e. no ‘carve-out’)\nimport pandas as pd\nimport math\nfrom examples.example_11_resourceless_animation.model_classes import Scenario, generate_seed_vector\nfrom examples.example_11_resourceless_animation.simulation_execution_functions import single_run\nfrom vidigi.prep import reshape_for_animations, generate_animation_df\nfrom vidigi.animation import generate_animation\nshifts = pd.read_csv(\"data/shifts.csv\")\n# if scenario_choice == \"As-is\" or scenario_choice == \"With Pooling\":\n# prop_carve_out = [0.0, 0.9, 0.15, 0.01]\nprop_carve_out = 0.15\n\n#depending on settings and CPU this model takes around 15-20 seconds to run\nRESULTS_COLLECTION = 90 * 1\n\n# We use a warm-up period\n# because the model starts up empty which doesn't reflect reality\nWARM_UP = 60 * 1\nRUN_LENGTH = RESULTS_COLLECTION + WARM_UP\n\n# Set up the scenario for the model to run.\nscenarios = {}\n\nscenarios['as-is'] = Scenario(\n    RUN_LENGTH,\n    WARM_UP,\n    prop_carve_out=prop_carve_out,\n    seeds=generate_seed_vector(),\n    slots_file=shifts\n    )\n\nscenarios['pooled'] = Scenario(\n    RUN_LENGTH,\n    WARM_UP,\n    prop_carve_out=prop_carve_out,\n    pooling=True,\n    seeds=generate_seed_vector(),\n    slots_file=shifts\n    )\n\nscenarios['no_carve_out'] = Scenario(\n    RUN_LENGTH,\n    WARM_UP,\n    pooling=True,\n    prop_carve_out=0.0,\n    seeds=generate_seed_vector(),\n    slots_file=shifts\n    )\n\nclinic_lkup_df = pd.DataFrame([\n    {'clinic': 0, 'icon': \"🟠\"},\n    {'clinic': 1, 'icon': \"🟡\"},\n    {'clinic': 2, 'icon': \"🟢\"},\n    {'clinic': 3, 'icon': \"🔵\"},\n    {'clinic': 4, 'icon': \"🟣\"},\n    {'clinic': 5, 'icon': \"🟤\"},\n    {'clinic': 6, 'icon': \"⚫\"},\n    {'clinic': 7, 'icon': \"⚪\"},\n    {'clinic': 8, 'icon': \"🔶\"},\n    {'clinic': 9, 'icon': \"🔷\"},\n    {'clinic': 10, 'icon': \"🟩\"}\n])\n\n\ndef show_home_clinic(row):\n        if \"more\" not in row[\"icon\"]:\n            if row[\"home_clinic\"] == 0:\n                return \"🟠\"\n            if row[\"home_clinic\"] == 1:\n                return \"🟡\"\n            if row[\"home_clinic\"] == 2:\n                return \"🟢\"\n            if row[\"home_clinic\"] == 3:\n                return \"🔵\"\n            if row[\"home_clinic\"] == 4:\n                return \"🟣\"\n            if row[\"home_clinic\"] == 5:\n                return \"🟤\"\n            if row[\"home_clinic\"] == 6:\n                return \"⚫\"\n            if row[\"home_clinic\"] == 7:\n                return \"⚪\"\n            if row[\"home_clinic\"] == 8:\n                return \"🔶\"\n            if row[\"home_clinic\"] == 9:\n                return \"🔷\"\n            if row[\"home_clinic\"] == 10:\n                return \"🟩\"\n            else:\n                return row[\"icon\"]\n        else:\n            return row[\"icon\"]\n\ndef show_priority_icon(row):\n    if \"more\" not in row[\"icon\"]:\n        if row[\"pathway\"] == 2:\n            return \"🚨\"\n        else:\n            return row[\"icon\"]\n    else:\n        return row[\"icon\"]\n\ndef add_los_to_icon(row):\n    if row[\"event_original\"] == \"have_appointment\":\n        return f'{row[\"icon\"]}&lt;br&gt;{int(row[\"wait\"])}'\n    else:\n        return row[\"icon\"]\ndef generate_scenario_results(scenario):\n    results_all, results_low, results_high, event_log = single_run(scenarios[scenario])\n    event_log_df = pd.DataFrame(event_log)\n    event_log_df['event_original'] = event_log_df['event']\n    event_log_df['event'] = event_log_df.apply(lambda x: f\"{x['event']}{f'_{int(x.booked_clinic)}' if pd.notna(x['booked_clinic']) else ''}\", axis=1)\n\n    full_patient_df = reshape_for_animations(\n        event_log_df,\n        entity_col_name=\"patient\",\n        limit_duration=WARM_UP+180,\n        every_x_time_units=1,\n        step_snapshot_max=50,\n        )\n\n    # Remove the warm-up period from the event log\n    full_patient_df = full_patient_df[full_patient_df[\"snapshot_time\"] &gt;= WARM_UP]\n\n    clinics =  [x for x in event_log_df['booked_clinic'].sort_values().unique().tolist() if not math.isnan(x)]\n\n    clinic_waits = [{'event': f'appointment_booked_waiting_{int(clinic)}',\n        'y':  950-(clinic+1)*80,\n        'x': 625,\n        'label': f\"Booked into&lt;br&gt;clinic {int(clinic)}\",\n        'clinic': int(clinic)}\n        for clinic in clinics]\n\n    clinic_attends = [{'event': f'have_appointment_{int(clinic)}',\n        'y':  950-(clinic+1)*80,\n        'x': 850,\n        'label': f\"Attending appointment&lt;br&gt;at clinic {int(clinic)}\"}\n        for clinic in clinics]\n\n    event_position_df = pd.concat([pd.DataFrame(clinic_waits),(pd.DataFrame(clinic_attends))])\n\n    referred_out = [{'event': f'referred_out_{int(clinic)}',\n        'y':  950-(clinic+1)*80,\n        'x': 125,\n        'label': f\"Referred Out From &lt;br&gt;clinic {int(clinic)}\"}\n        for clinic in clinics]\n\n    event_position_df = pd.concat([event_position_df,(pd.DataFrame(referred_out))])\n\n    if scenario == \"pooled\" or \"no_carve_out\":\n        event_position_df = event_position_df.merge(clinic_lkup_df, how=\"left\")\n        event_position_df[\"label\"] = event_position_df.apply(\n            lambda x: f\"{x['label']} {x['icon']}\" if pd.notna(x['icon']) else x['label'],\n            axis=1\n            )\n        event_position_df = event_position_df.drop(columns=\"icon\")\n\n    event_position_df.drop(columns=\"clinic\")\n\n    full_patient_df_plus_pos = generate_animation_df(\n                    full_entity_df=full_patient_df,\n                    entity_col_name=\"patient\",\n                    event_position_df=event_position_df,\n                    wrap_queues_at=25,\n                    step_snapshot_max=50,\n                    gap_between_entities=15,\n                    gap_between_queue_rows=15,\n                    debug_mode=True\n            )\n\n    return full_patient_df, full_patient_df_plus_pos, event_position_df",
    "crumbs": [
      "SimPy Examples",
      "Mental Health - Appointment Booking Model"
    ]
  },
  {
    "objectID": "examples/example_11_resourceless_animation/ex_11_resourceless.html#scenario-1---as-is",
    "href": "examples/example_11_resourceless_animation/ex_11_resourceless.html#scenario-1---as-is",
    "title": "Mental Health - Appointment Booking Model",
    "section": "Scenario 1 - As-is",
    "text": "Scenario 1 - As-is\n\nfull_patient_df, full_patient_df_plus_pos, event_position_df = generate_scenario_results(\n    'as-is'\n    )\n\nPlacement dataframe finished construction at 15:33:01\n\n\n\ndef generate_clinic_animation(final_df):\n    fig = generate_animation(\n        full_entity_df_plus_pos=final_df,\n        event_position_df=event_position_df,\n        scenario=None,\n        entity_col_name=\"patient\",\n        plotly_height=850,\n        plotly_width=1100,\n        override_x_max=1000,\n        override_y_max=1000,\n        entity_icon_size=10,\n        text_size=10,\n        include_play_button=True,\n        add_background_image=None,\n        display_stage_labels=True,\n        time_display_units=\"d\",\n        simulation_time_unit=\"days\",\n        start_date=\"2022-06-27\",\n        setup_mode=False,\n        frame_duration=1500, #milliseconds\n        frame_transition_duration=1000, #milliseconds\n        debug_mode=False\n    )\n\n    return fig\n\n    #TODO\n    # Add in additional trace that shows the number of available slots per day\n    # using the slot df\n\n    #TODO\n    # Pooled booking version where being in non-home clinic makes you one colour\n    # and home clinic makes you another\n\n    #TODO\n    # Investigate adding a priority attribute to event log\n    # that can be considered when ranking queues if present\n\n\ngenerate_clinic_animation(full_patient_df_plus_pos).show()\n\nUnable to display output for mime type(s): application/vnd.plotly.v1+json",
    "crumbs": [
      "SimPy Examples",
      "Mental Health - Appointment Booking Model"
    ]
  },
  {
    "objectID": "examples/example_11_resourceless_animation/ex_11_resourceless.html#with-pooling",
    "href": "examples/example_11_resourceless_animation/ex_11_resourceless.html#with-pooling",
    "title": "Mental Health - Appointment Booking Model",
    "section": "With Pooling",
    "text": "With Pooling\n\nfull_patient_df, full_patient_df_plus_pos, event_position_df = generate_scenario_results('pooled')\n\nPlacement dataframe finished construction at 15:33:13\n\n\n\nfull_patient_df_plus_pos = full_patient_df_plus_pos.assign(\n    icon=full_patient_df_plus_pos.apply(show_home_clinic, axis=1)\n    )\n\nfull_patient_df_plus_pos = full_patient_df_plus_pos.assign(\n    icon=full_patient_df_plus_pos.apply(show_priority_icon, axis=1)\n    )\n\nfull_patient_df_plus_pos = full_patient_df_plus_pos.assign(\n    icon=full_patient_df_plus_pos.apply(add_los_to_icon, axis=1)\n    )\n\n\ngenerate_clinic_animation(full_patient_df_plus_pos).show()\n\nUnable to display output for mime type(s): application/vnd.plotly.v1+json",
    "crumbs": [
      "SimPy Examples",
      "Mental Health - Appointment Booking Model"
    ]
  },
  {
    "objectID": "examples/example_11_resourceless_animation/ex_11_resourceless.html#with-pooling---no-carve-out",
    "href": "examples/example_11_resourceless_animation/ex_11_resourceless.html#with-pooling---no-carve-out",
    "title": "Mental Health - Appointment Booking Model",
    "section": "With Pooling - No Carve-out",
    "text": "With Pooling - No Carve-out\n\nfull_patient_df, full_patient_df_plus_pos, event_position_df = generate_scenario_results('no_carve_out')\n\nPlacement dataframe finished construction at 15:33:26\n\n\n\nfull_patient_df_plus_pos = full_patient_df_plus_pos.assign(\n    icon=full_patient_df_plus_pos.apply(show_home_clinic, axis=1)\n    )\n\nfull_patient_df_plus_pos = full_patient_df_plus_pos.assign(\n    icon=full_patient_df_plus_pos.apply(show_priority_icon, axis=1)\n    )\n\nfull_patient_df_plus_pos = full_patient_df_plus_pos.assign(\n    icon=full_patient_df_plus_pos.apply(add_los_to_icon, axis=1)\n    )\n\n\ngenerate_clinic_animation(full_patient_df_plus_pos).show()\n\nUnable to display output for mime type(s): application/vnd.plotly.v1+json",
    "crumbs": [
      "SimPy Examples",
      "Mental Health - Appointment Booking Model"
    ]
  },
  {
    "objectID": "examples/example_13_additional_synchronised_traces_method_1/synchronised_traces copy 2.html",
    "href": "examples/example_13_additional_synchronised_traces_method_1/synchronised_traces copy 2.html",
    "title": "Additional Synchronised Traces - Orthopaedic Ward - Hospital Efficiency Project",
    "section": "",
    "text": "This is the orthopaedic surgery model developed as part of the hospital efficiency project.\noriginal model author = Harper, Alison and Monks, Thomas\nlicense = MIT\ntitle = Hospital Efficiency Project Orthopaedic Planning Model Discrete-Event Simulation\nurl = https://github.com/AliHarp/HEP\nIt has been used as a test case here to allow the development and testing of several key features of the event log animations:\n\nadding of logging to a model from scratch\nensuring the requirement to use simpy stores instead of simpy resources doesn’t prevent the uses of certain common modelling patterns (in this case, conditional logic where patients will leave the system if a bed is not available within a specified period of time)\ndisplaying different icons for different classes of patients\ndisplaying custom resource icons\ndisplaying additional static information as part of the icon (in this case, whether the client’s discharge is delayed)\ndisplaying information that updates with each animation step as part of the icon (in this case, the LoS of the patient at each time point)\n\n\nimport gc\nimport time\nimport datetime as dt\nimport streamlit as st\nimport pandas as pd\nimport plotly.express as px\nimport plotly.graph_objects as go\nfrom examples.example_13_additional_synchronised_traces_method_1.simulation_execution_functions import multiple_replications\nfrom examples.example_13_additional_synchronised_traces_method_1.model_classes import Scenario, Schedule\nfrom vidigi.prep import reshape_for_animations, generate_animation_df\nfrom vidigi.animation import generate_animation\nfrom plotly.subplots import make_subplots\n\n\nTRACE = True\ndebug_mode=True\n\nschedule = Schedule()\n\n4 theatres\n5 day/week\nEach theatre has three sessions per day:\nMorning: 1 revision OR 2 primary\nAfternoon: 1 revision OR 2 primary\nEvening: 1 primary\n40 ring-fenced beds for recovery from these operations\n\n(pd.DataFrame.from_dict(schedule.sessions_per_weekday, orient=\"index\")\n        .rename(columns={0: \"Sessions\"}).merge(\n\n        pd.DataFrame.from_dict(schedule.theatres_per_weekday, orient=\"index\")\n            .rename(columns={0: \"Theatre Capacity\"}),\n            left_index=True, right_index=True\n\n        ).merge(\n\n        pd.DataFrame.from_dict(schedule.allocation, orient=\"index\"),\n        left_index=True, right_index=True\n\n        ))\n\n\n\n\n\n\n\n\nSessions\nTheatre Capacity\n0\n1\n2\n\n\n\n\nMonday\n3\n4\n2P_or_1R\n2P_or_1R\n1P\n\n\nTuesday\n3\n4\n2P_or_1R\n2P_or_1R\n1P\n\n\nWednesday\n3\n4\n2P_or_1R\n2P_or_1R\n1P\n\n\nThursday\n3\n4\n2P_or_1R\n2P_or_1R\n1P\n\n\nFriday\n3\n4\n2P_or_1R\n2P_or_1R\n1P\n\n\nSaturday\n0\n0\nNone\nNone\nNone\n\n\nSunday\n0\n0\nNone\nNone\nNone\n\n\n\n\n\n\n\n\nn_beds = 40\n\nprimary_hip_los = 4.4\n\nprimary_knee_los = 4.7\n\nrevision_hip_los = 6.9\n\nrevision_knee_los = 7.2\n\nunicompart_knee_los = 2.9\n\nlos_delay = 16.5\nlos_delay_sd = 15.2\n\nprop_delay = 0.076\n\nreplications = 30\nruntime = 60\nwarmup=7\n\nargs = Scenario(schedule=schedule,\n                primary_hip_mean_los=primary_hip_los,\n                primary_knee_mean_los=primary_knee_los,\n                revision_hip_mean_los=revision_hip_los,\n                revision_knee_mean_los=revision_knee_los,\n                unicompart_knee_mean_los=unicompart_knee_los,\n                prob_ward_delay=prop_delay,\n                n_beds=n_beds,\n                delay_post_los_mean=los_delay,\n                delay_post_los_sd=los_delay_sd\n                )\n\n\nresults = multiple_replications(\n                return_detailed_logs=True,\n                scenario=args,\n                n_reps=replications,\n                results_collection=runtime\n            )\n\n\n\n\n# Join the event log with a list of patients to add a column that will determine\n# the icon set used for a patient (in this case, we want to distinguish between the\n# knee/hip patients)\nevent_log = results[4]\nevent_log = event_log[event_log['rep'] == 1]\nevent_log['patient'] = event_log['patient'].astype('str') + event_log['pathway']\n\nprimary_patients = results[2]\nprimary_patients = primary_patients[primary_patients['rep'] == 1]\nprimary_patients['patient class'] = primary_patients['patient class'].str.title()\nprimary_patients['ID'] = primary_patients['ID'].astype('str') + primary_patients['patient class']\n\nrevision_patients = results[3]\nrevision_patients = revision_patients[revision_patients['rep'] == 1]\nrevision_patients['patient class'] = revision_patients['patient class'].str.title()\nrevision_patients['ID'] = revision_patients['ID'].astype('str') + revision_patients['patient class']\n\nfull_log_with_patient_details = event_log.merge(pd.concat([primary_patients, revision_patients]),\n                                                    how=\"left\",\n                                                left_on=[\"patient\", \"pathway\"],\n                                                right_on=[\"ID\", \"patient class\"]).reset_index(drop=True).drop(columns=\"ID\")\n\npid_table = full_log_with_patient_details[['patient']].drop_duplicates().reset_index(drop=True).reset_index(drop=False).rename(columns={'index': 'pid'})\n\nfull_log_with_patient_details = full_log_with_patient_details.merge(pid_table, how='left', on='patient').drop(columns='patient').rename(columns={'pid':'patient'})\n\nC:\\Users\\Sammi\\AppData\\Local\\Temp\\ipykernel_5672\\3505082114.py:50: SettingWithCopyWarning:\n\n\nA value is trying to be set on a copy of a slice from a DataFrame.\nTry using .loc[row_indexer,col_indexer] = value instead\n\nSee the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n\nC:\\Users\\Sammi\\AppData\\Local\\Temp\\ipykernel_5672\\3505082114.py:54: SettingWithCopyWarning:\n\n\nA value is trying to be set on a copy of a slice from a DataFrame.\nTry using .loc[row_indexer,col_indexer] = value instead\n\nSee the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n\nC:\\Users\\Sammi\\AppData\\Local\\Temp\\ipykernel_5672\\3505082114.py:55: SettingWithCopyWarning:\n\n\nA value is trying to be set on a copy of a slice from a DataFrame.\nTry using .loc[row_indexer,col_indexer] = value instead\n\nSee the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n\nC:\\Users\\Sammi\\AppData\\Local\\Temp\\ipykernel_5672\\3505082114.py:59: SettingWithCopyWarning:\n\n\nA value is trying to be set on a copy of a slice from a DataFrame.\nTry using .loc[row_indexer,col_indexer] = value instead\n\nSee the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n\nC:\\Users\\Sammi\\AppData\\Local\\Temp\\ipykernel_5672\\3505082114.py:60: SettingWithCopyWarning:\n\n\nA value is trying to be set on a copy of a slice from a DataFrame.\nTry using .loc[row_indexer,col_indexer] = value instead\n\nSee the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n\n\n\n\n\nevent_position_df = pd.DataFrame([\n            # {'event': 'arrival', 'x':  10, 'y': 250, 'label': \"Arrival\" },\n\n            # Triage - minor and trauma\n            {'event': 'enter_queue_for_bed',\n                'x':  300, 'y': 650, 'label': \"Waiting for&lt;br&gt;Availability of&lt;br&gt;Bed to be Confirmed&lt;br&gt;Before Surgery\" },\n\n            {'event': 'no_bed_available',\n                'x':  700, 'y': 650, 'label': \"No Bed&lt;br&gt;Available:&lt;br&gt;Surgery Cancelled\" },\n\n            {'event': 'post_surgery_stay_begins',\n                'x':  750, 'y': 220, 'resource':'n_beds', 'label': \"In Bed:&lt;br&gt;Recovering from&lt;br&gt;Surgery\" },\n\n            {'event': 'discharged_after_stay',\n                'x':  770, 'y': 50, 'label': \"Discharged from Hospital&lt;br&gt;After Recovery\"}\n            # {'event': 'exit',\n            #  'x':  670, 'y': 100, 'label': \"Exit\"}\n\n            ])\n\n\nfull_patient_df = reshape_for_animations(full_log_with_patient_details,\n                                         entity_col_name=\"patient\",\n                                            every_x_time_units=1,\n                                            limit_duration=runtime,\n                                            step_snapshot_max=50,\n                                            debug_mode=debug_mode\n                                            )\n\nif debug_mode:\n    print(f'Reshaped animation dataframe finished construction at {time.strftime(\"%H:%M:%S\", time.localtime())}')\n\nIteration through time-unit-by-time-unit logs complete 12:18:40\nSnapshot df concatenation complete at 12:18:40\nReshaped animation dataframe finished construction at 12:18:41\n\n\n\nfull_patient_df_plus_pos = generate_animation_df(\n                            full_entity_df=full_patient_df,\n                            entity_col_name=\"patient\",\n                            event_position_df=event_position_df,\n                            wrap_queues_at=20,\n                            wrap_resources_at=40,\n                            step_snapshot_max=50,\n                            gap_between_entities=15,\n                            gap_between_resources=15,\n                            gap_between_queue_rows=175,\n                            gap_between_resource_rows=175,\n                            debug_mode=debug_mode\n                    )\n\nPlacement dataframe finished construction at 12:18:41\n\n\n\ndef set_icon(row):\n    if row[\"surgery type\"] == \"p_knee\":\n        return \"🦵&lt;br&gt;1️⃣&lt;br&gt; \"\n    elif row[\"surgery type\"] == \"r_knee\":\n        return \"🦵&lt;br&gt;♻️&lt;br&gt; \"\n    elif row[\"surgery type\"] == \"p_hip\":\n        return \"🕺&lt;br&gt;1️⃣&lt;br&gt; \"\n    elif row[\"surgery type\"] == \"r_hip\":\n        return \"🕺&lt;br&gt;♻️&lt;br&gt; \"\n    elif row[\"surgery type\"] == \"uni_knee\":\n        return \"🦵&lt;br&gt;✳️&lt;br&gt; \"\n    else:\n        return f\"CHECK&lt;br&gt;{row['icon']}\"\n\nfull_patient_df_plus_pos = full_patient_df_plus_pos.assign(icon=full_patient_df_plus_pos.apply(set_icon, axis=1))\n\n# TODO: Check why this doesn't seem to be working quite right for the 'discharged after stay'\n# step. e.g. 194Primary is discharged on 28th July showing a LOS of 1 but prior to this shows a LOS of 9.\ndef add_los_to_icon(row):\n    if row[\"event\"] == \"post_surgery_stay_begins\":\n        return f'{row[\"icon\"]}&lt;br&gt;{row[\"snapshot_time\"]-row[\"time\"]:.0f}'\n    elif row[\"event\"] == \"discharged_after_stay\":\n        return f'{row[\"icon\"]}&lt;br&gt;{row[\"los\"]:.0f}'\n    else:\n        return row[\"icon\"]\n\nfull_patient_df_plus_pos = full_patient_df_plus_pos.assign(icon=full_patient_df_plus_pos.apply(add_los_to_icon, axis=1))\n\n\ndef indicate_delay_via_icon(row):\n    if row[\"delayed discharge\"] is True:\n        return f'{row[\"icon\"]}&lt;br&gt;*'\n    else:\n        return f'{row[\"icon\"]}&lt;br&gt; '\n\nfull_patient_df_plus_pos = full_patient_df_plus_pos.assign(icon=full_patient_df_plus_pos.apply(indicate_delay_via_icon, axis=1))\n\ncancelled_due_to_no_bed_available = len(full_log_with_patient_details[full_log_with_patient_details['event'] == \"no_bed_available\"][\"patient\"].unique())\ntotal_patients = len(full_log_with_patient_details[\"patient\"].unique())\n\ncancelled_perc = cancelled_due_to_no_bed_available/total_patients\n\n# st.markdown(f\"Surgeries cancelled due to no bed being available in time: {cancelled_perc:.2%} ({cancelled_due_to_no_bed_available} of {total_patients})\")\n\n# st.markdown(\n#     \"\"\"\n#     **Key**:\n\n#     🦵1️⃣: Primary Knee\n\n#     🦵♻️: Revision Knee\n\n#     🕺1️⃣: Primary Hip\n\n#     🕺♻️: Revision Hip\n\n#     🦵✳️: Primary Unicompartment Knee\n\n#     An asterisk (*) indicates that the patient has a delayed discharge from the ward.\n\n#     The numbers below patients indicate their length of stay.\n\n#     Note that the \"No Bed Available: Surgery Cancelled\" and \"Discharged from Hospital after Recovery\" stages in the animation are lagged by one day.\n#     For example, on the 2nd of July, this will show the patients who had their surgery cancelled on 1st July or were discharged on 1st July.\n#     These steps are included to make it easier to understand the destinations of different clients, but due to the size of the simulation step shown (1 day) it is difficult to demonstrate this differently.\n#     \"\"\"\n# )\n\n\ncounts_not_avail = full_patient_df_plus_pos[full_patient_df_plus_pos['event']=='no_bed_available'][['snapshot_time','patient']].groupby('snapshot_time').agg('count')\ncounts_not_avail = counts_not_avail.reset_index().merge(full_patient_df_plus_pos[['snapshot_time']].drop_duplicates(), how='right').sort_values('snapshot_time')\ncounts_not_avail['patient'] = counts_not_avail['patient'].fillna(0)\ncounts_not_avail['running_total'] = counts_not_avail['patient'].cumsum()\n\ncounts_not_avail = counts_not_avail.reset_index(drop=True)\n\ncounts_not_avail\n\n\n\n\n\n\n\n\nsnapshot_time\npatient\nrunning_total\n\n\n\n\n0\n0\n0.0\n0.0\n\n\n1\n1\n0.0\n0.0\n\n\n2\n2\n0.0\n0.0\n\n\n3\n3\n3.0\n3.0\n\n\n4\n4\n9.0\n12.0\n\n\n...\n...\n...\n...\n\n\n56\n56\n0.0\n265.0\n\n\n57\n57\n0.0\n265.0\n\n\n58\n58\n8.0\n273.0\n\n\n59\n59\n7.0\n280.0\n\n\n60\n60\n8.0\n288.0\n\n\n\n\n61 rows × 3 columns\n\n\n\n\n\ncounts_ops_completed = full_patient_df_plus_pos[full_patient_df_plus_pos['event']=='post_surgery_stay_begins'][['snapshot_time','patient']].drop_duplicates('patient').groupby('snapshot_time').agg('count')\ncounts_ops_completed = counts_ops_completed.reset_index().merge(full_patient_df_plus_pos[['snapshot_time']].drop_duplicates(), how='right').sort_values('snapshot_time')\ncounts_ops_completed['patient'] = counts_ops_completed['patient'].fillna(0)\ncounts_ops_completed['running_total'] = counts_ops_completed['patient'].cumsum()\n\ncounts_ops_completed = counts_ops_completed.reset_index(drop=True)\n\ncounts_ops_completed\n\n\n\n\n\n\n\n\nsnapshot_time\npatient\nrunning_total\n\n\n\n\n0\n0\n17.0\n17.0\n\n\n1\n1\n17.0\n34.0\n\n\n2\n2\n7.0\n41.0\n\n\n3\n3\n5.0\n46.0\n\n\n4\n4\n7.0\n53.0\n\n\n...\n...\n...\n...\n\n\n56\n56\n17.0\n407.0\n\n\n57\n57\n6.0\n413.0\n\n\n58\n58\n6.0\n419.0\n\n\n59\n59\n7.0\n426.0\n\n\n60\n60\n7.0\n433.0\n\n\n\n\n61 rows × 3 columns\n\n\n\n\ncounts_not_avail = counts_not_avail.merge(counts_ops_completed.rename(columns={'running_total':'completed'}), how=\"left\", on=\"snapshot_time\")\ncounts_not_avail['perc_slots_lost'] = counts_not_avail['running_total'] / (counts_not_avail['running_total'] + counts_not_avail['completed'])\n\ncounts_not_avail = counts_not_avail.reset_index(drop=True)\n\ncounts_not_avail\n\n\n\n\n\n\n\n\nsnapshot_time\npatient_x\nrunning_total\npatient_y\ncompleted\nperc_slots_lost\n\n\n\n\n0\n0\n0.0\n0.0\n17.0\n17.0\n0.000000\n\n\n1\n1\n0.0\n0.0\n17.0\n34.0\n0.000000\n\n\n2\n2\n0.0\n0.0\n7.0\n41.0\n0.000000\n\n\n3\n3\n3.0\n3.0\n5.0\n46.0\n0.061224\n\n\n4\n4\n9.0\n12.0\n7.0\n53.0\n0.184615\n\n\n...\n...\n...\n...\n...\n...\n...\n\n\n56\n56\n0.0\n265.0\n17.0\n407.0\n0.394345\n\n\n57\n57\n0.0\n265.0\n6.0\n413.0\n0.390855\n\n\n58\n58\n8.0\n273.0\n6.0\n419.0\n0.394509\n\n\n59\n59\n7.0\n280.0\n7.0\n426.0\n0.396601\n\n\n60\n60\n8.0\n288.0\n7.0\n433.0\n0.399445\n\n\n\n\n61 rows × 6 columns\n\n\n\n\nfig = generate_animation(\n        full_entity_df_plus_pos=full_patient_df_plus_pos,\n        entity_col_name=\"patient\",\n        event_position_df=event_position_df,\n        scenario=args,\n        plotly_height=950,\n        plotly_width=1200,\n        override_x_max=800,\n        override_y_max=1200,\n        entity_icon_size=14,\n        text_size=14,\n        wrap_resources_at=40,\n        gap_between_resources=15,\n        include_play_button=True,\n        add_background_image=None,\n        # we want the stage labels, but due to a bug\n        # when we add in additional animated traces later,\n        # they will disappear - so better to leave them out here\n        # and then re-add them manually\n        display_stage_labels=False,\n        custom_resource_icon=\"🛏️\",\n        time_display_units=\"d\",\n        simulation_time_unit=\"days\",\n        start_date=\"2022-06-27\",\n        setup_mode=False,\n        frame_duration=1500, #milliseconds\n        frame_transition_duration=1000, #milliseconds\n        debug_mode=False\n    )\n\nfig\n\nUnable to display output for mime type(s): application/vnd.plotly.v1+json\n\n\n\nlen(fig.data)\n\n2\n\n\n\n# Set up the desired subplot layout\nsp = make_subplots(\n    rows=2,\n    cols=1,\n    row_heights=[0.85, 0.15],\n    subplot_titles=(\n        \"\",\n        \"Daily lost slots\"\n        )\n    )\n\n# Overwrite the domain of our original x and y axis with domain from the new axis\nfig.layout['xaxis']['domain'] = sp.layout['xaxis']['domain']\nfig.layout['yaxis']['domain'] = sp.layout['yaxis']['domain']\n\n# Add in the attributes for the secondary axis from our subplot\nfig.layout['xaxis2'] = sp.layout['xaxis2']\nfig.layout['yaxis2'] = sp.layout['yaxis2']\n\n# Final key step - copy over the _grid_ref attribute\n# This isn't meant to be something we modify but it's an essential\n# part of the subplot code because otherwise plotly doesn't truly know\n# how the different subplots are arranged and referenced\nfig._grid_ref = sp._grid_ref\n\n\nprint(len(fig.data))\n\n2\n\n\n\n#####################################################\n# Adding additional animation traces\n#####################################################\n\n#####################################################\n# Initialize static and animated traces\n#####################################################\n\n## First, add each trace so it will show up initially\n\n# Plotly requires that all traces that will appear in animation frames are first\n# defined in `fig.data`. Otherwise, they appear to \"fly in\" from undefined positions,\n# or exhibit flickering due to missing interpolation references.\n\n# We add each animated trace in order, with placeholder data and correct styling,\n# so the animation engine has full knowledge of the traces from the outset.\n\n# Due to issues detailed in the following SO threads, it's essential to initialize the traces\n# outside of the frames argument else they will not show up at all (or show up intermittently)\n# https://stackoverflow.com/questions/69867334/multiple-traces-per-animation-frame-in-plotly\n# https://stackoverflow.com/questions/69367344/plotly-animating-a-variable-number-of-traces-in-each-frame-in-r\n# TODO: More explanation and investigation needed of why sometimes traces do and don't show up after being added in\n# via this method. Behaviour seems very inconsistent and not always logical (e.g. order you put traces in to the later\n# loop sometimes seems to make a difference but sometimes doesn't; making initial trace transparent sometimes seems to\n# stop it showing up when added in the frames but not always; sometimes the initial trace doesn't disappear).\n\n# 1. BED ICONS TRACE (animated, so must be initialized)\n# This trace is already in `fig.data[1]`, so we can simply re-add it to anchor it.\n# fig.add_trace(go.Scatter(x=[100], y=[100]))\n\nfig.add_trace(fig.data[1])\n\nprint(f\"Length after adding bed trace: {len(fig.data)}\")\n\n# 2. EVENT LABELS (static position text, but added dynamically per frame to avoid disappearing)\n# Add trace for the event labels (as these get lost from the animation once we start trying to add other things in,\n# so need manually re-adding)\nfig.add_trace(go.Scatter(\n        x=[pos+10 for pos in event_position_df['x'].to_list()],\n        y=event_position_df['y'].to_list(),\n        mode=\"text\",\n        name=\"\",\n        text=event_position_df['label'].to_list(),\n        textposition=\"middle right\",\n        hoverinfo='none'\n    ))\n\nprint(f\"Length after adding 'position labels:' trace: {len(fig.data)}\")\n\n# 3. OPERATIONS COMPLETED TEXT (animated text annotation)\n# Add animated text trace that gives running total of operations completed\nfig.add_trace(go.Scatter(\n                x=[100],\n                y=[30],\n                text=\"\",\n                # text=f\"Operations Completed: {int(counts_ops_completed['running_total'][0])}\",\n                mode='text',\n                textfont=dict(size=20),\n                # opacity=0,\n                showlegend=False,\n        ))\n\nprint(f\"Length after adding 'operations completed:' trace: {len(fig.data)}\")\n\n# 4. SLOTS LOST TEXT (animated text annotation)\n# Add animated trace giving running total of slots lost and percentage of total slots this represents\nfig.add_trace(go.Scatter(\n    x=[600],\n    y=[850],\n    text=\"\",\n    # text=f\"Total slots lost: {int(counts_not_avail['running_total'][0])}&lt;br&gt;({counts_not_avail['perc_slots_lost'][0]:.1%})\",\n    mode='text',\n    textfont=dict(size=20),\n    # opacity=0,\n    showlegend=False,\n))\n\nprint(f\"Length after adding 'slots lost:' trace: {len(fig.data)}\")\n\n\n# # 5. LINE PLOT ON SECONDARY AXIS (animated line in subplot)\n# # Initialize with a single point and assign it to subplot axes (x2/y2)\n# fig.add_trace(go.Scatter(\n#     x=[counts_not_avail['snapshot_time'].iloc[0]],\n#     y=[counts_not_avail['patient_x'].iloc[0]],\n#     mode=\"lines\",\n#     line=dict(color=\"rgba(0,0,0,0.2)\"),  # semi-transparent initial\n#     showlegend=False,\n#     name=\"slots_lost_line\",\n#     xaxis=\"x2\",\n#     yaxis=\"y2\"\n# ))\n\n# Add an initial trace to our secondary line chart\nfig.add_trace(go.Scatter(\n    x=counts_not_avail['snapshot_time'],\n    y=counts_not_avail['patient_x'],\n    mode='lines',\n    showlegend=False,\n    # name='line',\n    opacity=0.2,\n    xaxis=\"x2\",\n    yaxis=\"y2\"\n    # We place it in our new subplot using the following line\n), row=2, col=1)\n\nprint(f\"Length after adding additional line plot trace: {len(fig.data)}\")\n\n# Ensure these all have the right text size\nfig.update_traces(textfont_size=14)\n\nLength after adding bed trace: 3\nLength after adding 'position labels:' trace: 4\nLength after adding 'operations completed:' trace: 5\nLength after adding 'slots lost:' trace: 6\nLength after adding additional line plot trace: 7\n\n\nUnable to display output for mime type(s): application/vnd.plotly.v1+json\n\n\n\n\n##########################################################\n# Define animation frames: one per simulation time step\n##########################################################\n\n##########################################################\n# Now we need to add our traces to each individual frame\n##########################################################\n# IMPORTANT: To work correctly, these need to be provided in the same order as the traces above\n\n# This includes:\n# 0: bed icons\n# 1: event labels\n# 2: operations completed text\n# 3: slots lost text\n# 4: time series line in subplot\n\n# # Now ensure we tell it which traces we are animating\n# # (as per https://chart-studio.plotly.com/~empet/15243/animating-traces-in-subplotsbr/#/)\nfor i, frame in enumerate(fig.frames):\n    # Your original frame.data\n    # This will be a tuple\n    original_data = frame.data\n\n    # The new data you want to add for this specific frame\n    new_data = (\n        # 0: bed icons\n\n        fig.data[1],\n\n        # 1: Position labels\n        go.Scatter(\n            x=[pos+10 for pos in event_position_df['x'].to_list()],\n            y=event_position_df['y'].to_list(),\n            mode=\"text\",\n            text=event_position_df['label'].to_list(),\n            textposition=\"middle right\",\n            hoverinfo='none',\n            showlegend=False,\n        ),\n\n        # 2: Slots used/operations occurred\n        go.Scatter(\n            x=[100],\n            y=[30],\n            text=f\"Operations Completed: {int(counts_ops_completed.sort_values('snapshot_time')['running_total'][i])}\",\n            mode='text',\n            textfont=dict(size=20),\n            showlegend=False,\n        ),\n\n        # 3: Slots lost\n        go.Scatter(\n            x=[600],\n            y=[800],\n            text=f\"Total slots lost: {int(counts_not_avail.sort_values('snapshot_time')['running_total'][i])}&lt;br&gt;({counts_not_avail.sort_values('snapshot_time')['perc_slots_lost'][i]:.1%})\",\n            mode='text',\n            textfont=dict(size=20),\n            showlegend=False,\n        ),\n\n        # 4: Line subplot\n        go.Scatter(\n            x=counts_not_avail.sort_values('snapshot_time')['snapshot_time'][0: i+1].values,\n            y=counts_not_avail.sort_values('snapshot_time')['patient_x'][0: i+1].values,\n            mode=\"lines\",\n            showlegend=False,\n            name=\"line_subplot\",\n            xaxis='x2',\n            yaxis='y2'\n        ),\n    )\n\n    print(f\"Type of new data: {type(new_data)}\")\n\n    # Combine the original frame data with your new data\n    frame.data = original_data + new_data\n\n    print(f\"Type of final frame data: {type(frame.data)}\")\n\nfig\n\nType of new data: &lt;class 'tuple'&gt;\nType of final frame data: &lt;class 'tuple'&gt;\nType of new data: &lt;class 'tuple'&gt;\nType of final frame data: &lt;class 'tuple'&gt;\nType of new data: &lt;class 'tuple'&gt;\nType of final frame data: &lt;class 'tuple'&gt;\nType of new data: &lt;class 'tuple'&gt;\nType of final frame data: &lt;class 'tuple'&gt;\nType of new data: &lt;class 'tuple'&gt;\nType of final frame data: &lt;class 'tuple'&gt;\nType of new data: &lt;class 'tuple'&gt;\nType of final frame data: &lt;class 'tuple'&gt;\nType of new data: &lt;class 'tuple'&gt;\nType of final frame data: &lt;class 'tuple'&gt;\nType of new data: &lt;class 'tuple'&gt;\nType of final frame data: &lt;class 'tuple'&gt;\nType of new data: &lt;class 'tuple'&gt;\nType of final frame data: &lt;class 'tuple'&gt;\nType of new data: &lt;class 'tuple'&gt;\nType of final frame data: &lt;class 'tuple'&gt;\nType of new data: &lt;class 'tuple'&gt;\nType of final frame data: &lt;class 'tuple'&gt;\nType of new data: &lt;class 'tuple'&gt;\nType of final frame data: &lt;class 'tuple'&gt;\nType of new data: &lt;class 'tuple'&gt;\nType of final frame data: &lt;class 'tuple'&gt;\nType of new data: &lt;class 'tuple'&gt;\nType of final frame data: &lt;class 'tuple'&gt;\nType of new data: &lt;class 'tuple'&gt;\nType of final frame data: &lt;class 'tuple'&gt;\nType of new data: &lt;class 'tuple'&gt;\nType of final frame data: &lt;class 'tuple'&gt;\nType of new data: &lt;class 'tuple'&gt;\nType of final frame data: &lt;class 'tuple'&gt;\nType of new data: &lt;class 'tuple'&gt;\nType of final frame data: &lt;class 'tuple'&gt;\nType of new data: &lt;class 'tuple'&gt;\nType of final frame data: &lt;class 'tuple'&gt;\nType of new data: &lt;class 'tuple'&gt;\nType of final frame data: &lt;class 'tuple'&gt;\nType of new data: &lt;class 'tuple'&gt;\nType of final frame data: &lt;class 'tuple'&gt;\nType of new data: &lt;class 'tuple'&gt;\nType of final frame data: &lt;class 'tuple'&gt;\nType of new data: &lt;class 'tuple'&gt;\nType of final frame data: &lt;class 'tuple'&gt;\nType of new data: &lt;class 'tuple'&gt;\nType of final frame data: &lt;class 'tuple'&gt;\nType of new data: &lt;class 'tuple'&gt;\nType of final frame data: &lt;class 'tuple'&gt;\nType of new data: &lt;class 'tuple'&gt;\nType of final frame data: &lt;class 'tuple'&gt;\nType of new data: &lt;class 'tuple'&gt;\nType of final frame data: &lt;class 'tuple'&gt;\nType of new data: &lt;class 'tuple'&gt;\nType of final frame data: &lt;class 'tuple'&gt;\nType of new data: &lt;class 'tuple'&gt;\nType of final frame data: &lt;class 'tuple'&gt;\nType of new data: &lt;class 'tuple'&gt;\nType of final frame data: &lt;class 'tuple'&gt;\nType of new data: &lt;class 'tuple'&gt;\nType of final frame data: &lt;class 'tuple'&gt;\nType of new data: &lt;class 'tuple'&gt;\nType of final frame data: &lt;class 'tuple'&gt;\nType of new data: &lt;class 'tuple'&gt;\nType of final frame data: &lt;class 'tuple'&gt;\nType of new data: &lt;class 'tuple'&gt;\nType of final frame data: &lt;class 'tuple'&gt;\nType of new data: &lt;class 'tuple'&gt;\nType of final frame data: &lt;class 'tuple'&gt;\nType of new data: &lt;class 'tuple'&gt;\nType of final frame data: &lt;class 'tuple'&gt;\nType of new data: &lt;class 'tuple'&gt;\nType of final frame data: &lt;class 'tuple'&gt;\nType of new data: &lt;class 'tuple'&gt;\nType of final frame data: &lt;class 'tuple'&gt;\nType of new data: &lt;class 'tuple'&gt;\nType of final frame data: &lt;class 'tuple'&gt;\nType of new data: &lt;class 'tuple'&gt;\nType of final frame data: &lt;class 'tuple'&gt;\nType of new data: &lt;class 'tuple'&gt;\nType of final frame data: &lt;class 'tuple'&gt;\nType of new data: &lt;class 'tuple'&gt;\nType of final frame data: &lt;class 'tuple'&gt;\nType of new data: &lt;class 'tuple'&gt;\nType of final frame data: &lt;class 'tuple'&gt;\nType of new data: &lt;class 'tuple'&gt;\nType of final frame data: &lt;class 'tuple'&gt;\nType of new data: &lt;class 'tuple'&gt;\nType of final frame data: &lt;class 'tuple'&gt;\nType of new data: &lt;class 'tuple'&gt;\nType of final frame data: &lt;class 'tuple'&gt;\nType of new data: &lt;class 'tuple'&gt;\nType of final frame data: &lt;class 'tuple'&gt;\nType of new data: &lt;class 'tuple'&gt;\nType of final frame data: &lt;class 'tuple'&gt;\nType of new data: &lt;class 'tuple'&gt;\nType of final frame data: &lt;class 'tuple'&gt;\nType of new data: &lt;class 'tuple'&gt;\nType of final frame data: &lt;class 'tuple'&gt;\nType of new data: &lt;class 'tuple'&gt;\nType of final frame data: &lt;class 'tuple'&gt;\nType of new data: &lt;class 'tuple'&gt;\nType of final frame data: &lt;class 'tuple'&gt;\nType of new data: &lt;class 'tuple'&gt;\nType of final frame data: &lt;class 'tuple'&gt;\nType of new data: &lt;class 'tuple'&gt;\nType of final frame data: &lt;class 'tuple'&gt;\nType of new data: &lt;class 'tuple'&gt;\nType of final frame data: &lt;class 'tuple'&gt;\nType of new data: &lt;class 'tuple'&gt;\nType of final frame data: &lt;class 'tuple'&gt;\nType of new data: &lt;class 'tuple'&gt;\nType of final frame data: &lt;class 'tuple'&gt;\nType of new data: &lt;class 'tuple'&gt;\nType of final frame data: &lt;class 'tuple'&gt;\nType of new data: &lt;class 'tuple'&gt;\nType of final frame data: &lt;class 'tuple'&gt;\nType of new data: &lt;class 'tuple'&gt;\nType of final frame data: &lt;class 'tuple'&gt;\nType of new data: &lt;class 'tuple'&gt;\nType of final frame data: &lt;class 'tuple'&gt;\n\n\nUnable to display output for mime type(s): application/vnd.plotly.v1+json\n\n\n\n# After modifying the data in all frames, now correctly set the 'traces' property.\n\n# Get the total number of animated traces from the first (now updated) frame.\nnum_total_traces = len(fig.frames[0].data)\n\n# Create the list of indices that all traces will be mapped to.\n# This should be [0, 1, 2, ..., n-1] where n is the total number of animated traces.\ntrace_indices = list(range(num_total_traces))\n\n# Apply this correct list of indices to every frame.\nfor frame in fig.frames:\n    frame.traces = trace_indices\n\n# Finally, match these new traces with the text size used elsewhere\nfig.update_traces(textfont_size=14)\n\nUnable to display output for mime type(s): application/vnd.plotly.v1+json\n\n\n\n# Replace each frame's data with a consistent list of updated traces\n\n# for i, frame in enumerate(fig.frames):\n#     if i in [0, 1, 2, 3, 4]:\n#         print(frame.data)\n#     # Overwrite the frame.data with\n#     frame.data =  (\n#     # The original frame data (the animation we defined using the standard vidigi code)\n#     frame.data +\n#     # 0: bed icons\n#     (fig.data[1], ) +\n#     # 1: Slots used/operations occurred\n#     (\n#     go.Scatter(\n#         x=[100],\n#         y=[30],\n#         text=f\"Operations Completed: {int(counts_ops_completed['running_total'][i])}\",\n#         mode='text',\n#         textfont=dict(size=20),\n#         showlegend=False,\n#     ), )\n#         +\n#     # 2: Slots lost\n#     (go.Scatter(\n#             x=[600],\n#             y=[800],\n#             text=f\"Total slots lost: {int(counts_not_avail['running_total'][i])}&lt;br&gt;({counts_not_avail['perc_slots_lost'][i]:.1%})\",\n#             mode='text',\n#             textfont=dict(size=20),\n#             showlegend=False,\n#         ),) +\n\n#     # 3: Position labels\n#     (go.Scatter(\n#         x=[pos+10 for pos in event_position_df['x'].to_list()],\n#         y=event_position_df['y'].to_list(),\n#         mode=\"text\",\n#         name=\"\",\n#         text=event_position_df['label'].to_list(),\n#         textposition=\"middle right\",\n#         hoverinfo='none'\n#     ),) +\n\n#     # 4: Line subplot\n#     (go.Scatter(\n#         x=counts_not_avail['snapshot_time'][0: i+1].values,\n#         y=counts_not_avail['patient_x'][0: i+1].values,\n#         mode=\"lines\",\n#         # name=\"line\",\n#         # hoverinfo='none',\n#         showlegend=False,\n#         name=\"line_subplot\",\n#         # line=dict(color=\"#f71707\"),\n#         xaxis='x2',\n#         yaxis='y2'\n#     ),)\n\n#     )"
  },
  {
    "objectID": "examples/example_13_additional_synchronised_traces_method_1/synchronised_traces_BROKEN.html",
    "href": "examples/example_13_additional_synchronised_traces_method_1/synchronised_traces_BROKEN.html",
    "title": "Additional Synchronised Traces - Orthopaedic Ward - Hospital Efficiency Project",
    "section": "",
    "text": "This is the orthopaedic surgery model developed as part of the hospital efficiency project.\noriginal model author = Harper, Alison and Monks, Thomas\nlicense = MIT\ntitle = Hospital Efficiency Project Orthopaedic Planning Model Discrete-Event Simulation\nurl = https://github.com/AliHarp/HEP\nIt has been used as a test case here to allow the development and testing of several key features of the event log animations:\n\nadding of logging to a model from scratch\nensuring the requirement to use simpy stores instead of simpy resources doesn’t prevent the uses of certain common modelling patterns (in this case, conditional logic where patients will leave the system if a bed is not available within a specified period of time)\ndisplaying different icons for different classes of patients\ndisplaying custom resource icons\ndisplaying additional static information as part of the icon (in this case, whether the client’s discharge is delayed)\ndisplaying information that updates with each animation step as part of the icon (in this case, the LoS of the patient at each time point)\n\n\nimport gc\nimport time\nimport datetime as dt\nimport streamlit as st\nimport pandas as pd\nimport plotly.express as px\nimport plotly.graph_objects as go\nfrom examples.example_13_additional_synchronised_traces_method_1.simulation_execution_functions import multiple_replications\nfrom examples.example_13_additional_synchronised_traces_method_1.model_classes import Scenario, Schedule\nfrom vidigi.prep import reshape_for_animations, generate_animation_df\nfrom vidigi.animation import generate_animation\nfrom plotly.subplots import make_subplots\n\n\nTRACE = True\ndebug_mode=True\n\nschedule = Schedule()\n\n4 theatres\n5 day/week\nEach theatre has three sessions per day:\nMorning: 1 revision OR 2 primary\nAfternoon: 1 revision OR 2 primary\nEvening: 1 primary\n40 ring-fenced beds for recovery from these operations\n\n(pd.DataFrame.from_dict(schedule.sessions_per_weekday, orient=\"index\")\n        .rename(columns={0: \"Sessions\"}).merge(\n\n        pd.DataFrame.from_dict(schedule.theatres_per_weekday, orient=\"index\")\n            .rename(columns={0: \"Theatre Capacity\"}),\n            left_index=True, right_index=True\n\n        ).merge(\n\n        pd.DataFrame.from_dict(schedule.allocation, orient=\"index\"),\n        left_index=True, right_index=True\n\n        ))\n\n\n\n\n\n\n\n\nSessions\nTheatre Capacity\n0\n1\n2\n\n\n\n\nMonday\n3\n4\n2P_or_1R\n2P_or_1R\n1P\n\n\nTuesday\n3\n4\n2P_or_1R\n2P_or_1R\n1P\n\n\nWednesday\n3\n4\n2P_or_1R\n2P_or_1R\n1P\n\n\nThursday\n3\n4\n2P_or_1R\n2P_or_1R\n1P\n\n\nFriday\n3\n4\n2P_or_1R\n2P_or_1R\n1P\n\n\nSaturday\n0\n0\nNone\nNone\nNone\n\n\nSunday\n0\n0\nNone\nNone\nNone\n\n\n\n\n\n\n\n\nn_beds = 40\n\nprimary_hip_los = 4.4\n\nprimary_knee_los = 4.7\n\nrevision_hip_los = 6.9\n\nrevision_knee_los = 7.2\n\nunicompart_knee_los = 2.9\n\nlos_delay = 16.5\nlos_delay_sd = 15.2\n\nprop_delay = 0.076\n\nreplications = 30\nruntime = 60\nwarmup=7\n\nargs = Scenario(schedule=schedule,\n                primary_hip_mean_los=primary_hip_los,\n                primary_knee_mean_los=primary_knee_los,\n                revision_hip_mean_los=revision_hip_los,\n                revision_knee_mean_los=revision_knee_los,\n                unicompart_knee_mean_los=unicompart_knee_los,\n                prob_ward_delay=prop_delay,\n                n_beds=n_beds,\n                delay_post_los_mean=los_delay,\n                delay_post_los_sd=los_delay_sd\n                )\n\n\nresults = multiple_replications(\n                return_detailed_logs=True,\n                scenario=args,\n                n_reps=replications,\n                results_collection=runtime\n            )\n\n\n\n\n# Join the event log with a list of patients to add a column that will determine\n# the icon set used for a patient (in this case, we want to distinguish between the\n# knee/hip patients)\nevent_log = results[4]\nevent_log = event_log[event_log['rep'] == 1]\nevent_log['patient'] = event_log['patient'].astype('str') + event_log['pathway']\n\nprimary_patients = results[2]\nprimary_patients = primary_patients[primary_patients['rep'] == 1]\nprimary_patients['patient class'] = primary_patients['patient class'].str.title()\nprimary_patients['ID'] = primary_patients['ID'].astype('str') + primary_patients['patient class']\n\nrevision_patients = results[3]\nrevision_patients = revision_patients[revision_patients['rep'] == 1]\nrevision_patients['patient class'] = revision_patients['patient class'].str.title()\nrevision_patients['ID'] = revision_patients['ID'].astype('str') + revision_patients['patient class']\n\nfull_log_with_patient_details = event_log.merge(pd.concat([primary_patients, revision_patients]),\n                                                    how=\"left\",\n                                                left_on=[\"patient\", \"pathway\"],\n                                                right_on=[\"ID\", \"patient class\"]).reset_index(drop=True).drop(columns=\"ID\")\n\npid_table = full_log_with_patient_details[['patient']].drop_duplicates().reset_index(drop=True).reset_index(drop=False).rename(columns={'index': 'pid'})\n\nfull_log_with_patient_details = full_log_with_patient_details.merge(pid_table, how='left', on='patient').drop(columns='patient').rename(columns={'pid':'patient'})\n\nC:\\Users\\Sammi\\AppData\\Local\\Temp\\ipykernel_50528\\3505082114.py:50: SettingWithCopyWarning:\n\n\nA value is trying to be set on a copy of a slice from a DataFrame.\nTry using .loc[row_indexer,col_indexer] = value instead\n\nSee the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n\nC:\\Users\\Sammi\\AppData\\Local\\Temp\\ipykernel_50528\\3505082114.py:54: SettingWithCopyWarning:\n\n\nA value is trying to be set on a copy of a slice from a DataFrame.\nTry using .loc[row_indexer,col_indexer] = value instead\n\nSee the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n\nC:\\Users\\Sammi\\AppData\\Local\\Temp\\ipykernel_50528\\3505082114.py:55: SettingWithCopyWarning:\n\n\nA value is trying to be set on a copy of a slice from a DataFrame.\nTry using .loc[row_indexer,col_indexer] = value instead\n\nSee the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n\nC:\\Users\\Sammi\\AppData\\Local\\Temp\\ipykernel_50528\\3505082114.py:59: SettingWithCopyWarning:\n\n\nA value is trying to be set on a copy of a slice from a DataFrame.\nTry using .loc[row_indexer,col_indexer] = value instead\n\nSee the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n\nC:\\Users\\Sammi\\AppData\\Local\\Temp\\ipykernel_50528\\3505082114.py:60: SettingWithCopyWarning:\n\n\nA value is trying to be set on a copy of a slice from a DataFrame.\nTry using .loc[row_indexer,col_indexer] = value instead\n\nSee the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n\n\n\n\n\nevent_position_df = pd.DataFrame([\n            # {'event': 'arrival', 'x':  10, 'y': 250, 'label': \"Arrival\" },\n\n            # Triage - minor and trauma\n            {'event': 'enter_queue_for_bed',\n                'x':  300, 'y': 650, 'label': \"Waiting for&lt;br&gt;Availability of&lt;br&gt;Bed to be Confirmed&lt;br&gt;Before Surgery\" },\n\n            {'event': 'no_bed_available',\n                'x':  700, 'y': 650, 'label': \"No Bed&lt;br&gt;Available:&lt;br&gt;Surgery Cancelled\" },\n\n            {'event': 'post_surgery_stay_begins',\n                'x':  750, 'y': 220, 'resource':'n_beds', 'label': \"In Bed:&lt;br&gt;Recovering from&lt;br&gt;Surgery\" },\n\n            {'event': 'discharged_after_stay',\n                'x':  770, 'y': 50, 'label': \"Discharged from Hospital&lt;br&gt;After Recovery\"}\n            # {'event': 'exit',\n            #  'x':  670, 'y': 100, 'label': \"Exit\"}\n\n            ])\n\n\nfull_patient_df = reshape_for_animations(full_log_with_patient_details,\n                                         entity_col_name=\"patient\",\n                                            every_x_time_units=1,\n                                            limit_duration=runtime,\n                                            step_snapshot_max=50,\n                                            debug_mode=debug_mode\n                                            )\n\nif debug_mode:\n    print(f'Reshaped animation dataframe finished construction at {time.strftime(\"%H:%M:%S\", time.localtime())}')\n\nIteration through time-unit-by-time-unit logs complete 12:10:38\nSnapshot df concatenation complete at 12:10:38\nReshaped animation dataframe finished construction at 12:10:38\n\n\n\nfull_patient_df_plus_pos = generate_animation_df(\n                            full_entity_df=full_patient_df,\n                            entity_col_name=\"patient\",\n                            event_position_df=event_position_df,\n                            wrap_queues_at=20,\n                            wrap_resources_at=40,\n                            step_snapshot_max=50,\n                            gap_between_entities=15,\n                            gap_between_resources=15,\n                            gap_between_queue_rows=175,\n                            gap_between_resource_rows=175,\n                            debug_mode=debug_mode\n                    )\n\nPlacement dataframe finished construction at 12:10:39\n\n\n\ndef set_icon(row):\n    if row[\"surgery type\"] == \"p_knee\":\n        return \"🦵&lt;br&gt;1️⃣&lt;br&gt; \"\n    elif row[\"surgery type\"] == \"r_knee\":\n        return \"🦵&lt;br&gt;♻️&lt;br&gt; \"\n    elif row[\"surgery type\"] == \"p_hip\":\n        return \"🕺&lt;br&gt;1️⃣&lt;br&gt; \"\n    elif row[\"surgery type\"] == \"r_hip\":\n        return \"🕺&lt;br&gt;♻️&lt;br&gt; \"\n    elif row[\"surgery type\"] == \"uni_knee\":\n        return \"🦵&lt;br&gt;✳️&lt;br&gt; \"\n    else:\n        return f\"CHECK&lt;br&gt;{row['icon']}\"\n\nfull_patient_df_plus_pos = full_patient_df_plus_pos.assign(icon=full_patient_df_plus_pos.apply(set_icon, axis=1))\n\n# TODO: Check why this doesn't seem to be working quite right for the 'discharged after stay'\n# step. e.g. 194Primary is discharged on 28th July showing a LOS of 1 but prior to this shows a LOS of 9.\ndef add_los_to_icon(row):\n    if row[\"event\"] == \"post_surgery_stay_begins\":\n        return f'{row[\"icon\"]}&lt;br&gt;{row[\"snapshot_time\"]-row[\"time\"]:.0f}'\n    elif row[\"event\"] == \"discharged_after_stay\":\n        return f'{row[\"icon\"]}&lt;br&gt;{row[\"los\"]:.0f}'\n    else:\n        return row[\"icon\"]\n\nfull_patient_df_plus_pos = full_patient_df_plus_pos.assign(icon=full_patient_df_plus_pos.apply(add_los_to_icon, axis=1))\n\n\ndef indicate_delay_via_icon(row):\n    if row[\"delayed discharge\"] is True:\n        return f'{row[\"icon\"]}&lt;br&gt;*'\n    else:\n        return f'{row[\"icon\"]}&lt;br&gt; '\n\nfull_patient_df_plus_pos = full_patient_df_plus_pos.assign(icon=full_patient_df_plus_pos.apply(indicate_delay_via_icon, axis=1))\n\ncancelled_due_to_no_bed_available = len(full_log_with_patient_details[full_log_with_patient_details['event'] == \"no_bed_available\"][\"patient\"].unique())\ntotal_patients = len(full_log_with_patient_details[\"patient\"].unique())\n\ncancelled_perc = cancelled_due_to_no_bed_available/total_patients\n\n# st.markdown(f\"Surgeries cancelled due to no bed being available in time: {cancelled_perc:.2%} ({cancelled_due_to_no_bed_available} of {total_patients})\")\n\n# st.markdown(\n#     \"\"\"\n#     **Key**:\n\n#     🦵1️⃣: Primary Knee\n\n#     🦵♻️: Revision Knee\n\n#     🕺1️⃣: Primary Hip\n\n#     🕺♻️: Revision Hip\n\n#     🦵✳️: Primary Unicompartment Knee\n\n#     An asterisk (*) indicates that the patient has a delayed discharge from the ward.\n\n#     The numbers below patients indicate their length of stay.\n\n#     Note that the \"No Bed Available: Surgery Cancelled\" and \"Discharged from Hospital after Recovery\" stages in the animation are lagged by one day.\n#     For example, on the 2nd of July, this will show the patients who had their surgery cancelled on 1st July or were discharged on 1st July.\n#     These steps are included to make it easier to understand the destinations of different clients, but due to the size of the simulation step shown (1 day) it is difficult to demonstrate this differently.\n#     \"\"\"\n# )\n\n\ncounts_not_avail = full_patient_df_plus_pos[full_patient_df_plus_pos['event']=='no_bed_available'][['snapshot_time','patient']].groupby('snapshot_time').agg('count')\ncounts_not_avail = counts_not_avail.reset_index().merge(full_patient_df_plus_pos[['snapshot_time']].drop_duplicates(), how='right').sort_values('snapshot_time')\ncounts_not_avail['patient'] = counts_not_avail['patient'].fillna(0)\ncounts_not_avail['running_total'] = counts_not_avail['patient'].cumsum()\n\ncounts_not_avail\n\n\n\n\n\n\n\n\nsnapshot_time\npatient\nrunning_total\n\n\n\n\n2\n0\n0.0\n0.0\n\n\n3\n1\n0.0\n0.0\n\n\n1\n2\n0.0\n0.0\n\n\n0\n3\n7.0\n7.0\n\n\n4\n4\n9.0\n16.0\n\n\n...\n...\n...\n...\n\n\n56\n56\n0.0\n261.0\n\n\n57\n57\n0.0\n261.0\n\n\n58\n58\n5.0\n266.0\n\n\n59\n59\n6.0\n272.0\n\n\n60\n60\n10.0\n282.0\n\n\n\n\n61 rows × 3 columns\n\n\n\n\n\ncounts_ops_completed = full_patient_df_plus_pos[full_patient_df_plus_pos['event']=='post_surgery_stay_begins'][['snapshot_time','patient']].drop_duplicates('patient').groupby('snapshot_time').agg('count')\ncounts_ops_completed = counts_ops_completed.reset_index().merge(full_patient_df_plus_pos[['snapshot_time']].drop_duplicates(), how='right').sort_values('snapshot_time')\ncounts_ops_completed['patient'] = counts_ops_completed['patient'].fillna(0)\ncounts_ops_completed['running_total'] = counts_ops_completed['patient'].cumsum()\n\ncounts_ops_completed\n\n\n\n\n\n\n\n\nsnapshot_time\npatient\nrunning_total\n\n\n\n\n2\n0\n16.0\n16.0\n\n\n3\n1\n17.0\n33.0\n\n\n1\n2\n8.0\n41.0\n\n\n0\n3\n5.0\n46.0\n\n\n4\n4\n7.0\n53.0\n\n\n...\n...\n...\n...\n\n\n56\n56\n12.0\n405.0\n\n\n57\n57\n7.0\n412.0\n\n\n58\n58\n6.0\n418.0\n\n\n59\n59\n8.0\n426.0\n\n\n60\n60\n5.0\n431.0\n\n\n\n\n61 rows × 3 columns\n\n\n\n\ncounts_not_avail = counts_not_avail.merge(counts_ops_completed.rename(columns={'running_total':'completed'}), how=\"left\", on=\"snapshot_time\")\ncounts_not_avail['perc_slots_lost'] = counts_not_avail['running_total'] / (counts_not_avail['running_total'] + counts_not_avail['completed'])\n\ncounts_not_avail\n\n\n\n\n\n\n\n\nsnapshot_time\npatient_x\nrunning_total\npatient_y\ncompleted\nperc_slots_lost\n\n\n\n\n0\n0\n0.0\n0.0\n16.0\n16.0\n0.000000\n\n\n1\n1\n0.0\n0.0\n17.0\n33.0\n0.000000\n\n\n2\n2\n0.0\n0.0\n8.0\n41.0\n0.000000\n\n\n3\n3\n7.0\n7.0\n5.0\n46.0\n0.132075\n\n\n4\n4\n9.0\n16.0\n7.0\n53.0\n0.231884\n\n\n...\n...\n...\n...\n...\n...\n...\n\n\n56\n56\n0.0\n261.0\n12.0\n405.0\n0.391892\n\n\n57\n57\n0.0\n261.0\n7.0\n412.0\n0.387816\n\n\n58\n58\n5.0\n266.0\n6.0\n418.0\n0.388889\n\n\n59\n59\n6.0\n272.0\n8.0\n426.0\n0.389685\n\n\n60\n60\n10.0\n282.0\n5.0\n431.0\n0.395512\n\n\n\n\n61 rows × 6 columns\n\n\n\n\nfig = generate_animation(\n        full_entity_df_plus_pos=full_patient_df_plus_pos,\n        entity_col_name=\"patient\",\n        event_position_df=event_position_df,\n        scenario=args,\n        plotly_height=950,\n        plotly_width=1200,\n        override_x_max=800,\n        override_y_max=1200,\n        entity_icon_size=14,\n        text_size=14,\n        wrap_resources_at=40,\n        gap_between_resources=15,\n        include_play_button=True,\n        add_background_image=None,\n        # we want the stage labels, but due to a bug\n        # when we add in additional animated traces later,\n        # they will disappear - so better to leave them out here\n        # and then re-add them manually\n        display_stage_labels=False,\n        custom_resource_icon=\"🛏️\",\n        time_display_units=\"d\",\n        simulation_time_unit=\"days\",\n        start_date=\"2022-06-27\",\n        setup_mode=False,\n        frame_duration=1500, #milliseconds\n        frame_transition_duration=1000, #milliseconds\n        debug_mode=False\n    )\n\nfig\n\nUnable to display output for mime type(s): application/vnd.plotly.v1+json\n\n\n\nlen(fig.data)\n\n2\n\n\n\n# Set up the desired subplot layout\nsp = make_subplots(\n    rows=2,\n    cols=1,\n    row_heights=[0.85, 0.15],\n    subplot_titles=(\n        \"\",\n        \"Daily lost slots\"\n        )\n    )\n\n# Overwrite the domain of our original x and y axis with domain from the new axis\nfig.layout['xaxis']['domain'] = sp.layout['xaxis']['domain']\nfig.layout['yaxis']['domain'] = sp.layout['yaxis']['domain']\n\n# Add in the attributes for the secondary axis from our subplot\nfig.layout['xaxis2'] = sp.layout['xaxis2']\nfig.layout['yaxis2'] = sp.layout['yaxis2']\n\n# Final key step - copy over the _grid_ref attribute\n# This isn't meant to be something we modify but it's an essential\n# part of the subplot code because otherwise plotly doesn't truly know\n# how the different subplots are arranged and referenced\nfig._grid_ref = sp._grid_ref\n\n\nprint(len(fig.data))\n\n2\n\n\n\n#####################################################\n# Adding additional animation traces\n#####################################################\n\n#####################################################\n# Initialize static and animated traces\n#####################################################\n\n## First, add each trace so it will show up initially\n\n# Plotly requires that all traces that will appear in animation frames are first\n# defined in `fig.data`. Otherwise, they appear to \"fly in\" from undefined positions,\n# or exhibit flickering due to missing interpolation references.\n\n# We add each animated trace in order, with placeholder data and correct styling,\n# so the animation engine has full knowledge of the traces from the outset.\n\n# Due to issues detailed in the following SO threads, it's essential to initialize the traces\n# outside of the frames argument else they will not show up at all (or show up intermittently)\n# https://stackoverflow.com/questions/69867334/multiple-traces-per-animation-frame-in-plotly\n# https://stackoverflow.com/questions/69367344/plotly-animating-a-variable-number-of-traces-in-each-frame-in-r\n# TODO: More explanation and investigation needed of why sometimes traces do and don't show up after being added in\n# via this method. Behaviour seems very inconsistent and not always logical (e.g. order you put traces in to the later\n# loop sometimes seems to make a difference but sometimes doesn't; making initial trace transparent sometimes seems to\n# stop it showing up when added in the frames but not always; sometimes the initial trace doesn't disappear).\n\n# 1. BED ICONS TRACE (animated, so must be initialized)\n# This trace is already in `fig.data[1]`, so we can simply re-add it to anchor it.\n# fig.add_trace(go.Scatter(x=[100], y=[100]))\n\nfig.add_trace(fig.data[1])\n\nprint(f\"Length after adding bed trace: {len(fig.data)}\")\n\n# 2. OPERATIONS COMPLETED TEXT (animated text annotation)\n# Add animated text trace that gives running total of operations completed\nfig.add_trace(go.Scatter(\n                x=[100],\n                y=[30],\n                text=\"\",\n                # text=f\"Operations Completed: {int(counts_ops_completed['running_total'][0])}\",\n                mode='text',\n                textfont=dict(size=20),\n                # opacity=0,\n                showlegend=False,\n        ))\n\nprint(f\"Length after adding 'operations completed:' trace: {len(fig.data)}\")\n\n# 3. SLOTS LOST TEXT (animated text annotation)\n# Add animated trace giving running total of slots lost and percentage of total slots this represents\nfig.add_trace(go.Scatter(\n    x=[600],\n    y=[850],\n    text=\"\",\n    # text=f\"Total slots lost: {int(counts_not_avail['running_total'][0])}&lt;br&gt;({counts_not_avail['perc_slots_lost'][0]:.1%})\",\n    mode='text',\n    textfont=dict(size=20),\n    # opacity=0,\n    showlegend=False,\n))\n\nprint(f\"Length after adding 'slots lost:' trace: {len(fig.data)}\")\n\n# 4. EVENT LABELS (static position text, but added dynamically per frame to avoid disappearing)\n# Add trace for the event labels (as these get lost from the animation once we start trying to add other things in,\n# so need manually re-adding)\nfig.add_trace(go.Scatter(\n        x=[pos+10 for pos in event_position_df['x'].to_list()],\n        y=event_position_df['y'].to_list(),\n        mode=\"text\",\n        name=\"\",\n        text=event_position_df['label'].to_list(),\n        textposition=\"middle right\",\n        hoverinfo='none'\n    ))\n\nprint(f\"Length after adding 'position labels:' trace: {len(fig.data)}\")\n\n# # 5. LINE PLOT ON SECONDARY AXIS (animated line in subplot)\n# # Initialize with a single point and assign it to subplot axes (x2/y2)\n# fig.add_trace(go.Scatter(\n#     x=[counts_not_avail['snapshot_time'].iloc[0]],\n#     y=[counts_not_avail['patient_x'].iloc[0]],\n#     mode=\"lines\",\n#     line=dict(color=\"rgba(0,0,0,0.2)\"),  # semi-transparent initial\n#     showlegend=False,\n#     name=\"slots_lost_line\",\n#     xaxis=\"x2\",\n#     yaxis=\"y2\"\n# ))\n\n# Add an initial trace to our secondary line chart\nfig.add_trace(go.Scatter(\n    x=counts_not_avail['snapshot_time'],\n    y=counts_not_avail['patient_x'],\n    mode='lines',\n    showlegend=False,\n    # name='line',\n    opacity=0.2,\n    xaxis=\"x2\",\n    yaxis=\"y2\"\n    # We place it in our new subplot using the following line\n), row=2, col=1)\n\nprint(f\"Length after adding additional line plot trace: {len(fig.data)}\")\n\n# Ensure these all have the right text size\nfig.update_traces(textfont_size=14)\n\nLength after adding bed trace: 3\nLength after adding 'operations completed:' trace: 4\nLength after adding 'slots lost:' trace: 5\nLength after adding 'position labels:' trace: 6\nLength after adding additional line plot trace: 7\n\n\nUnable to display output for mime type(s): application/vnd.plotly.v1+json\n\n\n\n\n##########################################################\n# Define animation frames: one per simulation time step\n##########################################################\n\n##########################################################\n# Now we need to add our traces to each individual frame\n##########################################################\n# IMPORTANT: To work correctly, these need to be provided in the same order as the traces above\n\n# This includes:\n# 0: bed icons (static shape, but possibly moved)\n# 1: operations completed text\n# 2: slots lost text\n# 3: event labels\n# 4: time series line in subplot\n\ncounts_ops_completed = counts_ops_completed.sort_values('snapshot_time').reset_index()\ncounts_not_avail = counts_not_avail.sort_values('snapshot_time').reset_index()\n\n# # Now ensure we tell it which traces we are animating\n# # (as per https://chart-studio.plotly.com/~empet/15243/animating-traces-in-subplotsbr/#/)\nfor i, frame in enumerate(fig.frames):\n    # Your original frame.data\n    original_data = frame.data\n\n    # The new data you want to add for this specific frame\n    new_data = (\n        # 0: bed icons\n\n        fig.data[1],\n\n        # 1: Slots used/operations occurred\n        go.Scatter(\n            x=[100],\n            y=[30],\n            text=f\"Operations Completed: {int(counts_ops_completed['running_total'][i])}\",\n            mode='text',\n            textfont=dict(size=20),\n            showlegend=False,\n        ),\n\n        # 2: Slots lost\n        go.Scatter(\n            x=[600],\n            y=[800],\n            text=f\"Total slots lost: {int(counts_not_avail['running_total'][i])}&lt;br&gt;({counts_not_avail['perc_slots_lost'][i]:.1%})\",\n            mode='text',\n            textfont=dict(size=20),\n            showlegend=False,\n        ),\n\n        # 3: Position labels\n        go.Scatter(\n            x=[pos+10 for pos in event_position_df['x'].to_list()],\n            y=event_position_df['y'].to_list(),\n            mode=\"text\",\n            text=event_position_df['label'].to_list(),\n            textposition=\"middle right\",\n            hoverinfo='none',\n            showlegend=False,\n        ),\n\n        # 4: Line subplot\n        go.Scatter(\n            x=counts_not_avail[0: i+1].values,\n            y=counts_not_avail[0: i+1].values,\n            mode=\"lines\",\n            showlegend=False,\n            name=\"line_subplot\",\n            xaxis='x2',\n            yaxis='y2'\n        ),\n    )\n\n    # Combine the original frame data with your new data\n    frame.data = original_data + new_data\n\nfig\n\nUnable to display output for mime type(s): application/vnd.plotly.v1+json\n\n\n\n# After modifying the data in all frames, now correctly set the 'traces' property.\n\n# Get the total number of animated traces from the first (now updated) frame.\nnum_total_traces = len(fig.frames[0].data)\n\n# Create the list of indices that all traces will be mapped to.\n# This should be [0, 1, 2, ..., n-1] where n is the total number of animated traces.\ntrace_indices = list(range(num_total_traces))\n\n# Apply this correct list of indices to every frame.\nfor frame in fig.frames:\n    frame.traces = trace_indices\n\n# Finally, match these new traces with the text size used elsewhere\nfig.update_traces(textfont_size=14)\n\nUnable to display output for mime type(s): application/vnd.plotly.v1+json\n\n\n\n# Replace each frame's data with a consistent list of updated traces\n\n# for i, frame in enumerate(fig.frames):\n#     if i in [0, 1, 2, 3, 4]:\n#         print(frame.data)\n#     # Overwrite the frame.data with\n#     frame.data =  (\n#     # The original frame data (the animation we defined using the standard vidigi code)\n#     frame.data +\n#     # 0: bed icons\n#     (fig.data[1], ) +\n#     # 1: Slots used/operations occurred\n#     (\n#     go.Scatter(\n#         x=[100],\n#         y=[30],\n#         text=f\"Operations Completed: {int(counts_ops_completed['running_total'][i])}\",\n#         mode='text',\n#         textfont=dict(size=20),\n#         showlegend=False,\n#     ), )\n#         +\n#     # 2: Slots lost\n#     (go.Scatter(\n#             x=[600],\n#             y=[800],\n#             text=f\"Total slots lost: {int(counts_not_avail['running_total'][i])}&lt;br&gt;({counts_not_avail['perc_slots_lost'][i]:.1%})\",\n#             mode='text',\n#             textfont=dict(size=20),\n#             showlegend=False,\n#         ),) +\n\n#     # 3: Position labels\n#     (go.Scatter(\n#         x=[pos+10 for pos in event_position_df['x'].to_list()],\n#         y=event_position_df['y'].to_list(),\n#         mode=\"text\",\n#         name=\"\",\n#         text=event_position_df['label'].to_list(),\n#         textposition=\"middle right\",\n#         hoverinfo='none'\n#     ),) +\n\n#     # 4: Line subplot\n#     (go.Scatter(\n#         x=counts_not_avail['snapshot_time'][0: i+1].values,\n#         y=counts_not_avail['patient_x'][0: i+1].values,\n#         mode=\"lines\",\n#         # name=\"line\",\n#         # hoverinfo='none',\n#         showlegend=False,\n#         name=\"line_subplot\",\n#         # line=dict(color=\"#f71707\"),\n#         xaxis='x2',\n#         yaxis='y2'\n#     ),)\n\n#     )"
  },
  {
    "objectID": "examples/example_2_branching_multistep/ex_2_branching_multistep_case.html",
    "href": "examples/example_2_branching_multistep/ex_2_branching_multistep_case.html",
    "title": "Animation of a SimPy Model with Branching and Multiple Steps",
    "section": "",
    "text": "from examples.example_2_branching_multistep.ex_2_model_classes import Trial, g\nfrom vidigi.animation import animate_activity_log\nimport pandas as pd\nimport plotly.io as pio\npio.renderers.default = \"notebook\"\nimport os\nmy_trial = Trial()\n\nmy_trial.run_trial()\nmy_trial.all_event_logs.head(50)\n\n\n\n\n\n\n\n\npatient\npathway\nevent\nevent_type\ntime\nresource_id\nrun\n\n\n\n\n0\n1\nShared\narrival\narrival_departure\n3.285355\nNaN\n0\n\n\n1\n1\nNon-Trauma\ntriage_wait_begins\nqueue\n3.285355\nNaN\n0\n\n\n2\n1\nNon-Trauma\ntriage_begins\nresource_use\n3.285355\n1.0\n0\n\n\n3\n2\nShared\narrival\narrival_departure\n3.289691\nNaN\n0\n\n\n4\n2\nNon-Trauma\ntriage_wait_begins\nqueue\n3.289691\nNaN\n0\n\n\n5\n2\nNon-Trauma\ntriage_begins\nresource_use\n3.289691\n2.0\n0\n\n\n6\n1\nNon-Trauma\ntriage_complete\nresource_use_end\n7.364946\n1.0\n0\n\n\n7\n1\nNon-Trauma\nMINORS_registration_wait_begins\nqueue\n7.364946\nNaN\n0\n\n\n8\n1\nNon-Trauma\nMINORS_registration_begins\nresource_use\n7.364946\n1.0\n0\n\n\n9\n2\nNon-Trauma\ntriage_complete\nresource_use_end\n9.407274\n2.0\n0\n\n\n10\n2\nNon-Trauma\nMINORS_registration_wait_begins\nqueue\n9.407274\nNaN\n0\n\n\n11\n2\nNon-Trauma\nMINORS_registration_begins\nresource_use\n9.407274\n2.0\n0\n\n\n12\n1\nNon-Trauma\nMINORS_registration_complete\nresource_use_end\n15.418481\n1.0\n0\n\n\n13\n1\nNon-Trauma\nMINORS_examination_wait_begins\nqueue\n15.418481\nNaN\n0\n\n\n14\n1\nNon-Trauma\nMINORS_examination_begins\nresource_use\n15.418481\n1.0\n0\n\n\n15\n2\nNon-Trauma\nMINORS_registration_complete\nresource_use_end\n17.104670\n2.0\n0\n\n\n16\n2\nNon-Trauma\nMINORS_examination_wait_begins\nqueue\n17.104670\nNaN\n0\n\n\n17\n2\nNon-Trauma\nMINORS_examination_begins\nresource_use\n17.104670\n2.0\n0\n\n\n18\n1\nNon-Trauma\nMINORS_examination_complete\nresource_use_end\n31.636252\n1.0\n0\n\n\n19\n1\nShared\ndepart\narrival_departure\n31.636252\nNaN\n0\n\n\n20\n2\nNon-Trauma\nMINORS_examination_complete\nresource_use_end\n32.875857\n2.0\n0\n\n\n21\n2\nNon-Trauma\nrequires_treatment\nattribute_assigned\n32.875857\nNaN\n0\n\n\n22\n2\nNon-Trauma\nMINORS_treatment_wait_begins\nqueue\n32.875857\nNaN\n0\n\n\n23\n2\nNon-Trauma\nMINORS_treatment_begins\nresource_use\n32.875857\n1.0\n0\n\n\n24\n3\nShared\narrival\narrival_departure\n33.426168\nNaN\n0\n\n\n25\n3\nNon-Trauma\ntriage_wait_begins\nqueue\n33.426168\nNaN\n0\n\n\n26\n3\nNon-Trauma\ntriage_begins\nresource_use\n33.426168\n1.0\n0\n\n\n27\n3\nNon-Trauma\ntriage_complete\nresource_use_end\n33.545008\n1.0\n0\n\n\n28\n3\nNon-Trauma\nMINORS_registration_wait_begins\nqueue\n33.545008\nNaN\n0\n\n\n29\n3\nNon-Trauma\nMINORS_registration_begins\nresource_use\n33.545008\n1.0\n0\n\n\n30\n4\nShared\narrival\narrival_departure\n37.900548\nNaN\n0\n\n\n31\n4\nNon-Trauma\ntriage_wait_begins\nqueue\n37.900548\nNaN\n0\n\n\n32\n4\nNon-Trauma\ntriage_begins\nresource_use\n37.900548\n2.0\n0\n\n\n33\n4\nNon-Trauma\ntriage_complete\nresource_use_end\n37.914164\n2.0\n0\n\n\n34\n4\nNon-Trauma\nMINORS_registration_wait_begins\nqueue\n37.914164\nNaN\n0\n\n\n35\n4\nNon-Trauma\nMINORS_registration_begins\nresource_use\n37.914164\n2.0\n0\n\n\n36\n3\nNon-Trauma\nMINORS_registration_complete\nresource_use_end\n42.359504\n1.0\n0\n\n\n37\n3\nNon-Trauma\nMINORS_examination_wait_begins\nqueue\n42.359504\nNaN\n0\n\n\n38\n3\nNon-Trauma\nMINORS_examination_begins\nresource_use\n42.359504\n3.0\n0\n\n\n39\n4\nNon-Trauma\nMINORS_registration_complete\nresource_use_end\n45.938325\n2.0\n0\n\n\n40\n4\nNon-Trauma\nMINORS_examination_wait_begins\nqueue\n45.938325\nNaN\n0\n\n\n41\n4\nNon-Trauma\nMINORS_examination_begins\nresource_use\n45.938325\n1.0\n0\n\n\n42\n2\nNon-Trauma\nMINORS_treatment_complete\nresource_use_end\n46.278797\n1.0\n0\n\n\n43\n2\nShared\ndepart\narrival_departure\n46.278797\nNaN\n0\n\n\n44\n5\nShared\narrival\narrival_departure\n51.770459\nNaN\n0\n\n\n45\n5\nNon-Trauma\ntriage_wait_begins\nqueue\n51.770459\nNaN\n0\n\n\n46\n5\nNon-Trauma\ntriage_begins\nresource_use\n51.770459\n1.0\n0\n\n\n47\n5\nNon-Trauma\ntriage_complete\nresource_use_end\n55.072516\n1.0\n0\n\n\n48\n5\nNon-Trauma\nMINORS_registration_wait_begins\nqueue\n55.072516\nNaN\n0\n\n\n49\n5\nNon-Trauma\nMINORS_registration_begins\nresource_use\n55.072516\n1.0\n0\nevent_position_df = pd.DataFrame([\n                # {'event': 'arrival', 'x':  10, 'y': 250, 'label': \"Arrival\" },\n\n                # Triage - minor and trauma\n                {'event': 'triage_wait_begins',\n                 'x':  160, 'y': 375, 'label': \"Waiting for&lt;br&gt;Triage\"  },\n                {'event': 'triage_begins',\n                 'x':  160, 'y': 315, 'resource':'n_triage', 'label': \"Being Triaged\" },\n\n                # Minors (non-trauma) pathway\n                {'event': 'MINORS_registration_wait_begins',\n                 'x':  300, 'y': 145, 'label': \"Waiting for&lt;br&gt;Registration\"  },\n                {'event': 'MINORS_registration_begins',\n                 'x':  300, 'y': 85, 'resource':'n_reg', 'label':'Being&lt;br&gt;Registered'  },\n\n                {'event': 'MINORS_examination_wait_begins',\n                 'x':  465, 'y': 145, 'label': \"Waiting for&lt;br&gt;Examination\"  },\n                {'event': 'MINORS_examination_begins',\n                 'x':  465, 'y': 85, 'resource':'n_exam', 'label': \"Being&lt;br&gt;Examined\" },\n\n                {'event': 'MINORS_treatment_wait_begins',\n                 'x':  630, 'y': 145, 'label': \"Waiting for&lt;br&gt;Treatment\"  },\n                {'event': 'MINORS_treatment_begins',\n                 'x':  630, 'y': 85, 'resource':'n_cubicles_non_trauma_treat', 'label': \"Being&lt;br&gt;Treated\" },\n\n                # Trauma pathway\n                {'event': 'TRAUMA_stabilisation_wait_begins',\n                 'x': 300, 'y': 560, 'label': \"Waiting for&lt;br&gt;Stabilisation\" },\n                {'event': 'TRAUMA_stabilisation_begins',\n                 'x': 300, 'y': 490, 'resource':'n_trauma', 'label': \"Being&lt;br&gt;Stabilised\" },\n\n                {'event': 'TRAUMA_treatment_wait_begins',\n                 'x': 630, 'y': 560, 'label': \"Waiting for&lt;br&gt;Treatment\" },\n                {'event': 'TRAUMA_treatment_begins',\n                 'x': 630, 'y': 490, 'resource':'n_cubicles_trauma_treat', 'label': \"Being&lt;br&gt;Treated\" },\n\n                 {'event': 'depart',\n                 'x':  670, 'y': 330, 'label': \"Exit\"}\n            ])",
    "crumbs": [
      "SimPy Examples",
      "Animation of a SimPy Model with Branching and Multiple Steps"
    ]
  },
  {
    "objectID": "examples/example_2_branching_multistep/ex_2_branching_multistep_case.html#setup_mode-true",
    "href": "examples/example_2_branching_multistep/ex_2_branching_multistep_case.html#setup_mode-true",
    "title": "Animation of a SimPy Model with Branching and Multiple Steps",
    "section": "setup_mode = True",
    "text": "setup_mode = True\nsetup_mode allows us to see how the coordinates of our plot relate to the positioning of our background image, allowing us to more accurately place our entities.\n\nanimate_activity_log(\n        event_log=my_trial.all_event_logs[my_trial.all_event_logs['run']==1],\n        event_position_df= event_position_df,\n        scenario=g(),\n        entity_col_name=\"patient\",\n        debug_mode=True,\n        setup_mode=True,\n        every_x_time_units=5,\n        include_play_button=True,\n        gap_between_entities=10,\n        gap_between_resource_rows=20,\n        gap_between_queue_rows=20,\n        plotly_height=900,\n        plotly_width=1600,\n        override_x_max=700,\n        override_y_max=675,\n        entity_icon_size=20,\n        resource_icon_size=20,\n        text_size=20,\n        wrap_queues_at=10,\n        step_snapshot_max=50,\n        limit_duration=g.sim_duration,\n        time_display_units=\"dhm\",\n        display_stage_labels=False,\n        add_background_image=\"https://raw.githubusercontent.com/Bergam0t/vidigi/refs/heads/main/examples/example_2_branching_multistep/Full%20Model%20Background%20Image%20-%20Horizontal%20Layout.drawio.png\",\n    )\n\nAnimation function called at 12:10:58\nIteration through time-unit-by-time-unit logs complete 12:10:59\nSnapshot df concatenation complete at 12:10:59\nReshaped animation dataframe finished construction at 12:10:59\nPlacement dataframe finished construction at 12:10:59\nOutput animation generation complete at 12:11:01\nTotal Time Elapsed: 2.69 seconds",
    "crumbs": [
      "SimPy Examples",
      "Animation of a SimPy Model with Branching and Multiple Steps"
    ]
  },
  {
    "objectID": "examples/example_2_branching_multistep/ex_2_branching_multistep_case.html#setup_mode-false",
    "href": "examples/example_2_branching_multistep/ex_2_branching_multistep_case.html#setup_mode-false",
    "title": "Animation of a SimPy Model with Branching and Multiple Steps",
    "section": "setup_mode = False",
    "text": "setup_mode = False\nWe can then rerun our plot with setup_mode=False to remove the grid lines and axis tick marks.\n\nanimate_activity_log(\n        event_log=my_trial.all_event_logs[my_trial.all_event_logs['run']==1],\n        event_position_df= event_position_df,\n        scenario=g(),\n        entity_col_name=\"patient\",\n        debug_mode=True,\n        setup_mode=False,\n        every_x_time_units=5,\n        include_play_button=True,\n        gap_between_entities=10,\n        gap_between_resource_rows=20,\n        gap_between_queue_rows=20,\n        plotly_height=900,\n        plotly_width=1600,\n        override_x_max=700,\n        override_y_max=675,\n        entity_icon_size=20,\n        resource_icon_size=20,\n        text_size=20,\n        wrap_queues_at=10,\n        step_snapshot_max=50,\n        limit_duration=g.sim_duration,\n        time_display_units=\"dhm\",\n        display_stage_labels=False,\n        add_background_image=\"https://raw.githubusercontent.com/Bergam0t/vidigi/refs/heads/main/examples/example_2_branching_multistep/Full%20Model%20Background%20Image%20-%20Horizontal%20Layout.drawio.png\",\n    )\n\nAnimation function called at 12:11:02\nIteration through time-unit-by-time-unit logs complete 12:11:03\nSnapshot df concatenation complete at 12:11:03\nReshaped animation dataframe finished construction at 12:11:03\nPlacement dataframe finished construction at 12:11:03\nOutput animation generation complete at 12:11:04\nTotal Time Elapsed: 1.76 seconds",
    "crumbs": [
      "SimPy Examples",
      "Animation of a SimPy Model with Branching and Multiple Steps"
    ]
  },
  {
    "objectID": "examples/example_4_ciw/ex_4_ciw.html",
    "href": "examples/example_4_ciw/ex_4_ciw.html",
    "title": "A Simple Ciw Model",
    "section": "",
    "text": "Note that this example is written using ciw 2.x\nIt will not run with 3.x - but could theoretically be adapted to do so\nThe ‘logs’ object is the result of running\nsim_engine.get_all_records()\nHowever, note that while we run multiple replications, we only pass the records for a single replication to the event_log_from_ciw_recs function.\n\nThe underlying model code is from Monks, T., Harper, A., & Heather, A. (2023). Towards Sharing Tools, Artefacts, and Reproducible Simulation: a ciw model example (v1.0.1). Zenodo. https://doi.org/10.5281/zenodo.10051494\nSee here for the adaptation embedded within that repo: https://github.com/Bergam0t/ciw-example-animation/tree/main\n\n\nimport pandas as pd\n# Import the wrapper objects for model interaction.\nfrom examples.example_4_ciw.ex_4_ciw_model import Experiment, multiple_replications\nfrom vidigi.ciw import event_log_from_ciw_recs\nfrom vidigi.animation import animate_activity_log\nimport plotly.io as pio\npio.renderers.default = \"notebook\"\nimport os\n\n\n\n\n\n\n\nView Imported Code for the ciw model\n\n\n\n\n\n'''\nCiW Implementation of the 111 call centre\nTime units of the simulation model are in minutes.\n'''\n# Imports\n\nimport numpy as np\nimport pandas as pd\nimport ciw\n\n# Module level variables, constants, and default values\n\nN_OPERATORS = 13\nN_NURSES = 9\nMEAN_IAT = 100.0 / 60.0\n\nCALL_LOW = 5.0\nCALL_MODE = 7.0\nCALL_HIGH = 10.0\n\nNURSE_CALL_LOW = 10.0\nNURSE_CALL_HIGH = 20.0\n\nCHANCE_CALLBACK = 0.4\nRESULTS_COLLECTION_PERIOD = 1000\n\n\n# Experiment class\nclass Experiment:\n    def __init__(self, n_operators=N_OPERATORS, n_nurses=N_NURSES,\n                 mean_iat=MEAN_IAT, call_low=CALL_LOW,\n                 call_mode=CALL_MODE, call_high=CALL_HIGH,\n                 chance_callback=CHANCE_CALLBACK,\n                 nurse_call_low=NURSE_CALL_LOW,\n                 nurse_call_high=NURSE_CALL_HIGH,\n                 random_seed=None):\n        self.n_operators = n_operators\n        self.n_nurses = n_nurses\n\n        self.arrival_dist = ciw.dists.Exponential(mean_iat)\n        self.call_dist = ciw.dists.Triangular(call_low, call_mode, call_high)\n        self.nurse_dist = ciw.dists.Uniform(nurse_call_low, nurse_call_high)\n\n        self.chance_callback = chance_callback\n\n        self.init_results_variables()\n\n    def init_results_variables(self):\n        self.results = {\n            'waiting_times': [],\n            'total_call_duration': 0.0,\n            'nurse_waiting_times': [],\n            'total_nurse_call_duration': 0.0,\n        }\n\n\n# Model code\n\ndef get_model(args):\n    '''\n    Build a CiW model using the arguments provided.\n    '''\n    network = ciw.create_network(\n        arrival_distributions=[args.arrival_dist, None],\n        service_distributions=[args.call_dist, args.nurse_dist],\n        routing=[[0.0, args.chance_callback], [0.0, 0.0]],\n        number_of_servers=[args.n_operators, args.n_nurses]\n    )\n    return network\n\n\n# Model wrapper functions\n\ndef single_run(experiment, rc_period=RESULTS_COLLECTION_PERIOD, random_seed=None):\n    run_results = {}\n\n    ciw.seed(random_seed)\n\n    model = get_model(experiment)\n\n    sim_engine = ciw.Simulation(model)\n\n    sim_engine.simulate_until_max_time(rc_period)\n\n    recs = sim_engine.get_all_records()\n\n    op_servicetimes = [r.service_time for r in recs if r.node == 1]\n    nurse_servicetimes = [r.service_time for r in recs if r.node == 2]\n\n    op_waits = [r.waiting_time for r in recs if r.node == 1]\n    nurse_waits = [r.waiting_time for r in recs if r.node == 2]\n\n    run_results['01_mean_waiting_time'] = np.mean(op_waits)\n    run_results['02_operator_util'] = (\n        sum(op_servicetimes) / (rc_period * experiment.n_operators)\n    ) * 100.0\n    run_results['03_mean_nurse_waiting_time'] = np.mean(nurse_waits)\n    run_results['04_nurse_util'] = (\n        sum(nurse_servicetimes) / (rc_period * experiment.n_nurses)\n    ) * 100.0\n\n    return run_results, recs\n\n\ndef multiple_replications(experiment, rc_period=RESULTS_COLLECTION_PERIOD, n_reps=5):\n    results = []\n    logs = []\n\n    for rep in range(n_reps):\n        run_result, log = single_run(experiment, rc_period)\n        results.append(run_result)\n        logs.append(log)\n\n    df_results = pd.DataFrame(results)\n    df_results.index = np.arange(1, len(df_results) + 1)\n    df_results.index.name = 'rep'\n\n    return df_results, logs\n\n\n\n\nN_OPERATORS = 18\nN_NURSES = 9\nRESULTS_COLLECTION_PERIOD = 1000\n\nuser_experiment = Experiment(n_operators=N_OPERATORS,\n                             n_nurses=N_NURSES,\n                             chance_callback=0.4)\n\n# run multiple replications\nresults, logs = multiple_replications(user_experiment, n_reps=10)\n\nWhile we’ve done multiple replications, for the purpose of the animation we want only a single set of logs, so we will extract those from the logs variable we created.\n\n# the 'logs' object contains a list, where each entry is the recs object for that run\nlogs_run_1 = logs[0]\n\nprint(len(logs_run_1))\n\n2277\n\n\n\n# let's print all of the outputs for a single individual\n[print(log) for log in logs_run_1 if log.id_number==500]\n\nRecord(id_number=500, customer_class='Customer', original_customer_class='Customer', node=1, arrival_date=285.15199278675664, waiting_time=0.0, service_start_date=285.15199278675664, service_time=8.53886189681026, service_end_date=293.6908546835669, time_blocked=0.0, exit_date=293.6908546835669, destination=2, queue_size_at_arrival=14, queue_size_at_departure=9, server_id=2, record_type='service')\nRecord(id_number=500, customer_class='Customer', original_customer_class='Customer', node=2, arrival_date=293.6908546835669, waiting_time=49.99518525413794, service_start_date=343.68603993770483, service_time=15.877553023839369, service_end_date=359.5635929615442, time_blocked=0.0, exit_date=359.5635929615442, destination=-1, queue_size_at_arrival=40, queue_size_at_departure=45, server_id=4, record_type='service')\n\n\n[None, None]\n\n\nUnlike SimPy, where we have to manually add our event logs at various points, we instead can make use of the event_log_from_ciw_recs helper function from vidigi.utils to automatically reshape ciw logs into the correct format for vidigi to work with.\nFor each node, we pass in an appropriate name. Vidigi will use these and append ’_begins’ and ’_ends’, as well as calculating arrivals and departures from the model and creating resource IDs to allow it to correctly show the utilisation of a resource at each step.\n\n# let's now try turning this into an event log\nevent_log_test = event_log_from_ciw_recs(logs_run_1, node_name_list=[\"operator\", \"nurse\"])\n\nevent_log_test.head(25)\n\n\n\n\n\n\n\n\nentity_id\npathway\nevent_type\nevent\ntime\nresource_id\n\n\n\n\n0\n1\nModel\narrival_departure\narrival\n0.217233\nNaN\n\n\n1\n1\nModel\nqueue\noperator_wait_begins\n0.217233\nNaN\n\n\n2\n1\nModel\nresource_use\noperator_begins\n0.217233\n1.0\n\n\n3\n1\nModel\nresource_use\noperator_ends\n9.223846\n1.0\n\n\n4\n1\nModel\nqueue\nnurse_wait_begins\n9.223846\nNaN\n\n\n5\n1\nModel\nresource_use\nnurse_begins\n9.223846\n2.0\n\n\n6\n1\nModel\nresource_use\nnurse_ends\n20.429835\n2.0\n\n\n7\n1\nModel\narrival_departure\ndepart\n20.429835\nNaN\n\n\n8\n2\nModel\narrival_departure\narrival\n0.876985\nNaN\n\n\n9\n2\nModel\nqueue\noperator_wait_begins\n0.876985\nNaN\n\n\n10\n2\nModel\nresource_use\noperator_begins\n0.876985\n2.0\n\n\n11\n2\nModel\nresource_use\noperator_ends\n7.146672\n2.0\n\n\n12\n2\nModel\nqueue\nnurse_wait_begins\n7.146672\nNaN\n\n\n13\n2\nModel\nresource_use\nnurse_begins\n7.146672\n1.0\n\n\n14\n2\nModel\nresource_use\nnurse_ends\n18.146884\n1.0\n\n\n15\n2\nModel\narrival_departure\ndepart\n18.146884\nNaN\n\n\n16\n3\nModel\narrival_departure\narrival\n2.301595\nNaN\n\n\n17\n3\nModel\nqueue\noperator_wait_begins\n2.301595\nNaN\n\n\n18\n3\nModel\nresource_use\noperator_begins\n2.301595\n3.0\n\n\n19\n3\nModel\nresource_use\noperator_ends\n10.313719\n3.0\n\n\n20\n3\nModel\narrival_departure\ndepart\n10.313719\nNaN\n\n\n21\n4\nModel\narrival_departure\narrival\n2.806043\nNaN\n\n\n22\n4\nModel\nqueue\noperator_wait_begins\n2.806043\nNaN\n\n\n23\n4\nModel\nresource_use\noperator_begins\n2.806043\n4.0\n\n\n24\n4\nModel\nresource_use\noperator_ends\n10.160622\n4.0\n\n\n\n\n\n\n\nNow we need to create a suitable class to pass in the resource numbers to the animation function.\n\n# Create a suitable class to pass in the resource numbers to the animation function\nclass model_params():\n    def __init__(self):\n        self.n_operators = N_OPERATORS\n        self.n_nurses = N_NURSES\n\nparams = model_params()\n\nprint(f\"Number of operators: {params.n_operators}\")\nprint(f\"Number of nurses: {params.n_nurses}\")\n\nNumber of operators: 18\nNumber of nurses: 9\n\n\nLike with SimPy, we need to tell vidigi where to put each step on our plot. We will refer to the names we used - so as we named our nodes ‘operator’ and ‘nurse’, we will want\n\narrival\noperator_wait_begins (to show queueing for the operator)\noperator_begins (to show resource use of the operator)\nnurse_wait_begins (to show queuing for the nurse after finishing being seen by the operator)\nnurse_begins (to show resource use of the nurse)\n\nFor the _begins steps, which relat to resource use, we will also pass in a name that relates to the number of resources we need, which we defined in our model_params class above.\nSo, for the operator_begins step, for example, we tell t to look for n_operators, whch is one of the parameters in our model_params class. We pass the params class into the animation function.\n\n# Create required event_position_df for vidigi animation\nevent_position_df = pd.DataFrame([\n                    {'event': 'arrival',\n                     'x':  30, 'y': 350,\n                     'label': \"Arrival\"},\n\n                    {'event': 'operator_wait_begins',\n                     'x':  205, 'y': 270,\n                     'label': \"Waiting for Operator\"},\n\n                    {'event': 'operator_begins',\n                     'x':  210, 'y': 210,\n                     'resource':'n_operators',\n                     'label': \"Speaking to operator\"},\n\n                    {'event': 'nurse_wait_begins',\n                     'x':  205, 'y': 110,\n                     'label': \"Waiting for Nurse\"},\n\n                    {'event': 'nurse_begins',\n                     'x':  210, 'y': 50,\n                     'resource':'n_nurses',\n                     'label': \"Speaking to Nurse\"},\n\n                    {'event': 'depart',\n                     'x':  270, 'y': 10,\n                     'label': \"Exit\"}\n\n                ])\n\nevent_position_df\n\n\n\n\n\n\n\n\nevent\nx\ny\nlabel\nresource\n\n\n\n\n0\narrival\n30\n350\nArrival\nNaN\n\n\n1\noperator_wait_begins\n205\n270\nWaiting for Operator\nNaN\n\n\n2\noperator_begins\n210\n210\nSpeaking to operator\nn_operators\n\n\n3\nnurse_wait_begins\n205\n110\nWaiting for Nurse\nNaN\n\n\n4\nnurse_begins\n210\n50\nSpeaking to Nurse\nn_nurses\n\n\n5\nexit\n270\n10\nExit\nNaN\n\n\n\n\n\n\n\nFinally, we can create the animation.\n\n# Create animation\nparams = model_params()\n\nanimate_activity_log(\n        event_log=event_log_test,\n        event_position_df=event_position_df,\n        scenario=model_params(),\n        debug_mode=True,\n        setup_mode=False,\n        every_x_time_units=1,\n        include_play_button=True,\n        entity_icon_size=20,\n        gap_between_entities=8,\n        gap_between_queue_rows=25,\n        plotly_height=700,\n        frame_duration=200,\n        plotly_width=1200,\n        override_x_max=300,\n        override_y_max=300,\n        limit_duration=RESULTS_COLLECTION_PERIOD,\n        wrap_queues_at=25,\n        wrap_resources_at=50,\n        step_snapshot_max=75,\n        time_display_units=\"dhm\",\n        display_stage_labels=True,\n    )\n\nAnimation function called at 15:52:26\nIteration through time-unit-by-time-unit logs complete 15:52:31\nSnapshot df concatenation complete at 15:52:31\nReshaped animation dataframe finished construction at 15:52:31\nPlacement dataframe finished construction at 15:52:31\nOutput animation generation complete at 15:52:35\nTotal Time Elapsed: 9.56 seconds",
    "crumbs": [
      "Ciw Examples",
      "A Simple Ciw Model"
    ]
  },
  {
    "objectID": "examples/example_5_simplest_case_wrapped_resources/ex_5_simplest_case_wrapped_resource.html",
    "href": "examples/example_5_simplest_case_wrapped_resources/ex_5_simplest_case_wrapped_resource.html",
    "title": "Managing Higher Numbers of Resources with Resource Wrapping",
    "section": "",
    "text": "from examples.example_1_simplest_case.ex_1_model_classes_with_vidigi_logging import Trial, g\nfrom vidigi.animation import animate_activity_log\nimport pandas as pd\nimport plotly.io as pio\npio.renderers.default = \"notebook\"\nimport os",
    "crumbs": [
      "SimPy Examples",
      "Managing Higher Numbers of Resources with Resource Wrapping"
    ]
  },
  {
    "objectID": "examples/example_5_simplest_case_wrapped_resources/ex_5_simplest_case_wrapped_resource.html#demonstrate-issues-with-wrapping-not-implemented",
    "href": "examples/example_5_simplest_case_wrapped_resources/ex_5_simplest_case_wrapped_resource.html#demonstrate-issues-with-wrapping-not-implemented",
    "title": "Managing Higher Numbers of Resources with Resource Wrapping",
    "section": "Demonstrate issues with wrapping not implemented",
    "text": "Demonstrate issues with wrapping not implemented\n\ng.sim_duration = 360\ng.n_cubicles = 30\ng.trauma_treat_mean = 120\ng.trauma_treat_var = 20\ng.arrival_rate = 3\n\n\nmy_trial = Trial()\n\nmy_trial.run_trial()\n\n30 nurses\n\n\n\n\nmy_trial.all_event_logs.head(20)\n\n\n\n\n\n\n\n\npatient\npathway\nevent_type\nevent\ntime\nresource_id\nrun\n\n\n\n\n0\n1\nSimplest\narrival_departure\narrival\n0.000000\nNaN\n0\n\n\n1\n1\nSimplest\nqueue\ntreatment_wait_begins\n0.000000\nNaN\n0\n\n\n2\n1\nSimplest\nresource_use\ntreatment_begins\n0.000000\n1.0\n0\n\n\n3\n2\nSimplest\narrival_departure\narrival\n2.039796\nNaN\n0\n\n\n4\n2\nSimplest\nqueue\ntreatment_wait_begins\n2.039796\nNaN\n0\n\n\n5\n2\nSimplest\nresource_use\ntreatment_begins\n2.039796\n2.0\n0\n\n\n6\n3\nSimplest\narrival_departure\narrival\n5.098587\nNaN\n0\n\n\n7\n3\nSimplest\nqueue\ntreatment_wait_begins\n5.098587\nNaN\n0\n\n\n8\n3\nSimplest\nresource_use\ntreatment_begins\n5.098587\n3.0\n0\n\n\n9\n4\nSimplest\narrival_departure\narrival\n5.158007\nNaN\n0\n\n\n10\n4\nSimplest\nqueue\ntreatment_wait_begins\n5.158007\nNaN\n0\n\n\n11\n4\nSimplest\nresource_use\ntreatment_begins\n5.158007\n4.0\n0\n\n\n12\n5\nSimplest\narrival_departure\narrival\n5.164815\nNaN\n0\n\n\n13\n5\nSimplest\nqueue\ntreatment_wait_begins\n5.164815\nNaN\n0\n\n\n14\n5\nSimplest\nresource_use\ntreatment_begins\n5.164815\n5.0\n0\n\n\n15\n6\nSimplest\narrival_departure\narrival\n6.815844\nNaN\n0\n\n\n16\n6\nSimplest\nqueue\ntreatment_wait_begins\n6.815844\nNaN\n0\n\n\n17\n6\nSimplest\nresource_use\ntreatment_begins\n6.815844\n6.0\n0\n\n\n18\n7\nSimplest\narrival_departure\narrival\n11.705665\nNaN\n0\n\n\n19\n7\nSimplest\nqueue\ntreatment_wait_begins\n11.705665\nNaN\n0\n\n\n\n\n\n\n\n\nevent_position_df = pd.DataFrame([\n                    {'event': 'arrival',\n                     'x':  50, 'y': 300,\n                     'label': \"Arrival\" },\n\n                    # Triage - minor and trauma\n                    {'event': 'treatment_wait_begins',\n                     'x':  205, 'y': 275,\n                     'label': \"Waiting for Treatment\"},\n\n                    {'event': 'treatment_begins',\n                     'x':  205, 'y': 175,\n                     'resource':'n_cubicles',\n                     'label': \"Being Treated\"},\n\n                    {'event': 'depart',\n                     'x':  270, 'y': 70,\n                     'label': \"Exit\"}\n\n                ])\n\n\nanimate_activity_log(\n        event_log=my_trial.all_event_logs[my_trial.all_event_logs['run']==1],\n        event_position_df= event_position_df,\n        scenario=g(),\n        entity_col_name=\"patient\",\n        debug_mode=True,\n        setup_mode=False,\n        every_x_time_units=1,\n        include_play_button=True,\n        entity_icon_size=20,\n        gap_between_entities=6,\n        gap_between_queue_rows=25,\n        gap_between_resource_rows=25,\n        plotly_height=700,\n        frame_duration=200,\n        plotly_width=1200,\n        override_x_max=300,\n        override_y_max=500,\n        limit_duration=180,\n        wrap_queues_at=25,\n        wrap_resources_at=None,\n        step_snapshot_max=125,\n        time_display_units=\"dhm\",\n        display_stage_labels=False,\n        add_background_image=\"https://raw.githubusercontent.com/Bergam0t/vidigi/refs/heads/main/examples/example_1_simplest_case/Simplest%20Model%20Background%20Image%20-%20Horizontal%20Layout.drawio.png\",\n    )\n\nAnimation function called at 12:33:48\nIteration through time-unit-by-time-unit logs complete 12:33:49\nSnapshot df concatenation complete at 12:33:49\nReshaped animation dataframe finished construction at 12:33:49\nPlacement dataframe finished construction at 12:33:49\nOutput animation generation complete at 12:33:50\nTotal Time Elapsed: 1.95 seconds",
    "crumbs": [
      "SimPy Examples",
      "Managing Higher Numbers of Resources with Resource Wrapping"
    ]
  },
  {
    "objectID": "examples/example_5_simplest_case_wrapped_resources/ex_5_simplest_case_wrapped_resource.html#rerun-with-wrapped-resources",
    "href": "examples/example_5_simplest_case_wrapped_resources/ex_5_simplest_case_wrapped_resource.html#rerun-with-wrapped-resources",
    "title": "Managing Higher Numbers of Resources with Resource Wrapping",
    "section": "Rerun with wrapped resources",
    "text": "Rerun with wrapped resources\n\nanimate_activity_log(\n        event_log=my_trial.all_event_logs[my_trial.all_event_logs['run']==1],\n        event_position_df= event_position_df,\n        scenario=g(),\n        entity_col_name=\"patient\",\n        debug_mode=True,\n        setup_mode=False,\n        every_x_time_units=1,\n        include_play_button=True,\n        entity_icon_size=20,\n        resource_icon_size=20,\n        gap_between_entities=6,\n        gap_between_queue_rows=25,\n        gap_between_resource_rows=25,\n        plotly_height=700,\n        frame_duration=200,\n        plotly_width=1200,\n        override_x_max=300,\n        override_y_max=500,\n        limit_duration=180,\n        wrap_queues_at=25,\n        wrap_resources_at=15,\n        step_snapshot_max=125,\n        time_display_units=\"dhm\",\n        display_stage_labels=False,\n        add_background_image=\"https://raw.githubusercontent.com/Bergam0t/vidigi/refs/heads/main/examples/example_1_simplest_case/Simplest%20Model%20Background%20Image%20-%20Horizontal%20Layout.drawio.png\",\n    )\n\nAnimation function called at 12:33:50\nIteration through time-unit-by-time-unit logs complete 12:33:51\nSnapshot df concatenation complete at 12:33:51\nReshaped animation dataframe finished construction at 12:33:51\nPlacement dataframe finished construction at 12:33:51\nOutput animation generation complete at 12:33:52\nTotal Time Elapsed: 1.89 seconds",
    "crumbs": [
      "SimPy Examples",
      "Managing Higher Numbers of Resources with Resource Wrapping"
    ]
  },
  {
    "objectID": "examples/example_5_simplest_case_wrapped_resources/ex_5_simplest_case_wrapped_resource.html#running-this-with-a-much-larger-number-of-resources",
    "href": "examples/example_5_simplest_case_wrapped_resources/ex_5_simplest_case_wrapped_resource.html#running-this-with-a-much-larger-number-of-resources",
    "title": "Managing Higher Numbers of Resources with Resource Wrapping",
    "section": "Running this with a much larger number of resources",
    "text": "Running this with a much larger number of resources\nThis demonstrates that vidigi can cope with relatively high numbers of resources being tracked.\nLet’s envisage the bays as beds instead, and do a bit of a rough tweak to our existing model parameters to pretend that this is playing out over a period of days instead of minutes.\n\ng.n_cubicles = 200\ng.trauma_treat_mean = 3*24\ng.trauma_treat_var = 10*24\ng.arrival_rate = 0.2\n\n\nmy_trial = Trial()\n\nmy_trial.run_trial()\n\n200 nurses\n\n\n\n\nevent_position_df = pd.DataFrame([\n                    {'event': 'arrival',\n                     'x':  5, 'y': 1250,\n                     'label': \"Arrival\" },\n\n                    # Triage - minor and trauma\n                    {'event': 'treatment_wait_begins',\n                     'x':  285, 'y': 790,\n                     'label': \"Waiting for\\nBed\"},\n\n                    {'event': 'treatment_begins',\n                     'x':  285, 'y': 130,\n                     'resource':'n_cubicles',\n                     'label': \"In a Bed\"},\n\n                    {'event': 'depart',\n                     'x':  320, 'y': 30,\n                     'label': \"Exit\"}\n\n                ])\n\n\nanimate_activity_log(\n        event_log=my_trial.all_event_logs[my_trial.all_event_logs['run']==1],\n        event_position_df= event_position_df,\n        scenario=g(),\n        entity_col_name=\"patient\",\n        debug_mode=True,\n        setup_mode=True,\n        every_x_time_units=1,\n        include_play_button=True,\n        entity_icon_size=12,\n        resource_icon_size=16,\n        gap_between_entities=10,\n        gap_between_resources=12,\n        gap_between_queue_rows=50,\n        gap_between_resource_rows=50,\n        plotly_height=700,\n        frame_duration=500,\n        plotly_width=1200,\n        override_x_max=350,\n        override_y_max=1350,\n        limit_duration=180,\n        wrap_queues_at=25,\n        wrap_resources_at=20,\n        step_snapshot_max=250,\n        time_display_units=\"d\",\n        display_stage_labels=True,\n        custom_resource_icon=\"🛏️\"\n    )\n\nAnimation function called at 12:33:58\nIteration through time-unit-by-time-unit logs complete 12:33:59\nSnapshot df concatenation complete at 12:33:59\nReshaped animation dataframe finished construction at 12:33:59\nPlacement dataframe finished construction at 12:33:59\nError changing frame duration\nError changing frame transition duration\nOutput animation generation complete at 12:33:59\nTotal Time Elapsed: 1.57 seconds\n\n\n                                                    \n\n\n\nIncrease the number of beds and rerun\n\ng.n_cubicles = 300\ng.trauma_treat_mean = 5*24\ng.trauma_treat_var = 10*24\ng.arrival_rate = 0.2\n\n\nmy_trial = Trial()\n\nmy_trial.run_trial()\n\n300 nurses\n\n\n\n\nevent_position_df = pd.DataFrame([\n                    {'event': 'arrival',\n                     'x':  5, 'y': 1900,\n                     'label': \"Arrival\" },\n\n                    # Triage - minor and trauma\n                    {'event': 'treatment_wait_begins',\n                     'x':  285, 'y': 1300,\n                     'label': \"Waiting for\\nBed\"},\n\n                    {'event': 'treatment_begins',\n                     'x':  285, 'y': 130,\n                     'resource':'n_cubicles',\n                     'label': \"In a Bed\"},\n\n                    {'event': 'depart',\n                     'x':  320, 'y': 30,\n                     'label': \"Exit\"}\n\n                ])\n\n\nanimate_activity_log(\n        event_log=my_trial.all_event_logs[my_trial.all_event_logs['run']==1],\n        event_position_df= event_position_df,\n        scenario=g(),\n        entity_col_name=\"patient\",\n        debug_mode=True,\n        setup_mode=False,\n        every_x_time_units=1,\n        include_play_button=True,\n        entity_icon_size=14,\n        resource_icon_size=14,\n        gap_between_entities=10,\n        gap_between_resources=13,\n        gap_between_resource_rows=70,\n        gap_between_queue_rows=70,\n        plotly_height=850,\n        frame_duration=500,\n        plotly_width=1200,\n        override_x_max=350,\n        override_y_max=2650,\n        limit_duration=180,\n        wrap_queues_at=25,\n        wrap_resources_at=20,\n        step_snapshot_max=425, # Make sure this is larger than the number of resources you have!\n        time_display_units=\"d\",\n        display_stage_labels=True,\n        custom_resource_icon=\"🛏️\"\n    )\n\nAnimation function called at 12:35:16\nIteration through time-unit-by-time-unit logs complete 12:35:17\nSnapshot df concatenation complete at 12:35:17\nReshaped animation dataframe finished construction at 12:35:17\nPlacement dataframe finished construction at 12:35:17\nError changing frame duration\nError changing frame transition duration\nOutput animation generation complete at 12:35:18\nTotal Time Elapsed: 1.84 seconds\n\n\n                                                    \n\n\nWe can see that even with this many resources displayed at once, performance in this simple model is acceptable.",
    "crumbs": [
      "SimPy Examples",
      "Managing Higher Numbers of Resources with Resource Wrapping"
    ]
  },
  {
    "objectID": "examples/example_7_simplest_case_priority_resource_storewrapper/ex_7_simplest_case_priority_resource.html",
    "href": "examples/example_7_simplest_case_priority_resource_storewrapper/ex_7_simplest_case_priority_resource.html",
    "title": "Using the VidigiPriorityStore to Simplify Model Code Changes with Priority Resources",
    "section": "",
    "text": "In vidigi 0.0.5, a new version of VidigiPriorityStore has been added that can be used almost exactly like a resource - reducing the amount of rewriting required to incorporate vidigi into your model.\nThis allows us to use the pattern\nwith self.treatment_cubicles.request(priority=patient.priority) as req:\n\n    treatment_resource = yield req\n\n    ### Continue all code in the indented portion that requires the resource, with the resource\n    ### automatically being returned to the store when the indented portion completes\nInstead of\ntreatment_resource = yield self.treatment_cubicles.get(priority=patient.priority)\n\n### Continue all code that requires the resource\n\nself.treatment_cubicles.put(treatment_resource)\n(even though we are still using a Store behind the scenes)\nThis minimizes the syntax changes and rewriting that are required when converting an existing model built using resources to a vidigi-compatible state.\nWhen setting up the resources, we simply use the pattern\nfrom vidigi.utils import VidigiPriorityStore, populate_store\n\n...\n\nself.treatment_cubicles = VidigiPriorityStore(self.env)\n\npopulate_store(num_resources=g.n_cubicles, # or wherever you are storing your resource counts\n               simpy_store=self.treatment_cubicles, # pass in the VidgiStore we created\n               sim_env=self.env # include the simpy env this will sit in\n               )\n\nfrom examples.example_7_simplest_case_priority_resource_storewrapper.ex_7_model_classes import Trial, g\nfrom vidigi.prep import reshape_for_animations, generate_animation_df\nfrom vidigi.animation import generate_animation, animate_activity_log\nimport pandas as pd\nimport plotly.io as pio\npio.renderers.default = \"notebook\"\nimport os\n\n\n\n\n\n\n\nView Imported Code, which has had logging steps added at the appropriate points in the ‘model’ class\n\n\n\n\n\nimport random\nimport numpy as np\nimport pandas as pd\nimport simpy\nfrom sim_tools.distributions import Exponential, Lognormal\nfrom vidigi.resources import VidigiPriorityStore\n\nclass g:\n    '''\n    Create a scenario to parameterise the simulation model\n\n    Parameters:\n    -----------\n    random_number_set: int, optional (default=DEFAULT_RNG_SET)\n        Set to control the initial seeds of each stream of pseudo\n        random numbers used in the model.\n\n    n_cubicles: int\n        The number of treatment cubicles\n\n    trauma_treat_mean: float\n        Mean of the trauma cubicle treatment distribution (Lognormal)\n\n    trauma_treat_var: float\n        Variance of the trauma cubicle treatment distribution (Lognormal)\n\n        arrival_rate: float\n        Set the mean of the exponential distribution that is used to sample the\n        inter-arrival time of patients\n\n    '''\n    random_number_set = 42\n\n    n_cubicles = 4\n    trauma_treat_mean = 40\n    trauma_treat_var = 5\n\n    arrival_rate = 5\n    sim_duration = 600\n    number_of_runs = 100\n\nclass Patient:\n    '''\n    Class defining details for a patient entity\n    '''\n    def __init__(self, p_id):\n        '''\n        Constructor method\n\n        Params:\n        -----\n        identifier: int\n            a numeric identifier for the patient.\n        '''\n        self.identifier = p_id\n        self.arrival = -np.inf\n        self.wait_treat = -np.inf\n        self.total_time = -np.inf\n        self.treat_duration = -np.inf\n\n        # Randomly initialise a patient priority value\n        # Lower values will be prioritised - so priority 1 will be seen before priority 2\n        if random.uniform(0, 1) &lt; 0.2:\n            self.priority = 1\n        else:\n            self.priority = 2\n\nclass Model:\n    '''\n    Simulates the simplest minor treatment process for a patient\n\n    1. Arrive\n    2. Examined/treated by nurse when one available\n    3. Discharged\n    '''\n    # Constructor to set up the model for a run.  We pass in a run number when\n    # we create a new model.\n    def __init__(self, run_number):\n        # Create a SimPy environment in which everything will live\n        self.env = simpy.Environment()\n\n        self.event_log = []\n\n        # Create a patient counter (which we'll use as a patient ID)\n        self.patient_counter = 0\n\n        self.patients = []\n\n        # Create our resources\n        self.init_resources()\n\n        # Store the passed in run number\n        self.run_number = run_number\n\n        # Create a new Pandas DataFrame that will store some results against\n        # the patient ID (which we'll use as the index).\n        self.results_df = pd.DataFrame()\n        self.results_df[\"Patient ID\"] = [1]\n        self.results_df[\"Queue Time Cubicle\"] = [0.0]\n        self.results_df[\"Time with Nurse\"] = [0.0]\n        self.results_df.set_index(\"Patient ID\", inplace=True)\n\n        # Create an attribute to store the mean queuing times across this run of\n        # the model\n        self.mean_q_time_cubicle = 0\n\n        self.patient_inter_arrival_dist = Exponential(mean = g.arrival_rate,\n                                                      random_seed = self.run_number*g.random_number_set)\n        self.treat_dist = Lognormal(mean = g.trauma_treat_mean,\n                                    stdev = g.trauma_treat_var,\n                                    random_seed = self.run_number*g.random_number_set)\n\n    def init_resources(self):\n        '''\n        Init the number of resources\n        and store in the arguments container object\n\n        Resource list:\n            1. Nurses/treatment bays (same thing in this model)\n\n        '''\n        self.treatment_cubicles = VidigiPriorityStore(self.env, num_resources=g.n_cubicles)\n\n    # A generator function that represents the DES generator for patient arrivals\n    def generator_patient_arrivals(self):\n        # Use an infinite loop here to keep doing this indefinitely while the simulation runs\n        while True:\n            # Increment the patient counter by 1 (first patient will have an ID of 1)\n            self.patient_counter += 1\n\n            p = Patient(self.patient_counter)\n\n            # Store patient in list for later easy access\n            self.patients.append(p)\n\n            # Tell SimPy to start up the attend_clinic generator function with this patient\n            # (the generator function that will model the patient's journey through the system)\n            self.env.process(self.attend_clinic(p))\n\n            # Randomly sample the time to the next patient arriving\n            sampled_inter = self.patient_inter_arrival_dist.sample()\n\n            # Freeze this instance of this function in place until the inter-arrival time\n            # sampled above has elapsed\n            yield self.env.timeout(sampled_inter)\n\n    def attend_clinic(self, patient):\n        \"\"\"\n        A generator function that represents the pathway for a patient going through the clinic.\n\n        The patient object is passed in to the generator function so we can extract information\n        from / record information to it\n        \"\"\"\n        self.arrival = self.env.now\n\n        # ===== LOGGING FOR VIDIGI ANIMATION  ===== #\n        self.event_log.append(\n            {'patient': patient.identifier,\n             'pathway': patient.priority,\n             'event_type': 'arrival_departure',\n             'event': 'arrival',\n             'time': self.env.now}\n        )\n        # ========================================= #\n\n        # request examination resource\n        start_wait = self.env.now\n\n        # ===== LOGGING FOR VIDIGI ANIMATION  ===== #\n        self.event_log.append(\n            {'patient': patient.identifier,\n             'pathway': patient.priority,\n             'event': 'treatment_wait_begins',\n             'event_type': 'queue',\n             'time': self.env.now}\n        )\n        # ========================================= #\n\n        # Seize a treatment resource when available\n        # Note that we must pass in the patient priority\n        with self.treatment_cubicles.request(priority=patient.priority) as req:\n\n            treatment_resource = yield req\n\n            # record the waiting time for registration\n            self.wait_treat = self.env.now - start_wait\n\n            # ===== LOGGING FOR VIDIGI ANIMATION  ===== #\n            self.event_log.append(\n                {'patient': patient.identifier,\n                    'pathway': patient.priority,\n                    'event': 'treatment_begins',\n                    'event_type': 'resource_use',\n                    'time': self.env.now,\n                    'resource_id': treatment_resource.id_attribute\n                    }\n            )\n            # ========================================= #\n\n            # sample treatment duration\n            self.treat_duration = self.treat_dist.sample()\n            yield self.env.timeout(self.treat_duration)\n\n            # ===== LOGGING FOR VIDIGI ANIMATION  ===== #\n            self.event_log.append(\n                {'patient': patient.identifier,\n                    'pathway': patient.priority,\n                    'event': 'treatment_complete',\n                    'event_type': 'resource_use_end',\n                    'time': self.env.now,\n                    'resource_id': treatment_resource.id_attribute}\n            )\n            # ========================================= #\n\n\n        # total time in system\n        self.total_time = self.env.now - self.arrival\n\n        # ===== LOGGING FOR VIDIGI ANIMATION  ===== #\n        self.event_log.append(\n            {'patient': patient.identifier,\n            'pathway': patient.priority,\n            'event': 'depart',\n            'event_type': 'arrival_departure',\n            'time': self.env.now}\n        )\n        # ========================================= #\n\n\n    # This method calculates results over a single run.  Here we just calculate\n    # a mean, but in real world models you'd probably want to calculate more.\n    def calculate_run_results(self):\n        # Take the mean of the queuing times across patients in this run of the\n        # model.\n        self.mean_q_time_cubicle = self.results_df[\"Queue Time Cubicle\"].mean()\n\n    # The run method starts up the DES entity generators, runs the simulation,\n    # and in turns calls anything we need to generate results for the run\n    def run(self):\n        # Start up our DES entity generators that create new patients.  We've\n        # only got one in this model, but we'd need to do this for each one if\n        # we had multiple generators.\n        self.env.process(self.generator_patient_arrivals())\n\n        # Run the model for the duration specified in g class\n        self.env.run(until=g.sim_duration)\n\n        # Now the simulation run has finished, call the method that calculates\n        # run results\n        self.calculate_run_results()\n\n        self.event_log = pd.DataFrame(self.event_log)\n\n        self.event_log[\"run\"] = self.run_number\n\n        return {'results': self.results_df, 'event_log': self.event_log}\n\n# Class representing a Trial for our simulation - a batch of simulation runs.\nclass Trial:\n    # The constructor sets up a pandas dataframe that will store the key\n    # results from each run against run number, with run number as the index.\n    def  __init__(self):\n        self.df_trial_results = pd.DataFrame()\n        self.df_trial_results[\"Run Number\"] = [0]\n        self.df_trial_results[\"Arrivals\"] = [0]\n        self.df_trial_results[\"Mean Queue Time Cubicle\"] = [0.0]\n        self.df_trial_results.set_index(\"Run Number\", inplace=True)\n\n        self.all_event_logs = []\n\n    # Method to run a trial\n    def run_trial(self):\n        print(f\"{g.n_cubicles} nurses\")\n        print(\"\") ## Print a blank line\n\n        # Run the simulation for the number of runs specified in g class.\n        # For each run, we create a new instance of the Model class and call its\n        # run method, which sets everything else in motion.  Once the run has\n        # completed, we grab out the stored run results (just mean queuing time\n        # here) and store it against the run number in the trial results\n        # dataframe.\n        for run in range(g.number_of_runs):\n            random.seed(run)\n\n            my_model = Model(run)\n            model_outputs = my_model.run()\n            patient_level_results = model_outputs[\"results\"]\n            event_log = model_outputs[\"event_log\"]\n\n            self.df_trial_results.loc[run] = [\n                len(patient_level_results),\n                my_model.mean_q_time_cubicle,\n            ]\n\n            # print(event_log)\n\n            self.all_event_logs.append(event_log)\n\n        self.all_event_logs = pd.concat(self.all_event_logs)\n\n\n\n\nmy_trial = Trial()\n\nmy_trial.run_trial()\n\n4 nurses\n\n\n\n\nmy_trial.all_event_logs.head(50)\n\n\n\n\n\n\n\n\npatient\npathway\nevent_type\nevent\ntime\nresource_id\nrun\n\n\n\n\n0\n1\n2\narrival_departure\narrival\n0.000000\nNaN\n0\n\n\n1\n1\n2\nqueue\ntreatment_wait_begins\n0.000000\nNaN\n0\n\n\n2\n1\n2\nresource_use\ntreatment_begins\n0.000000\n1.0\n0\n\n\n3\n2\n2\narrival_departure\narrival\n3.399660\nNaN\n0\n\n\n4\n2\n2\nqueue\ntreatment_wait_begins\n3.399660\nNaN\n0\n\n\n5\n2\n2\nresource_use\ntreatment_begins\n3.399660\n2.0\n0\n\n\n6\n3\n2\narrival_departure\narrival\n8.497645\nNaN\n0\n\n\n7\n3\n2\nqueue\ntreatment_wait_begins\n8.497645\nNaN\n0\n\n\n8\n3\n2\nresource_use\ntreatment_begins\n8.497645\n3.0\n0\n\n\n9\n4\n2\narrival_departure\narrival\n8.596678\nNaN\n0\n\n\n10\n4\n2\nqueue\ntreatment_wait_begins\n8.596678\nNaN\n0\n\n\n11\n4\n2\nresource_use\ntreatment_begins\n8.596678\n4.0\n0\n\n\n12\n5\n2\narrival_departure\narrival\n8.608025\nNaN\n0\n\n\n13\n5\n2\nqueue\ntreatment_wait_begins\n8.608025\nNaN\n0\n\n\n14\n6\n2\narrival_departure\narrival\n11.359739\nNaN\n0\n\n\n15\n6\n2\nqueue\ntreatment_wait_begins\n11.359739\nNaN\n0\n\n\n16\n7\n2\narrival_departure\narrival\n19.509442\nNaN\n0\n\n\n17\n7\n2\nqueue\ntreatment_wait_begins\n19.509442\nNaN\n0\n\n\n18\n8\n2\narrival_departure\narrival\n22.877356\nNaN\n0\n\n\n19\n8\n2\nqueue\ntreatment_wait_begins\n22.877356\nNaN\n0\n\n\n20\n9\n2\narrival_departure\narrival\n26.653863\nNaN\n0\n\n\n21\n9\n2\nqueue\ntreatment_wait_begins\n26.653863\nNaN\n0\n\n\n22\n1\n2\nresource_use_end\ntreatment_complete\n40.317385\n1.0\n0\n\n\n23\n1\n2\narrival_departure\ndepart\n40.317385\nNaN\n0\n\n\n24\n5\n2\nresource_use\ntreatment_begins\n40.317385\n1.0\n0\n\n\n25\n10\n2\narrival_departure\narrival\n40.737793\nNaN\n0\n\n\n26\n10\n2\nqueue\ntreatment_wait_begins\n40.737793\nNaN\n0\n\n\n27\n2\n2\nresource_use_end\ntreatment_complete\n42.443230\n2.0\n0\n\n\n28\n2\n2\narrival_departure\ndepart\n42.443230\nNaN\n0\n\n\n29\n6\n2\nresource_use\ntreatment_begins\n42.443230\n2.0\n0\n\n\n30\n4\n2\nresource_use_end\ntreatment_complete\n48.809628\n4.0\n0\n\n\n31\n4\n2\narrival_departure\ndepart\n48.809628\nNaN\n0\n\n\n32\n7\n2\nresource_use\ntreatment_begins\n48.809628\n4.0\n0\n\n\n33\n3\n2\nresource_use_end\ntreatment_complete\n51.483457\n3.0\n0\n\n\n34\n3\n2\narrival_departure\ndepart\n51.483457\nNaN\n0\n\n\n35\n8\n2\nresource_use\ntreatment_begins\n51.483457\n3.0\n0\n\n\n36\n11\n2\narrival_departure\narrival\n71.026558\nNaN\n0\n\n\n37\n11\n2\nqueue\ntreatment_wait_begins\n71.026558\nNaN\n0\n\n\n38\n5\n2\nresource_use_end\ntreatment_complete\n77.447488\n1.0\n0\n\n\n39\n5\n2\narrival_departure\ndepart\n77.447488\nNaN\n0\n\n\n40\n9\n2\nresource_use\ntreatment_begins\n77.447488\n1.0\n0\n\n\n41\n6\n2\nresource_use_end\ntreatment_complete\n83.962251\n2.0\n0\n\n\n42\n6\n2\narrival_departure\ndepart\n83.962251\nNaN\n0\n\n\n43\n10\n2\nresource_use\ntreatment_begins\n83.962251\n2.0\n0\n\n\n44\n12\n2\narrival_departure\narrival\n87.458700\nNaN\n0\n\n\n45\n12\n2\nqueue\ntreatment_wait_begins\n87.458700\nNaN\n0\n\n\n46\n13\n2\narrival_departure\narrival\n87.465138\nNaN\n0\n\n\n47\n13\n2\nqueue\ntreatment_wait_begins\n87.465138\nNaN\n0\n\n\n48\n7\n2\nresource_use_end\ntreatment_complete\n95.498040\n4.0\n0\n\n\n49\n7\n2\narrival_departure\ndepart\n95.498040\nNaN\n0\n\n\n\n\n\n\n\n\nSTEP_SNAPSHOT_MAX = 45\nLIMIT_DURATION = g.sim_duration\nWRAP_QUEUES_AT = 15\n\n\nfull_patient_df = reshape_for_animations(\n    event_log=my_trial.all_event_logs[my_trial.all_event_logs['run']==1],\n    every_x_time_units=2,\n    entity_col_name=\"patient\",\n    step_snapshot_max=STEP_SNAPSHOT_MAX,\n    limit_duration=LIMIT_DURATION,\n    debug_mode=True\n    )\n\nfull_patient_df.head(15)\n\nIteration through time-unit-by-time-unit logs complete 12:37:59\nSnapshot df concatenation complete at 12:37:59\n\n\n\n\n\n\n\n\n\nindex\npatient\npathway\nevent_type\nevent\ntime\nresource_id\nrun\nrank\nsnapshot_time\nadditional\n\n\n\n\n0\n2\n1\n1\nresource_use\ntreatment_begins\n0.0\n1.0\n1\n1.0\n0\nNaN\n\n\n1\n2\n1\n1\nresource_use\ntreatment_begins\n0.0\n1.0\n1\n1.0\n2\nNaN\n\n\n2\n2\n1\n1\nresource_use\ntreatment_begins\n0.0\n1.0\n1\n1.0\n4\nNaN\n\n\n3\n2\n1\n1\nresource_use\ntreatment_begins\n0.0\n1.0\n1\n1.0\n6\nNaN\n\n\n4\n2\n1\n1\nresource_use\ntreatment_begins\n0.0\n1.0\n1\n1.0\n8\nNaN\n\n\n5\n2\n1\n1\nresource_use\ntreatment_begins\n0.0\n1.0\n1\n1.0\n10\nNaN\n\n\n6\n2\n1\n1\nresource_use\ntreatment_begins\n0.0\n1.0\n1\n1.0\n12\nNaN\n\n\n7\n2\n1\n1\nresource_use\ntreatment_begins\n0.0\n1.0\n1\n1.0\n14\nNaN\n\n\n8\n2\n1\n1\nresource_use\ntreatment_begins\n0.0\n1.0\n1\n1.0\n16\nNaN\n\n\n9\n2\n1\n1\nresource_use\ntreatment_begins\n0.0\n1.0\n1\n1.0\n18\nNaN\n\n\n10\n2\n1\n1\nresource_use\ntreatment_begins\n0.0\n1.0\n1\n1.0\n20\nNaN\n\n\n11\n2\n1\n1\nresource_use\ntreatment_begins\n0.0\n1.0\n1\n1.0\n22\nNaN\n\n\n12\n2\n1\n1\nresource_use\ntreatment_begins\n0.0\n1.0\n1\n1.0\n24\nNaN\n\n\n13\n2\n1\n1\nresource_use\ntreatment_begins\n0.0\n1.0\n1\n1.0\n26\nNaN\n\n\n14\n2\n1\n1\nresource_use\ntreatment_begins\n0.0\n1.0\n1\n1.0\n28\nNaN\n\n\n\n\n\n\n\n\nevent_position_df = pd.DataFrame([\n                    {'event': 'arrival',\n                     'x':  50, 'y': 300,\n                     'label': \"Arrival\" },\n\n                    # Triage - minor and trauma\n                    {'event': 'treatment_wait_begins',\n                     'x':  205, 'y': 275,\n                     'label': \"Waiting for Treatment\"},\n\n                    {'event': 'treatment_begins',\n                     'x':  205, 'y': 175,\n                     'resource':'n_cubicles',\n                     'label': \"Being Treated\"},\n\n                    {'event': 'depart',\n                     'x':  270, 'y': 70,\n                     'label': \"Exit\"}\n\n                ])\n\n\nGenerate animation using the step-by-step functions\nUsing the three step-by-step functions allows us to intervene in the produced dataframe and manually take control of the icons in use.\nThis will allow us to show the high-priority patients with a unique icon so we can see their frequency and how they are handled in the final model.\n\nfull_patient_df_plus_pos = generate_animation_df(\n    full_entity_df=full_patient_df,\n    event_position_df=event_position_df,\n    entity_col_name=\"patient\",\n    wrap_queues_at=WRAP_QUEUES_AT,\n    step_snapshot_max=STEP_SNAPSHOT_MAX,\n    gap_between_entities=10,\n    gap_between_resources=10,\n    gap_between_resource_rows=30,\n    gap_between_queue_rows=30,\n    debug_mode=True\n    )\n\nfull_patient_df_plus_pos.sort_values(['patient', 'snapshot_time']).head(15)\n\nPlacement dataframe finished construction at 12:37:59\n\n\n\n\n\n\n\n\n\nindex\npatient\npathway\nevent_type\nevent\ntime\nresource_id\nrun\nrank\nsnapshot_time\nadditional\nx\ny_final\nlabel\nresource\nx_final\nrow\nicon\n\n\n\n\n10186\n2\n1\n1\nresource_use\ntreatment_begins\n0.0\n1.0\n1\n1.0\n0\nNaN\n205\n175.0\nBeing Treated\nn_cubicles\n205.0\n0.0\n🧔🏼\n\n\n10187\n2\n1\n1\nresource_use\ntreatment_begins\n0.0\n1.0\n1\n1.0\n2\nNaN\n205\n175.0\nBeing Treated\nn_cubicles\n205.0\n0.0\n🧔🏼\n\n\n10188\n2\n1\n1\nresource_use\ntreatment_begins\n0.0\n1.0\n1\n1.0\n4\nNaN\n205\n175.0\nBeing Treated\nn_cubicles\n205.0\n0.0\n🧔🏼\n\n\n10189\n2\n1\n1\nresource_use\ntreatment_begins\n0.0\n1.0\n1\n1.0\n6\nNaN\n205\n175.0\nBeing Treated\nn_cubicles\n205.0\n0.0\n🧔🏼\n\n\n10190\n2\n1\n1\nresource_use\ntreatment_begins\n0.0\n1.0\n1\n1.0\n8\nNaN\n205\n175.0\nBeing Treated\nn_cubicles\n205.0\n0.0\n🧔🏼\n\n\n10191\n2\n1\n1\nresource_use\ntreatment_begins\n0.0\n1.0\n1\n1.0\n10\nNaN\n205\n175.0\nBeing Treated\nn_cubicles\n205.0\n0.0\n🧔🏼\n\n\n10192\n2\n1\n1\nresource_use\ntreatment_begins\n0.0\n1.0\n1\n1.0\n12\nNaN\n205\n175.0\nBeing Treated\nn_cubicles\n205.0\n0.0\n🧔🏼\n\n\n10193\n2\n1\n1\nresource_use\ntreatment_begins\n0.0\n1.0\n1\n1.0\n14\nNaN\n205\n175.0\nBeing Treated\nn_cubicles\n205.0\n0.0\n🧔🏼\n\n\n10194\n2\n1\n1\nresource_use\ntreatment_begins\n0.0\n1.0\n1\n1.0\n16\nNaN\n205\n175.0\nBeing Treated\nn_cubicles\n205.0\n0.0\n🧔🏼\n\n\n10195\n2\n1\n1\nresource_use\ntreatment_begins\n0.0\n1.0\n1\n1.0\n18\nNaN\n205\n175.0\nBeing Treated\nn_cubicles\n205.0\n0.0\n🧔🏼\n\n\n10196\n2\n1\n1\nresource_use\ntreatment_begins\n0.0\n1.0\n1\n1.0\n20\nNaN\n205\n175.0\nBeing Treated\nn_cubicles\n205.0\n0.0\n🧔🏼\n\n\n10197\n2\n1\n1\nresource_use\ntreatment_begins\n0.0\n1.0\n1\n1.0\n22\nNaN\n205\n175.0\nBeing Treated\nn_cubicles\n205.0\n0.0\n🧔🏼\n\n\n10198\n2\n1\n1\nresource_use\ntreatment_begins\n0.0\n1.0\n1\n1.0\n24\nNaN\n205\n175.0\nBeing Treated\nn_cubicles\n205.0\n0.0\n🧔🏼\n\n\n10199\n2\n1\n1\nresource_use\ntreatment_begins\n0.0\n1.0\n1\n1.0\n26\nNaN\n205\n175.0\nBeing Treated\nn_cubicles\n205.0\n0.0\n🧔🏼\n\n\n10200\n2\n1\n1\nresource_use\ntreatment_begins\n0.0\n1.0\n1\n1.0\n28\nNaN\n205\n175.0\nBeing Treated\nn_cubicles\n205.0\n0.0\n🧔🏼\n\n\n\n\n\n\n\n\ndef show_priority_icon(row):\n            if \"more\" not in row[\"icon\"]:\n                if row[\"pathway\"] == 1:\n                        return \"🚨\"\n                else:\n                    return row[\"icon\"]\n            else:\n                return row[\"icon\"]\n\n\nfull_patient_df_plus_pos = full_patient_df_plus_pos.assign(\n            icon=full_patient_df_plus_pos.apply(show_priority_icon, axis=1)\n            )\n\n\nfull_patient_df_plus_pos.head(15)\n\n\n\n\n\n\n\n\nindex\npatient\npathway\nevent_type\nevent\ntime\nresource_id\nrun\nrank\nsnapshot_time\nadditional\nx\ny_final\nlabel\nresource\nx_final\nrow\nicon\n\n\n\n\n0\n155\n49\n2\nqueue\nexit\n208.540636\nNaN\n1\n1.0\n598\nNaN\n270\n70.0\nExit\nNaN\n270.0\n0.0\n🧕🏾\n\n\n1\n155\n49\n2\nqueue\ntreatment_wait_begins\n206.540636\nNaN\n1\n27.0\n208\nNaN\n205\n305.0\nWaiting for Treatment\nNaN\n95.0\n1.0\n🧕🏾\n\n\n2\n155\n49\n2\nqueue\ntreatment_wait_begins\n206.540636\nNaN\n1\n27.0\n210\nNaN\n205\n305.0\nWaiting for Treatment\nNaN\n95.0\n1.0\n🧕🏾\n\n\n3\n155\n49\n2\nqueue\ntreatment_wait_begins\n206.540636\nNaN\n1\n27.0\n212\nNaN\n205\n305.0\nWaiting for Treatment\nNaN\n95.0\n1.0\n🧕🏾\n\n\n4\n155\n49\n2\nqueue\ntreatment_wait_begins\n206.540636\nNaN\n1\n27.0\n214\nNaN\n205\n305.0\nWaiting for Treatment\nNaN\n95.0\n1.0\n🧕🏾\n\n\n5\n155\n49\n2\nqueue\ntreatment_wait_begins\n206.540636\nNaN\n1\n27.0\n216\nNaN\n205\n305.0\nWaiting for Treatment\nNaN\n95.0\n1.0\n🧕🏾\n\n\n6\n155\n49\n2\nqueue\ntreatment_wait_begins\n206.540636\nNaN\n1\n27.0\n218\nNaN\n205\n305.0\nWaiting for Treatment\nNaN\n95.0\n1.0\n🧕🏾\n\n\n7\n155\n49\n2\nqueue\ntreatment_wait_begins\n206.540636\nNaN\n1\n27.0\n220\nNaN\n205\n305.0\nWaiting for Treatment\nNaN\n95.0\n1.0\n🧕🏾\n\n\n8\n155\n49\n2\nqueue\ntreatment_wait_begins\n206.540636\nNaN\n1\n27.0\n222\nNaN\n205\n305.0\nWaiting for Treatment\nNaN\n95.0\n1.0\n🧕🏾\n\n\n9\n155\n49\n2\nqueue\ntreatment_wait_begins\n206.540636\nNaN\n1\n27.0\n224\nNaN\n205\n305.0\nWaiting for Treatment\nNaN\n95.0\n1.0\n🧕🏾\n\n\n10\n155\n49\n2\nqueue\ntreatment_wait_begins\n206.540636\nNaN\n1\n27.0\n226\nNaN\n205\n305.0\nWaiting for Treatment\nNaN\n95.0\n1.0\n🧕🏾\n\n\n11\n155\n49\n2\nqueue\ntreatment_wait_begins\n206.540636\nNaN\n1\n27.0\n228\nNaN\n205\n305.0\nWaiting for Treatment\nNaN\n95.0\n1.0\n🧕🏾\n\n\n12\n155\n49\n2\nqueue\ntreatment_wait_begins\n206.540636\nNaN\n1\n27.0\n230\nNaN\n205\n305.0\nWaiting for Treatment\nNaN\n95.0\n1.0\n🧕🏾\n\n\n13\n155\n49\n2\nqueue\ntreatment_wait_begins\n206.540636\nNaN\n1\n27.0\n232\nNaN\n205\n305.0\nWaiting for Treatment\nNaN\n95.0\n1.0\n🧕🏾\n\n\n14\n155\n49\n2\nqueue\ntreatment_wait_begins\n206.540636\nNaN\n1\n26.0\n234\nNaN\n205\n305.0\nWaiting for Treatment\nNaN\n105.0\n1.0\n🧕🏾\n\n\n\n\n\n\n\n\ngenerate_animation(\n        full_entity_df_plus_pos=full_patient_df_plus_pos.sort_values(['patient', 'snapshot_time']),\n        event_position_df= event_position_df,\n        scenario=g(),\n        entity_col_name=\"patient\",\n        debug_mode=True,\n        setup_mode=False,\n        include_play_button=True,\n        entity_icon_size=20,\n        resource_icon_size=20,\n        gap_between_resource_rows=30,\n        plotly_height=700,\n        frame_duration=800,\n        frame_transition_duration=200,\n        plotly_width=1200,\n        override_x_max=300,\n        override_y_max=500,\n        time_display_units=\"dhm\",\n        display_stage_labels=False,\n        add_background_image=\"https://raw.githubusercontent.com/Bergam0t/vidigi/refs/heads/main/examples/example_1_simplest_case/Simplest%20Model%20Background%20Image%20-%20Horizontal%20Layout.drawio.png\",\n    )\n\nOutput animation generation complete at 12:38:11\n\n\n        \n        \n        \n\n\n                                                    \n\n\n\n\nRerun, but using the all-in-one animation function (which will not show different priority icons)\n\nanimate_activity_log(\n        event_log=my_trial.all_event_logs[my_trial.all_event_logs['run']==1],\n        event_position_df= event_position_df,\n        scenario=g(),\n        entity_col_name=\"patient\",\n        debug_mode=True,\n        setup_mode=False,\n        every_x_time_units=1,\n        include_play_button=True,\n        entity_icon_size=20,\n        resource_icon_size=20,\n        gap_between_entities=6,\n        gap_between_queue_rows=25,\n        gap_between_resource_rows=25,\n        plotly_height=700,\n        frame_duration=200,\n        plotly_width=1200,\n        override_x_max=300,\n        override_y_max=500,\n        limit_duration=g.sim_duration,\n        wrap_queues_at=25,\n        step_snapshot_max=125,\n        time_display_units=\"dhm\",\n        display_stage_labels=False,\n        add_background_image=\"https://raw.githubusercontent.com/Bergam0t/vidigi/refs/heads/main/examples/example_1_simplest_case/Simplest%20Model%20Background%20Image%20-%20Horizontal%20Layout.drawio.png\",\n    )\n\nAnimation function called at 12:39:05\nIteration through time-unit-by-time-unit logs complete 12:39:08\nSnapshot df concatenation complete at 12:39:08\nReshaped animation dataframe finished construction at 12:39:08\nPlacement dataframe finished construction at 12:39:08\nOutput animation generation complete at 12:39:11\nTotal Time Elapsed: 5.72 seconds",
    "crumbs": [
      "SimPy Examples",
      "Using the VidigiPriorityStore to Simplify Model Code Changes with Priority Resources"
    ]
  },
  {
    "objectID": "examples/example_9_wide_resource_spacing_multiple/ex_9_model.html",
    "href": "examples/example_9_wide_resource_spacing_multiple/ex_9_model.html",
    "title": "Creative Layouts - Multiple Ward Example",
    "section": "",
    "text": "import pandas as pd\n\nfrom examples.example_9_wide_resource_spacing_multiple.ex_9_model_classes import g, Trial\n\nfrom vidigi.animation import animate_activity_log\n\nimport plotly.io as pio\npio.renderers.default = \"notebook\"\n\n\nclinic_simulation = Trial()\n\n\nclinic_simulation.trial_results\n\n\n\n\n\n\n\n\nentity_id\nevent_type\nevent\ntime\npathway\nrun_number\ntimestamp\nresource_id\n\n\n\n\n0\n1\narrival_departure\narrival\n0.000000\nNone\n1\nNone\nNaN\n\n\n1\n1\nqueue\nbed_wait_begins\n0.000000\nNone\n1\nNone\nNaN\n\n\n2\n1\nresource_use\nmaple_stay_begins\n0.000000\nNone\n1\nNone\n1.0\n\n\n3\n2\narrival_departure\narrival\n0.519445\nNone\n1\nNone\nNaN\n\n\n4\n2\nqueue\nbed_wait_begins\n0.519445\nNone\n1\nNone\nNaN\n\n\n...\n...\n...\n...\n...\n...\n...\n...\n...\n\n\n10272\n2143\narrival_departure\narrival\n8735.445825\nNone\n100\nNone\nNaN\n\n\n10273\n2143\nqueue\nbed_wait_begins\n8735.445825\nNone\n100\nNone\nNaN\n\n\n10274\n2144\narrival_departure\narrival\n8735.740369\nNone\n100\nNone\nNaN\n\n\n10275\n2144\nqueue\nbed_wait_begins\n8735.740369\nNone\n100\nNone\nNaN\n\n\n10276\n2144\nresource_use\nmaple_stay_begins\n8735.740369\nNone\n100\nNone\n8.0\n\n\n\n\n1050654 rows × 8 columns\n\n\n\n\nevent_position_df = pd.DataFrame([\n                    {'event': 'arrival',\n                     'x':  50, 'y': 800,\n                     'label': \"Arrival\" },\n\n                    # Triage - minor and trauma\n                    {'event': 'bed_wait_begins',\n                     'x':  505, 'y': 700,\n                     'label': \"Waiting for Bed\"},\n\n                    {'event': 'ash_stay_begins',\n                     'x':  675, 'y': 275,\n                     'resource':'number_of_beds_ash',\n                     'label': \"Ash Ward\"},\n\n                    {'event': 'oak_stay_begins',\n                     'x':  205, 'y': 475,\n                     'resource':'number_of_beds_oak',\n                     'label': \"Oak Ward\"},\n\n                    {'event': 'maple_stay_begins',\n                     'x':  205, 'y': 175,\n                     'resource':'number_of_beds_maple',\n                     'label': \"Maple Ward\"},\n\n                    {'event': 'depart',\n                     'x':  740, 'y': 70,\n                     'label': \"Exit\"}\n\n                ])\n\n\nanimate_activity_log(\n        event_log=clinic_simulation.trial_results[clinic_simulation.trial_results['run_number']==1],\n        event_position_df= event_position_df,\n        scenario=g(),\n        # Key animation prep parameters\n        every_x_time_units=3,\n        simulation_time_unit=\"hours\",\n        limit_duration=g.sim_duration,\n        step_snapshot_max=125,\n        # Animation display parameters\n        time_display_units=\"dhm\",\n        include_play_button=True,\n        setup_mode=False,\n        debug_mode=True,\n        frame_duration=500,\n        # Text parameters\n        display_stage_labels=True,\n        text_size=20,\n        # Entity and queue size and spacing\n        entity_icon_size=16,\n        wrap_queues_at=25,\n        gap_between_entities=12,\n        gap_between_queue_rows=30,\n        # Resource size and spacing\n        gap_between_resources=80,\n        gap_between_resource_rows=40,\n        resource_icon_size=25,\n        wrap_resources_at=2,\n        custom_resource_icon='🛏️',\n        custom_entity_icon_list=['🧍'],\n        # Plot size\n        plotly_height=900,\n        plotly_width=1200,\n        # Internal plot coordinates\n        override_x_max=800,\n        override_y_max=900,\n        )\n\nAnimation function called at 15:41:32\nIteration through time-unit-by-time-unit logs complete 15:41:49\nSnapshot df concatenation complete at 15:41:50\nReshaped animation dataframe finished construction at 15:41:51\nPlacement dataframe finished construction at 15:41:51\nOutput animation generation complete at 15:42:06\nTotal Time Elapsed: 34.02 seconds",
    "crumbs": [
      "SimPy Examples",
      "Creative Layouts - Multiple Ward Example"
    ]
  },
  {
    "objectID": "examples/feat_vidigi_logging_class/feat_example_logging_class.html",
    "href": "examples/feat_vidigi_logging_class/feat_example_logging_class.html",
    "title": "Feature Example: Event Logging Helpers",
    "section": "",
    "text": "version 0.5.0 of vidigi added an EventLogger class, with various helper methods to simplify the process of generating the event logs that vidigi requires for the animation process.\nIn this notebook, we will add this logging into a simulation, also making use of the VidigiStore and its .populate() method to generate resources that have an ID attribute, allowing the vidigi animations to show individuals using a consistent resource.\nimport random\nimport numpy as np\nimport pandas as pd\nimport simpy\n\nfrom sim_tools.distributions import Exponential, Lognormal\n\nfrom vidigi.resources import VidigiStore\nfrom vidigi.logging import EventLogger\nfrom vidigi.animation import animate_activity_log\n\nimport plotly.io as pio\npio.renderers.default = \"notebook\"",
    "crumbs": [
      "Details",
      "Feature Example: Event Logging Helpers"
    ]
  },
  {
    "objectID": "examples/feat_vidigi_logging_class/feat_example_logging_class.html#more-complex-example---multiple-resource-types-branching",
    "href": "examples/feat_vidigi_logging_class/feat_example_logging_class.html#more-complex-example---multiple-resource-types-branching",
    "title": "Feature Example: Event Logging Helpers",
    "section": "More Complex example - Multiple Resource Types, Branching",
    "text": "More Complex example - Multiple Resource Types, Branching\n\n# Import additional required distributions\nfrom sim_tools.distributions import Normal, Bernoulli, Uniform\n\n\n# Class to store global parameter values.  We don't create an instance of this\n# class - we just refer to the class blueprint itself to access the numbers\n# inside.\nclass g:\n    '''\n    Create a scenario to parameterise the simulation model\n\n    Parameters:\n    -----------\n    random_number_set: int, optional (default=DEFAULT_RNG_SET)\n        Set to control the initial seeds of each stream of pseudo\n        random numbers used in the model.\n\n    n_triage: int\n        The number of triage cubicles\n\n    n_reg: int\n        The number of registration clerks\n\n    n_exam: int\n        The number of examination rooms\n\n    n_trauma: int\n        The number of trauma bays for stablisation\n\n    n_cubicles_non_trauma_treat: int\n        The number of non-trauma treatment cubicles\n\n    n_cubicles_trauma_treat: int\n        The number of trauma treatment cubicles\n\n    triage_mean: float\n        Mean duration of the triage distribution (Exponential)\n\n    reg_mean: float\n        Mean duration of the registration distribution (Lognormal)\n\n    reg_var: float\n        Variance of the registration distribution (Lognormal)\n\n    exam_mean: float\n        Mean of the examination distribution (Normal)\n\n    exam_var: float\n        Variance of the examination distribution (Normal)\n\n    trauma_mean: float\n        Mean of the trauma stabilisation distribution (Exponential)\n\n    trauma_treat_mean: float\n        Mean of the trauma cubicle treatment distribution (Lognormal)\n\n    trauma_treat_var: float\n        Variance of the trauma cubicle treatment distribution (Lognormal)\n\n    non_trauma_treat_mean: float\n        Mean of the non trauma treatment distribution\n\n    non_trauma_treat_var: float\n        Variance of the non trauma treatment distribution\n\n    non_trauma_treat_p: float\n        Probability non trauma patient requires treatment\n\n    prob_trauma: float\n        probability that a new arrival is a trauma patient.\n    '''\n    random_number_set = 42\n\n    n_triage=2\n    n_reg=2\n    n_exam=3\n    n_trauma=4\n    n_cubicles_non_trauma_treat=4\n    n_cubicles_trauma_treat=5\n\n    triage_mean=6\n    reg_mean=8\n    reg_var=2\n    exam_mean=16\n    exam_var=3\n    trauma_mean=90\n    trauma_treat_mean=30\n    trauma_treat_var=4\n    non_trauma_treat_mean=13.3\n    non_trauma_treat_var=2\n\n    non_trauma_treat_p=0.6\n    prob_trauma=0.12\n\n    arrival_df=\"ed_arrivals.csv\"\n\n    sim_duration = 600\n    number_of_runs = 100\n\n\nclass Patient:\n    '''\n    Class defining details for a patient entity\n    '''\n    def __init__(self, p_id):\n        '''\n        Constructor method\n\n        Params:\n        -----\n        identifier: int\n            a numeric identifier for the patient.\n        '''\n        self.identifier = p_id\n\n        # Time of arrival in model/at centre\n        self.arrival = -np.inf\n        # Total time in pathway\n        self.total_time = -np.inf\n\n        # Shared waits\n        self.wait_triage = -np.inf\n        self.wait_reg = -np.inf\n        self.wait_treat = -np.inf\n        # Non-trauma pathway - examination wait\n        self.wait_exam = -np.inf\n        # Trauma pathway - stabilisation wait\n        self.wait_trauma = -np.inf\n\n        # Shared durations\n        self.triage_duration = -np.inf\n        self.reg_duration = -np.inf\n        self.treat_duration = -np.inf\n\n        # Non-trauma pathway - examination duration\n        self.exam_duration = -np.inf\n        # Trauma pathway - stabilisation duration\n        self.trauma_duration = -np.inf\n\n\n# Class representing our model of the clinic.\nclass Model:\n    '''\n    Simulates the simplest minor treatment process for a patient\n\n    1. Arrive\n    2. Examined/treated by nurse when one available\n    3. Discharged\n    '''\n    # Constructor to set up the model for a run.  We pass in a run number when\n    # we create a new model.\n    def __init__(self, run_number):\n        # Create a SimPy environment in which everything will live\n        self.env = simpy.Environment()\n        # Store the passed in run number\n        self.run_number = run_number\n\n        self.logger = EventLogger(env=self.env, run_number=self.run_number)\n\n        # Create a patient counter (which we'll use as a patient ID)\n        self.patient_counter = 0\n\n        self.trauma_patients = []\n        self.non_trauma_patients = []\n\n        # Create our resources\n        self.init_resources()\n        # Create our distributions\n        self.init_distributions()\n\n    def init_distributions(self):\n        # Create distributions\n\n        # Triage duration\n        self.triage_dist = Exponential(g.triage_mean,\n                                    random_seed=self.run_number*g.random_number_set)\n\n        # Registration duration (non-trauma only)\n        self.reg_dist = Lognormal(g.reg_mean,\n                                np.sqrt(g.reg_var),\n                                random_seed=self.run_number*g.random_number_set)\n\n        # Evaluation (non-trauma only)\n        self.exam_dist = Normal(g.exam_mean,\n                                np.sqrt(g.exam_var),\n                                random_seed=self.run_number*g.random_number_set)\n\n        # Trauma/stablisation duration (trauma only)\n        self.trauma_dist = Exponential(g.trauma_mean,\n                                    random_seed=self.run_number*g.random_number_set)\n\n        # Non-trauma treatment\n        self.nt_treat_dist = Lognormal(g.non_trauma_treat_mean,\n                                    np.sqrt(g.non_trauma_treat_var),\n                                    random_seed=self.run_number*g.random_number_set)\n\n        # treatment of trauma patients\n        self.treat_dist = Lognormal(g.trauma_treat_mean,\n                                    np.sqrt(g.non_trauma_treat_var),\n                                    random_seed=self.run_number*g.random_number_set)\n\n        # probability of non-trauma patient requiring treatment\n        self.nt_p_treat_dist = Bernoulli(g.non_trauma_treat_p,\n                                        random_seed=self.run_number*g.random_number_set)\n\n        # probability of non-trauma versus trauma patient\n        self.p_trauma_dist = Bernoulli(g.prob_trauma,\n                                    random_seed=self.run_number*g.random_number_set)\n\n        # init sampling for non-stationary poisson process\n        self.init_nspp()\n\n    def init_nspp(self):\n\n        # read arrival profile\n        self.arrivals = pd.read_csv(g.arrival_df)  # pylint: disable=attribute-defined-outside-init\n        self.arrivals['mean_iat'] = 60 / self.arrivals['arrival_rate']\n\n        # maximum arrival rate (smallest time between arrivals)\n        self.lambda_max = self.arrivals['arrival_rate'].max()  # pylint: disable=attribute-defined-outside-init\n\n        # thinning exponential\n        self.arrival_dist = Exponential(60.0 / self.lambda_max,  # pylint: disable=attribute-defined-outside-init\n                                            random_seed=self.run_number*g.random_number_set)\n\n        # thinning uniform rng\n        self.thinning_rng = Uniform(low=0.0, high=1.0,  # pylint: disable=attribute-defined-outside-init\n                                    random_seed=self.run_number*g.random_number_set)\n\n\n    def init_resources(self):\n        '''\n        Init the number of resources\n        and store in the arguments container object\n\n        Resource list:\n            1. Nurses/treatment bays (same thing in this model)\n\n        '''\n        # Shared Resources\n        self.triage_cubicles = VidigiStore(self.env, num_resources=g.n_triage)\n        self.registration_cubicles = VidigiStore(self.env, num_resources=g.n_reg)\n\n        # Non-trauma\n        self.exam_cubicles = VidigiStore(self.env, num_resources=g.n_exam)\n        self.non_trauma_treatment_cubicles = VidigiStore(self.env, g.n_cubicles_non_trauma_treat)\n\n        # Trauma\n        self.trauma_stabilisation_bays = VidigiStore(self.env, num_resources=g.n_trauma)\n        self.trauma_treatment_cubicles = VidigiStore(self.env, num_resources=g.n_cubicles_trauma_treat)\n\n    # A generator function that represents the DES generator for patient\n    # arrivals\n    def generator_patient_arrivals(self):\n        # We use an infinite loop here to keep doing this indefinitely whilst\n        # the simulation runs\n        while True:\n            t = int(self.env.now // 60) % self.arrivals.shape[0]\n            lambda_t = self.arrivals['arrival_rate'].iloc[t]\n\n            # set to a large number so that at least 1 sample taken!\n            u = np.Inf\n\n            interarrival_time = 0.0\n            # reject samples if u &gt;= lambda_t / lambda_max\n            while u &gt;= (lambda_t / self.lambda_max):\n                interarrival_time += self.arrival_dist.sample()\n                u = self.thinning_rng.sample()\n\n            # Freeze this instance of this function in place until the\n            # inter-arrival time we sampled above has elapsed.  Note - time in\n            # SimPy progresses in \"Time Units\", which can represent anything\n            # you like (just make sure you're consistent within the model)\n            yield self.env.timeout(interarrival_time)\n\n            # Increment the patient counter by 1 (this means our first patient\n            # will have an ID of 1)\n            self.patient_counter += 1\n\n            # Create a new patient - an instance of the Patient Class we\n            # defined above.  Remember, we pass in the ID when creating a\n            # patient - so here we pass the patient counter to use as the ID.\n            p = Patient(self.patient_counter)\n\n            self.logger.log_arrival(entity_id=p.identifier,\n                                    pathway=\"Shared\")\n\n            # sample if the patient is trauma or non-trauma\n            trauma = self.p_trauma_dist.sample()\n\n            # Tell SimPy to start up the attend_clinic generator function with\n            # this patient (the generator function that will model the\n            # patient's journey through the system)\n            # and store patient in list for later easy access\n            if trauma:\n                # create and store a trauma patient to update KPIs.\n                self.trauma_patients.append(p)\n                self.env.process(self.attend_trauma_pathway(p))\n\n            else:\n                # create and store a non-trauma patient to update KPIs.\n                self.non_trauma_patients.append(p)\n                self.env.process(self.attend_non_trauma_pathway(p))\n\n    # A generator function that represents the pathway for a patient going\n    # through the clinic.\n    # The patient object is passed in to the generator function so we can\n    # extract information from / record information to it\n    def attend_non_trauma_pathway(self, patient):\n        '''\n        simulates the non-trauma/minor treatment process for a patient\n\n        1. request and wait for sign-in/triage\n        2. patient registration\n        3. examination\n        4a. percentage discharged\n        4b. remaining percentage treatment then discharge\n        '''\n        # record the time of arrival and entered the triage queue\n        patient.arrival = self.env.now\n\n        self.logger.log_queue(\n            entity_id=patient.identifier,\n            pathway='Non-Trauma',\n            event='triage_wait_begins'\n            )\n\n        ###################################################\n        # request sign-in/triage\n        with self.triage_cubicles.request() as req:\n            triage_resource = yield req\n\n            # record the waiting time for triage\n            patient.wait_triage = self.env.now - patient.arrival\n\n            self.logger.log_resource_use_start(\n                entity_id=patient.identifier,\n                pathway='Non-Trauma',\n                event='triage_begins',\n                resource_id=triage_resource.id_attribute\n                )\n\n            # sample triage duration.\n            patient.triage_duration = self.triage_dist.sample()\n            yield self.env.timeout(patient.triage_duration)\n\n            self.logger.log_resource_use_end(\n                entity_id=patient.identifier,\n                pathway='Non-Trauma',\n                event='triage_complete',\n                resource_id=triage_resource.id_attribute\n                )\n\n        #########################################################\n\n        # record the time that entered the registration queue\n        start_wait = self.env.now\n\n        self.logger.log_queue(\n            entity_id=patient.identifier,\n            pathway='Non-Trauma',\n            event='MINORS_registration_wait_begins'\n            )\n\n        #########################################################\n        # request registration clerk\n        with self.registration_cubicles.request() as req:\n            registration_resource = yield req\n\n            # record the waiting time for registration\n            patient.wait_reg = self.env.now - start_wait\n\n            self.logger.log_resource_use_start(\n                    entity_id=patient.identifier,\n                    pathway='Non-Trauma',\n                    event='MINORS_registration_begins',\n                    resource_id=registration_resource.id_attribute\n                    )\n\n            # sample registration duration.\n            patient.reg_duration = self.reg_dist.sample()\n\n            yield self.env.timeout(patient.reg_duration)\n\n            self.logger.log_resource_use_end(\n                    entity_id=patient.identifier,\n                    pathway='Non-Trauma',\n                    event='MINORS_registration_complete',\n                    resource_id=registration_resource.id_attribute\n                    )\n\n        ########################################################\n\n        # record the time that entered the evaluation queue\n        start_wait = self.env.now\n\n        self.logger.log_queue(\n            entity_id=patient.identifier,\n            pathway='Non-Trauma',\n            event='MINORS_examination_wait_begins'\n            )\n\n        #########################################################\n        # request examination resource\n        with self.exam_cubicles.request() as req:\n            examination_resource = yield req\n\n            # record the waiting time for examination to begin\n            patient.wait_exam = self.env.now - start_wait\n\n            self.logger.log_resource_use_start(\n                    entity_id=patient.identifier,\n                    pathway='Non-Trauma',\n                    event='MINORS_examination_begins',\n                    resource_id=examination_resource.id_attribute\n                    )\n\n            # sample examination duration.\n            patient.exam_duration = self.exam_dist.sample()\n\n            yield self.env.timeout(patient.exam_duration)\n\n            self.logger.log_resource_use_end(\n                    entity_id=patient.identifier,\n                    pathway='Non-Trauma',\n                    event='MINORS_examination_complete',\n                    resource_id=examination_resource.id_attribute\n                    )\n\n        ############################################################################\n\n        # sample if patient requires treatment?\n        patient.require_treat = self.nt_p_treat_dist.sample()  #pylint: disable=attribute-defined-outside-init\n\n        if patient.require_treat:\n\n            self.logger.log_event(\n                entity_id = patient.identifier,\n                pathway = 'Non-Trauma',\n                event = 'requires_treatment',\n                event_type = 'attribute_assigned'\n            )\n\n            # record the time that entered the treatment queue\n            start_wait = self.env.now\n\n            self.logger.log_queue(\n                entity_id = patient.identifier,\n                pathway='Non-Trauma',\n                event='MINORS_treatment_wait_begins'\n                )\n\n            ###################################################\n            # request treatment cubicle\n\n            with self.non_trauma_treatment_cubicles.request() as req:\n                non_trauma_treatment_resource = yield req\n\n                # record the waiting time for treatment\n                patient.wait_treat = self.env.now - start_wait\n\n                self.logger.log_resource_use_start(\n                    entity_id=patient.identifier,\n                    pathway='Non-Trauma',\n                    event='MINORS_treatment_begins',\n                    resource_id=non_trauma_treatment_resource.id_attribute\n                    )\n\n                # sample treatment duration.\n                patient.treat_duration = self.nt_treat_dist.sample()\n                yield self.env.timeout(patient.treat_duration)\n\n                self.logger.log_resource_use_end(\n                    entity_id=patient.identifier,\n                    pathway='Non-Trauma',\n                    event='MINORS_treatment_complete',\n                    resource_id=non_trauma_treatment_resource.id_attribute\n                    )\n\n        ##########################################################################\n\n        # Return to what happens to all patients, regardless of whether\n        # they were sampled as needing treatment\n\n        self.logger.log_departure(\n            entity_id=patient.identifier,\n            pathway='Non-Trauma'\n        )\n\n        # total time in system\n        patient.total_time = self.env.now - patient.arrival\n\n    def attend_trauma_pathway(self, patient):\n        '''\n        simulates the major treatment process for a patient\n\n        1. request and wait for sign-in/triage\n        2. trauma\n        3. treatment\n        '''\n        # record the time of arrival and entered the triage queue\n        patient.arrival = self.env.now\n\n        self.logger.log_queue(\n            entity_id = patient.identifier,\n            pathway = 'Trauma',\n            event = 'triage_wait_begins'\n        )\n\n        ###################################################\n        # request sign-in/triage\n        with self.triage_cubicles.request() as req:\n\n            triage_resource = yield req\n\n            # record the waiting time for triage\n            patient.wait_triage = self.env.now - patient.arrival\n\n            self.logger.log_resource_use_start(\n                entity_id = patient.identifier,\n                pathway = 'Trauma',\n                event = 'triage_begins',\n                resource_id = triage_resource.id_attribute\n            )\n\n            # sample triage duration.\n            patient.triage_duration = self.triage_dist.sample()\n            yield self.env.timeout(patient.triage_duration)\n\n            self.logger.log_resource_use_end(\n                entity_id = patient.identifier,\n                pathway = 'Trauma',\n                event = 'triage_complete',\n                resource_id = triage_resource.id_attribute\n            )\n\n        ###################################################\n\n        # record the time that entered the trauma queue\n        self.logger.log_queue(\n            entity_id = patient.identifier,\n            pathway = 'Trauma',\n            event = 'TRAUMA_stabilisation_wait_begins'\n        )\n        start_wait = self.env.now\n\n        ###################################################\n        # request trauma room\n        with self.trauma_stabilisation_bays.request() as req:\n            trauma_resource = yield req\n\n            self.logger.log_resource_use_start(\n                entity_id = patient.identifier,\n                pathway = 'Trauma',\n                event = 'TRAUMA_stabilisation_begins',\n                resource_id = trauma_resource.id_attribute\n            )\n\n            # record the waiting time for trauma\n            patient.wait_trauma = self.env.now - start_wait\n\n            # sample stablisation duration.\n            patient.trauma_duration = self.trauma_dist.sample()\n            yield self.env.timeout(patient.trauma_duration)\n\n            self.logger.log_resource_use_end(\n                entity_id = patient.identifier,\n                pathway = 'Trauma',\n                event = 'TRAUMA_stabilisation_complete',\n                resource_id = trauma_resource.id_attribute\n            )\n\n        #######################################################\n\n        # record the time that patient entered the treatment queue\n        start_wait = self.env.now\n\n        self.logger.log_queue(\n            entity_id = patient.identifier,\n            pathway = 'Trauma',\n            event = 'TRAUMA_treatment_wait_begins'\n        )\n\n        ########################################################\n        # request treatment cubicle\n        with self.trauma_treatment_cubicles.request() as req:\n            trauma_treatment_resource = yield req\n\n            # record the waiting time for trauma\n            patient.wait_treat = self.env.now - start_wait\n\n            self.logger.log_resource_use_start(\n                    entity_id = patient.identifier,\n                    pathway = 'Trauma',\n                    event = 'TRAUMA_treatment_begins',\n                    resource_id = trauma_treatment_resource.id_attribute\n                )\n\n            # sample treatment duration.\n            patient.treat_duration = self.trauma_dist.sample()\n            yield self.env.timeout(patient.treat_duration)\n\n            self.logger.log_resource_use_end(\n                    entity_id = patient.identifier,\n                    pathway = 'Trauma',\n                    event = 'TRAUMA_treatment_complete',\n                    resource_id = trauma_treatment_resource.id_attribute\n                )\n\n        self.logger.log_departure(\n            entity_id = patient.identifier,\n            pathway = 'Shared'\n        )\n\n        #########################################################\n\n        # total time in system\n        patient.total_time = self.env.now - patient.arrival\n\n    # The run method starts up the DES entity generators, runs the simulation,\n    # and in turns calls anything we need to generate results for the run\n    def run(self):\n        # Start up our DES entity generators that create new patients.  We've\n        # only got one in this model, but we'd need to do this for each one if\n        # we had multiple generators.\n        self.env.process(self.generator_patient_arrivals())\n\n        # Run the model for the duration specified in g class\n        self.env.run(until=g.sim_duration)\n\n\nclass Trial:\n    def  __init__(self):\n        self.all_event_logs = []\n        self.trial_results_df = pd.DataFrame()\n\n        self.run_trial()\n\n    # Method to run a trial\n    def run_trial(self):\n        # Run the simulation for the number of runs specified in g class.\n        # For each run, we create a new instance of the Model class and call its\n        # run method, which sets everything else in motion.  Once the run has\n        # completed, we grab out the stored run results (just mean queuing time\n        # here) and store it against the run number in the trial results\n        # dataframe.\n        for run in range(1, g.number_of_runs+1):\n            random.seed(run)\n\n            my_model = Model(run)\n            my_model.run()\n\n            self.all_event_logs.append(my_model.logger)\n\n        self.trial_results = pd.concat(\n            [run_results.to_dataframe() for run_results in self.all_event_logs]\n            )\n\n\nadvanced_clinic_simulation = Trial()\n\nC:\\simviz\\vidigi\\vidigi\\utils.py:1112: UserWarning:\n\nUnrecognized event_type 'attribute_assigned'. Recommended values are: resource_use_end, resource_use, queue, arrival_departure.\n\nC:\\simviz\\vidigi\\vidigi\\utils.py:1112: UserWarning:\n\nUnrecognized event_type 'attribute_assigned'. Recommended values are: resource_use_end, resource_use, queue, arrival_departure.\n\nC:\\simviz\\vidigi\\vidigi\\utils.py:1112: UserWarning:\n\nUnrecognized event_type 'attribute_assigned'. Recommended values are: resource_use_end, resource_use, queue, arrival_departure.\n\nC:\\simviz\\vidigi\\vidigi\\utils.py:1112: UserWarning:\n\nUnrecognized event_type 'attribute_assigned'. Recommended values are: resource_use_end, resource_use, queue, arrival_departure.\n\nC:\\simviz\\vidigi\\vidigi\\utils.py:1112: UserWarning:\n\nUnrecognized event_type 'attribute_assigned'. Recommended values are: resource_use_end, resource_use, queue, arrival_departure.\n\nC:\\simviz\\vidigi\\vidigi\\utils.py:1112: UserWarning:\n\nUnrecognized event_type 'attribute_assigned'. Recommended values are: resource_use_end, resource_use, queue, arrival_departure.\n\nC:\\simviz\\vidigi\\vidigi\\utils.py:1112: UserWarning:\n\nUnrecognized event_type 'attribute_assigned'. Recommended values are: resource_use_end, resource_use, queue, arrival_departure.\n\nC:\\simviz\\vidigi\\vidigi\\utils.py:1112: UserWarning:\n\nUnrecognized event_type 'attribute_assigned'. Recommended values are: resource_use_end, resource_use, queue, arrival_departure.\n\nC:\\simviz\\vidigi\\vidigi\\utils.py:1112: UserWarning:\n\nUnrecognized event_type 'attribute_assigned'. Recommended values are: resource_use_end, resource_use, queue, arrival_departure.\n\nC:\\simviz\\vidigi\\vidigi\\utils.py:1112: UserWarning:\n\nUnrecognized event_type 'attribute_assigned'. Recommended values are: resource_use_end, resource_use, queue, arrival_departure.\n\nC:\\simviz\\vidigi\\vidigi\\utils.py:1112: UserWarning:\n\nUnrecognized event_type 'attribute_assigned'. Recommended values are: resource_use_end, resource_use, queue, arrival_departure.\n\nC:\\simviz\\vidigi\\vidigi\\utils.py:1112: UserWarning:\n\nUnrecognized event_type 'attribute_assigned'. Recommended values are: resource_use_end, resource_use, queue, arrival_departure.\n\nC:\\simviz\\vidigi\\vidigi\\utils.py:1112: UserWarning:\n\nUnrecognized event_type 'attribute_assigned'. Recommended values are: resource_use_end, resource_use, queue, arrival_departure.\n\nC:\\simviz\\vidigi\\vidigi\\utils.py:1112: UserWarning:\n\nUnrecognized event_type 'attribute_assigned'. Recommended values are: resource_use_end, resource_use, queue, arrival_departure.\n\nC:\\simviz\\vidigi\\vidigi\\utils.py:1112: UserWarning:\n\nUnrecognized event_type 'attribute_assigned'. Recommended values are: resource_use_end, resource_use, queue, arrival_departure.\n\nC:\\simviz\\vidigi\\vidigi\\utils.py:1112: UserWarning:\n\nUnrecognized event_type 'attribute_assigned'. Recommended values are: resource_use_end, resource_use, queue, arrival_departure.\n\nC:\\simviz\\vidigi\\vidigi\\utils.py:1112: UserWarning:\n\nUnrecognized event_type 'attribute_assigned'. Recommended values are: resource_use_end, resource_use, queue, arrival_departure.\n\nC:\\simviz\\vidigi\\vidigi\\utils.py:1112: UserWarning:\n\nUnrecognized event_type 'attribute_assigned'. Recommended values are: resource_use_end, resource_use, queue, arrival_departure.\n\nC:\\simviz\\vidigi\\vidigi\\utils.py:1112: UserWarning:\n\nUnrecognized event_type 'attribute_assigned'. Recommended values are: resource_use_end, resource_use, queue, arrival_departure.\n\nC:\\simviz\\vidigi\\vidigi\\utils.py:1112: UserWarning:\n\nUnrecognized event_type 'attribute_assigned'. Recommended values are: resource_use_end, resource_use, queue, arrival_departure.\n\nC:\\simviz\\vidigi\\vidigi\\utils.py:1112: UserWarning:\n\nUnrecognized event_type 'attribute_assigned'. Recommended values are: resource_use_end, resource_use, queue, arrival_departure.\n\nC:\\simviz\\vidigi\\vidigi\\utils.py:1112: UserWarning:\n\nUnrecognized event_type 'attribute_assigned'. Recommended values are: resource_use_end, resource_use, queue, arrival_departure.\n\nC:\\simviz\\vidigi\\vidigi\\utils.py:1112: UserWarning:\n\nUnrecognized event_type 'attribute_assigned'. Recommended values are: resource_use_end, resource_use, queue, arrival_departure.\n\nC:\\simviz\\vidigi\\vidigi\\utils.py:1112: UserWarning:\n\nUnrecognized event_type 'attribute_assigned'. Recommended values are: resource_use_end, resource_use, queue, arrival_departure.\n\nC:\\simviz\\vidigi\\vidigi\\utils.py:1112: UserWarning:\n\nUnrecognized event_type 'attribute_assigned'. Recommended values are: resource_use_end, resource_use, queue, arrival_departure.\n\nC:\\simviz\\vidigi\\vidigi\\utils.py:1112: UserWarning:\n\nUnrecognized event_type 'attribute_assigned'. Recommended values are: resource_use_end, resource_use, queue, arrival_departure.\n\nC:\\simviz\\vidigi\\vidigi\\utils.py:1112: UserWarning:\n\nUnrecognized event_type 'attribute_assigned'. Recommended values are: resource_use_end, resource_use, queue, arrival_departure.\n\nC:\\simviz\\vidigi\\vidigi\\utils.py:1112: UserWarning:\n\nUnrecognized event_type 'attribute_assigned'. Recommended values are: resource_use_end, resource_use, queue, arrival_departure.\n\nC:\\simviz\\vidigi\\vidigi\\utils.py:1112: UserWarning:\n\nUnrecognized event_type 'attribute_assigned'. Recommended values are: resource_use_end, resource_use, queue, arrival_departure.\n\nC:\\simviz\\vidigi\\vidigi\\utils.py:1112: UserWarning:\n\nUnrecognized event_type 'attribute_assigned'. Recommended values are: resource_use_end, resource_use, queue, arrival_departure.\n\nC:\\simviz\\vidigi\\vidigi\\utils.py:1112: UserWarning:\n\nUnrecognized event_type 'attribute_assigned'. Recommended values are: resource_use_end, resource_use, queue, arrival_departure.\n\nC:\\simviz\\vidigi\\vidigi\\utils.py:1112: UserWarning:\n\nUnrecognized event_type 'attribute_assigned'. Recommended values are: resource_use_end, resource_use, queue, arrival_departure.\n\nC:\\simviz\\vidigi\\vidigi\\utils.py:1112: UserWarning:\n\nUnrecognized event_type 'attribute_assigned'. Recommended values are: resource_use_end, resource_use, queue, arrival_departure.\n\nC:\\simviz\\vidigi\\vidigi\\utils.py:1112: UserWarning:\n\nUnrecognized event_type 'attribute_assigned'. Recommended values are: resource_use_end, resource_use, queue, arrival_departure.\n\nC:\\simviz\\vidigi\\vidigi\\utils.py:1112: UserWarning:\n\nUnrecognized event_type 'attribute_assigned'. Recommended values are: resource_use_end, resource_use, queue, arrival_departure.\n\nC:\\simviz\\vidigi\\vidigi\\utils.py:1112: UserWarning:\n\nUnrecognized event_type 'attribute_assigned'. Recommended values are: resource_use_end, resource_use, queue, arrival_departure.\n\nC:\\simviz\\vidigi\\vidigi\\utils.py:1112: UserWarning:\n\nUnrecognized event_type 'attribute_assigned'. Recommended values are: resource_use_end, resource_use, queue, arrival_departure.\n\nC:\\simviz\\vidigi\\vidigi\\utils.py:1112: UserWarning:\n\nUnrecognized event_type 'attribute_assigned'. Recommended values are: resource_use_end, resource_use, queue, arrival_departure.\n\nC:\\simviz\\vidigi\\vidigi\\utils.py:1112: UserWarning:\n\nUnrecognized event_type 'attribute_assigned'. Recommended values are: resource_use_end, resource_use, queue, arrival_departure.\n\nC:\\simviz\\vidigi\\vidigi\\utils.py:1112: UserWarning:\n\nUnrecognized event_type 'attribute_assigned'. Recommended values are: resource_use_end, resource_use, queue, arrival_departure.\n\nC:\\simviz\\vidigi\\vidigi\\utils.py:1112: UserWarning:\n\nUnrecognized event_type 'attribute_assigned'. Recommended values are: resource_use_end, resource_use, queue, arrival_departure.\n\nC:\\simviz\\vidigi\\vidigi\\utils.py:1112: UserWarning:\n\nUnrecognized event_type 'attribute_assigned'. Recommended values are: resource_use_end, resource_use, queue, arrival_departure.\n\nC:\\simviz\\vidigi\\vidigi\\utils.py:1112: UserWarning:\n\nUnrecognized event_type 'attribute_assigned'. Recommended values are: resource_use_end, resource_use, queue, arrival_departure.\n\nC:\\simviz\\vidigi\\vidigi\\utils.py:1112: UserWarning:\n\nUnrecognized event_type 'attribute_assigned'. Recommended values are: resource_use_end, resource_use, queue, arrival_departure.\n\nC:\\simviz\\vidigi\\vidigi\\utils.py:1112: UserWarning:\n\nUnrecognized event_type 'attribute_assigned'. Recommended values are: resource_use_end, resource_use, queue, arrival_departure.\n\nC:\\simviz\\vidigi\\vidigi\\utils.py:1112: UserWarning:\n\nUnrecognized event_type 'attribute_assigned'. Recommended values are: resource_use_end, resource_use, queue, arrival_departure.\n\nC:\\simviz\\vidigi\\vidigi\\utils.py:1112: UserWarning:\n\nUnrecognized event_type 'attribute_assigned'. Recommended values are: resource_use_end, resource_use, queue, arrival_departure.\n\nC:\\simviz\\vidigi\\vidigi\\utils.py:1112: UserWarning:\n\nUnrecognized event_type 'attribute_assigned'. Recommended values are: resource_use_end, resource_use, queue, arrival_departure.\n\nC:\\simviz\\vidigi\\vidigi\\utils.py:1112: UserWarning:\n\nUnrecognized event_type 'attribute_assigned'. Recommended values are: resource_use_end, resource_use, queue, arrival_departure.\n\nC:\\simviz\\vidigi\\vidigi\\utils.py:1112: UserWarning:\n\nUnrecognized event_type 'attribute_assigned'. Recommended values are: resource_use_end, resource_use, queue, arrival_departure.\n\nC:\\simviz\\vidigi\\vidigi\\utils.py:1112: UserWarning:\n\nUnrecognized event_type 'attribute_assigned'. Recommended values are: resource_use_end, resource_use, queue, arrival_departure.\n\nC:\\simviz\\vidigi\\vidigi\\utils.py:1112: UserWarning:\n\nUnrecognized event_type 'attribute_assigned'. Recommended values are: resource_use_end, resource_use, queue, arrival_departure.\n\nC:\\simviz\\vidigi\\vidigi\\utils.py:1112: UserWarning:\n\nUnrecognized event_type 'attribute_assigned'. Recommended values are: resource_use_end, resource_use, queue, arrival_departure.\n\nC:\\simviz\\vidigi\\vidigi\\utils.py:1112: UserWarning:\n\nUnrecognized event_type 'attribute_assigned'. Recommended values are: resource_use_end, resource_use, queue, arrival_departure.\n\nC:\\simviz\\vidigi\\vidigi\\utils.py:1112: UserWarning:\n\nUnrecognized event_type 'attribute_assigned'. Recommended values are: resource_use_end, resource_use, queue, arrival_departure.\n\nC:\\simviz\\vidigi\\vidigi\\utils.py:1112: UserWarning:\n\nUnrecognized event_type 'attribute_assigned'. Recommended values are: resource_use_end, resource_use, queue, arrival_departure.\n\nC:\\simviz\\vidigi\\vidigi\\utils.py:1112: UserWarning:\n\nUnrecognized event_type 'attribute_assigned'. Recommended values are: resource_use_end, resource_use, queue, arrival_departure.\n\nC:\\simviz\\vidigi\\vidigi\\utils.py:1112: UserWarning:\n\nUnrecognized event_type 'attribute_assigned'. Recommended values are: resource_use_end, resource_use, queue, arrival_departure.\n\nC:\\simviz\\vidigi\\vidigi\\utils.py:1112: UserWarning:\n\nUnrecognized event_type 'attribute_assigned'. Recommended values are: resource_use_end, resource_use, queue, arrival_departure.\n\nC:\\simviz\\vidigi\\vidigi\\utils.py:1112: UserWarning:\n\nUnrecognized event_type 'attribute_assigned'. Recommended values are: resource_use_end, resource_use, queue, arrival_departure.\n\nC:\\simviz\\vidigi\\vidigi\\utils.py:1112: UserWarning:\n\nUnrecognized event_type 'attribute_assigned'. Recommended values are: resource_use_end, resource_use, queue, arrival_departure.\n\nC:\\simviz\\vidigi\\vidigi\\utils.py:1112: UserWarning:\n\nUnrecognized event_type 'attribute_assigned'. Recommended values are: resource_use_end, resource_use, queue, arrival_departure.\n\nC:\\simviz\\vidigi\\vidigi\\utils.py:1112: UserWarning:\n\nUnrecognized event_type 'attribute_assigned'. Recommended values are: resource_use_end, resource_use, queue, arrival_departure.\n\nC:\\simviz\\vidigi\\vidigi\\utils.py:1112: UserWarning:\n\nUnrecognized event_type 'attribute_assigned'. Recommended values are: resource_use_end, resource_use, queue, arrival_departure.\n\nC:\\simviz\\vidigi\\vidigi\\utils.py:1112: UserWarning:\n\nUnrecognized event_type 'attribute_assigned'. Recommended values are: resource_use_end, resource_use, queue, arrival_departure.\n\nC:\\simviz\\vidigi\\vidigi\\utils.py:1112: UserWarning:\n\nUnrecognized event_type 'attribute_assigned'. Recommended values are: resource_use_end, resource_use, queue, arrival_departure.\n\nC:\\simviz\\vidigi\\vidigi\\utils.py:1112: UserWarning:\n\nUnrecognized event_type 'attribute_assigned'. Recommended values are: resource_use_end, resource_use, queue, arrival_departure.\n\nC:\\simviz\\vidigi\\vidigi\\utils.py:1112: UserWarning:\n\nUnrecognized event_type 'attribute_assigned'. Recommended values are: resource_use_end, resource_use, queue, arrival_departure.\n\nC:\\simviz\\vidigi\\vidigi\\utils.py:1112: UserWarning:\n\nUnrecognized event_type 'attribute_assigned'. Recommended values are: resource_use_end, resource_use, queue, arrival_departure.\n\nC:\\simviz\\vidigi\\vidigi\\utils.py:1112: UserWarning:\n\nUnrecognized event_type 'attribute_assigned'. Recommended values are: resource_use_end, resource_use, queue, arrival_departure.\n\nC:\\simviz\\vidigi\\vidigi\\utils.py:1112: UserWarning:\n\nUnrecognized event_type 'attribute_assigned'. Recommended values are: resource_use_end, resource_use, queue, arrival_departure.\n\nC:\\simviz\\vidigi\\vidigi\\utils.py:1112: UserWarning:\n\nUnrecognized event_type 'attribute_assigned'. Recommended values are: resource_use_end, resource_use, queue, arrival_departure.\n\nC:\\simviz\\vidigi\\vidigi\\utils.py:1112: UserWarning:\n\nUnrecognized event_type 'attribute_assigned'. Recommended values are: resource_use_end, resource_use, queue, arrival_departure.\n\nC:\\simviz\\vidigi\\vidigi\\utils.py:1112: UserWarning:\n\nUnrecognized event_type 'attribute_assigned'. Recommended values are: resource_use_end, resource_use, queue, arrival_departure.\n\nC:\\simviz\\vidigi\\vidigi\\utils.py:1112: UserWarning:\n\nUnrecognized event_type 'attribute_assigned'. Recommended values are: resource_use_end, resource_use, queue, arrival_departure.\n\nC:\\simviz\\vidigi\\vidigi\\utils.py:1112: UserWarning:\n\nUnrecognized event_type 'attribute_assigned'. Recommended values are: resource_use_end, resource_use, queue, arrival_departure.\n\nC:\\simviz\\vidigi\\vidigi\\utils.py:1112: UserWarning:\n\nUnrecognized event_type 'attribute_assigned'. Recommended values are: resource_use_end, resource_use, queue, arrival_departure.\n\nC:\\simviz\\vidigi\\vidigi\\utils.py:1112: UserWarning:\n\nUnrecognized event_type 'attribute_assigned'. Recommended values are: resource_use_end, resource_use, queue, arrival_departure.\n\nC:\\simviz\\vidigi\\vidigi\\utils.py:1112: UserWarning:\n\nUnrecognized event_type 'attribute_assigned'. Recommended values are: resource_use_end, resource_use, queue, arrival_departure.\n\nC:\\simviz\\vidigi\\vidigi\\utils.py:1112: UserWarning:\n\nUnrecognized event_type 'attribute_assigned'. Recommended values are: resource_use_end, resource_use, queue, arrival_departure.\n\nC:\\simviz\\vidigi\\vidigi\\utils.py:1112: UserWarning:\n\nUnrecognized event_type 'attribute_assigned'. Recommended values are: resource_use_end, resource_use, queue, arrival_departure.\n\nC:\\simviz\\vidigi\\vidigi\\utils.py:1112: UserWarning:\n\nUnrecognized event_type 'attribute_assigned'. Recommended values are: resource_use_end, resource_use, queue, arrival_departure.\n\nC:\\simviz\\vidigi\\vidigi\\utils.py:1112: UserWarning:\n\nUnrecognized event_type 'attribute_assigned'. Recommended values are: resource_use_end, resource_use, queue, arrival_departure.\n\nC:\\simviz\\vidigi\\vidigi\\utils.py:1112: UserWarning:\n\nUnrecognized event_type 'attribute_assigned'. Recommended values are: resource_use_end, resource_use, queue, arrival_departure.\n\nC:\\simviz\\vidigi\\vidigi\\utils.py:1112: UserWarning:\n\nUnrecognized event_type 'attribute_assigned'. Recommended values are: resource_use_end, resource_use, queue, arrival_departure.\n\nC:\\simviz\\vidigi\\vidigi\\utils.py:1112: UserWarning:\n\nUnrecognized event_type 'attribute_assigned'. Recommended values are: resource_use_end, resource_use, queue, arrival_departure.\n\nC:\\simviz\\vidigi\\vidigi\\utils.py:1112: UserWarning:\n\nUnrecognized event_type 'attribute_assigned'. Recommended values are: resource_use_end, resource_use, queue, arrival_departure.\n\nC:\\simviz\\vidigi\\vidigi\\utils.py:1112: UserWarning:\n\nUnrecognized event_type 'attribute_assigned'. Recommended values are: resource_use_end, resource_use, queue, arrival_departure.\n\nC:\\simviz\\vidigi\\vidigi\\utils.py:1112: UserWarning:\n\nUnrecognized event_type 'attribute_assigned'. Recommended values are: resource_use_end, resource_use, queue, arrival_departure.\n\nC:\\simviz\\vidigi\\vidigi\\utils.py:1112: UserWarning:\n\nUnrecognized event_type 'attribute_assigned'. Recommended values are: resource_use_end, resource_use, queue, arrival_departure.\n\nC:\\simviz\\vidigi\\vidigi\\utils.py:1112: UserWarning:\n\nUnrecognized event_type 'attribute_assigned'. Recommended values are: resource_use_end, resource_use, queue, arrival_departure.\n\nC:\\simviz\\vidigi\\vidigi\\utils.py:1112: UserWarning:\n\nUnrecognized event_type 'attribute_assigned'. Recommended values are: resource_use_end, resource_use, queue, arrival_departure.\n\nC:\\simviz\\vidigi\\vidigi\\utils.py:1112: UserWarning:\n\nUnrecognized event_type 'attribute_assigned'. Recommended values are: resource_use_end, resource_use, queue, arrival_departure.\n\nC:\\simviz\\vidigi\\vidigi\\utils.py:1112: UserWarning:\n\nUnrecognized event_type 'attribute_assigned'. Recommended values are: resource_use_end, resource_use, queue, arrival_departure.\n\nC:\\simviz\\vidigi\\vidigi\\utils.py:1112: UserWarning:\n\nUnrecognized event_type 'attribute_assigned'. Recommended values are: resource_use_end, resource_use, queue, arrival_departure.\n\nC:\\simviz\\vidigi\\vidigi\\utils.py:1112: UserWarning:\n\nUnrecognized event_type 'attribute_assigned'. Recommended values are: resource_use_end, resource_use, queue, arrival_departure.\n\nC:\\simviz\\vidigi\\vidigi\\utils.py:1112: UserWarning:\n\nUnrecognized event_type 'attribute_assigned'. Recommended values are: resource_use_end, resource_use, queue, arrival_departure.\n\nC:\\simviz\\vidigi\\vidigi\\utils.py:1112: UserWarning:\n\nUnrecognized event_type 'attribute_assigned'. Recommended values are: resource_use_end, resource_use, queue, arrival_departure.\n\nC:\\simviz\\vidigi\\vidigi\\utils.py:1112: UserWarning:\n\nUnrecognized event_type 'attribute_assigned'. Recommended values are: resource_use_end, resource_use, queue, arrival_departure.\n\nC:\\simviz\\vidigi\\vidigi\\utils.py:1112: UserWarning:\n\nUnrecognized event_type 'attribute_assigned'. Recommended values are: resource_use_end, resource_use, queue, arrival_departure.\n\n\n\n\nadvanced_clinic_simulation.all_event_logs[0].get_events_by_entity(5)\n\n\n\n\n\n\n\n\nentity_id\nevent_type\nevent\ntime\npathway\nrun_number\ntimestamp\nresource_id\n\n\n\n\n0\n5\narrival_departure\narrival\n125.487189\nShared\n1\nNone\nNaN\n\n\n1\n5\nqueue\ntriage_wait_begins\n125.487189\nNon-Trauma\n1\nNone\nNaN\n\n\n2\n5\nresource_use\ntriage_begins\n125.487189\nNon-Trauma\n1\nNone\n1.0\n\n\n3\n5\nresource_use_end\ntriage_complete\n126.005814\nNon-Trauma\n1\nNone\n1.0\n\n\n4\n5\nqueue\nMINORS_registration_wait_begins\n126.005814\nNon-Trauma\n1\nNone\nNaN\n\n\n5\n5\nresource_use\nMINORS_registration_begins\n126.005814\nNon-Trauma\n1\nNone\n1.0\n\n\n6\n5\nresource_use_end\nMINORS_registration_complete\n131.600448\nNon-Trauma\n1\nNone\n1.0\n\n\n7\n5\nqueue\nMINORS_examination_wait_begins\n131.600448\nNon-Trauma\n1\nNone\nNaN\n\n\n8\n5\nresource_use\nMINORS_examination_begins\n131.600448\nNon-Trauma\n1\nNone\n1.0\n\n\n9\n5\nresource_use_end\nMINORS_examination_complete\n149.229554\nNon-Trauma\n1\nNone\n1.0\n\n\n10\n5\nattribute_assigned\nrequires_treatment\n149.229554\nNon-Trauma\n1\nNone\nNaN\n\n\n11\n5\nqueue\nMINORS_treatment_wait_begins\n149.229554\nNon-Trauma\n1\nNone\nNaN\n\n\n\n\n\n\n\n\nadvanced_clinic_simulation.trial_results\n\n\n\n\n\n\n\n\nentity_id\nevent_type\nevent\ntime\npathway\nrun_number\ntimestamp\nresource_id\n\n\n\n\n0\n1\narrival_departure\narrival\n37.593555\nShared\n1\nNone\nNaN\n\n\n1\n1\nqueue\ntriage_wait_begins\n37.593555\nNon-Trauma\n1\nNone\nNaN\n\n\n2\n1\nresource_use\ntriage_begins\n37.593555\nNon-Trauma\n1\nNone\n1.0\n\n\n3\n2\narrival_departure\narrival\n51.835879\nShared\n1\nNone\nNaN\n\n\n4\n2\nqueue\ntriage_wait_begins\n51.835879\nNon-Trauma\n1\nNone\nNaN\n\n\n...\n...\n...\n...\n...\n...\n...\n...\n...\n\n\n1325\n89\nresource_use\nMINORS_examination_begins\n598.166934\nNon-Trauma\n100\nNone\n2.0\n\n\n1326\n87\nresource_use_end\nMINORS_examination_complete\n598.990148\nNon-Trauma\n100\nNone\n1.0\n\n\n1327\n87\nattribute_assigned\nrequires_treatment\n598.990148\nNon-Trauma\n100\nNone\nNaN\n\n\n1328\n87\nqueue\nMINORS_treatment_wait_begins\n598.990148\nNon-Trauma\n100\nNone\nNaN\n\n\n1329\n86\nresource_use\nMINORS_examination_begins\n598.990148\nNon-Trauma\n100\nNone\n1.0\n\n\n\n\n132814 rows × 8 columns\n\n\n\n\nevent_position_df = pd.DataFrame([\n                # {'event': 'arrival', 'x':  10, 'y': 250, 'label': \"Arrival\" },\n\n                # Triage - minor and trauma\n                {'event': 'triage_wait_begins',\n                 'x':  160, 'y': 375, 'label': \"Waiting for&lt;br&gt;Triage\"  },\n                {'event': 'triage_begins',\n                 'x':  160, 'y': 315, 'resource':'n_triage', 'label': \"Being Triaged\" },\n\n                # Minors (non-trauma) pathway\n                {'event': 'MINORS_registration_wait_begins',\n                 'x':  300, 'y': 145, 'label': \"Waiting for&lt;br&gt;Registration\"  },\n                {'event': 'MINORS_registration_begins',\n                 'x':  300, 'y': 85, 'resource':'n_reg', 'label':'Being&lt;br&gt;Registered'  },\n\n                {'event': 'MINORS_examination_wait_begins',\n                 'x':  465, 'y': 145, 'label': \"Waiting for&lt;br&gt;Examination\"  },\n                {'event': 'MINORS_examination_begins',\n                 'x':  465, 'y': 85, 'resource':'n_exam', 'label': \"Being&lt;br&gt;Examined\" },\n\n                {'event': 'MINORS_treatment_wait_begins',\n                 'x':  630, 'y': 145, 'label': \"Waiting for&lt;br&gt;Treatment\"  },\n                {'event': 'MINORS_treatment_begins',\n                 'x':  630, 'y': 85, 'resource':'n_cubicles_non_trauma_treat', 'label': \"Being&lt;br&gt;Treated\" },\n\n                # Trauma pathway\n                {'event': 'TRAUMA_stabilisation_wait_begins',\n                 'x': 300, 'y': 560, 'label': \"Waiting for&lt;br&gt;Stabilisation\" },\n                {'event': 'TRAUMA_stabilisation_begins',\n                 'x': 300, 'y': 490, 'resource':'n_trauma', 'label': \"Being&lt;br&gt;Stabilised\" },\n\n                {'event': 'TRAUMA_treatment_wait_begins',\n                 'x': 630, 'y': 560, 'label': \"Waiting for&lt;br&gt;Treatment\" },\n                {'event': 'TRAUMA_treatment_begins',\n                 'x': 630, 'y': 490, 'resource':'n_cubicles_trauma_treat', 'label': \"Being&lt;br&gt;Treated\" },\n\n                 {'event': 'depart',\n                 'x':  670, 'y': 330, 'label': \"Exit\"}\n            ])\n\n\nanimate_activity_log(\n        event_log=advanced_clinic_simulation.trial_results[advanced_clinic_simulation.trial_results['run_number']==1],\n        event_position_df= event_position_df,\n        scenario=g(),\n        debug_mode=True,\n        setup_mode=False,\n        every_x_time_units=10,\n        include_play_button=True,\n        gap_between_entities=10,\n        gap_between_queue_rows=20,\n        plotly_height=900,\n        plotly_width=1600,\n        override_x_max=700,\n        override_y_max=675,\n        entity_icon_size=20,\n        resource_icon_size=20,\n        wrap_queues_at=10,\n        step_snapshot_max=50,\n        limit_duration=g.sim_duration,\n        time_display_units=\"dhm\",\n        display_stage_labels=False,\n        add_background_image=\"https://raw.githubusercontent.com/Bergam0t/vidigi/refs/heads/main/examples/example_2_branching_multistep/Full%20Model%20Background%20Image%20-%20Horizontal%20Layout.drawio.png\",\n    )\n\nAnimation function called at 15:33:08\nIteration through time-unit-by-time-unit logs complete 15:33:08\nSnapshot df concatenation complete at 15:33:08\nReshaped animation dataframe finished construction at 15:33:08\nPlacement dataframe finished construction at 15:33:09\nOutput animation generation complete at 15:33:09\nTotal Time Elapsed: 0.87 seconds",
    "crumbs": [
      "Details",
      "Feature Example: Event Logging Helpers"
    ]
  },
  {
    "objectID": "reference/animation.animate_activity_log.html",
    "href": "reference/animation.animate_activity_log.html",
    "title": "animation.animate_activity_log",
    "section": "",
    "text": "animation.animate_activity_log(\n    event_log,\n    event_position_df,\n    scenario=None,\n    time_col_name='time',\n    entity_col_name='entity_id',\n    event_type_col_name='event_type',\n    event_col_name='event',\n    pathway_col_name=None,\n    resource_col_name='resource_id',\n    simulation_time_unit='minutes',\n    every_x_time_units=10,\n    wrap_queues_at=20,\n    wrap_resources_at=20,\n    step_snapshot_max=50,\n    limit_duration=10 * 60 * 24,\n    plotly_height=900,\n    plotly_width=None,\n    include_play_button=True,\n    add_background_image=None,\n    display_stage_labels=True,\n    entity_icon_size=24,\n    text_size=24,\n    resource_icon_size=24,\n    gap_between_entities=10,\n    gap_between_queue_rows=30,\n    gap_between_resource_rows=30,\n    gap_between_resources=10,\n    resource_opacity=0.8,\n    custom_resource_icon=None,\n    override_x_max=None,\n    override_y_max=None,\n    start_date=None,\n    start_time=None,\n    time_display_units=None,\n    setup_mode=False,\n    frame_duration=400,\n    frame_transition_duration=600,\n    debug_mode=False,\n    custom_entity_icon_list=None,\n)\nGenerate an animated visualization of patient flow through a system.\n\nThis function processes event log data, adds positional information, and creates\nan interactive Plotly animation representing patient movement through various stages.\n\n\nevent_log : pd.DataFrame\n    The log of events to be animated, containing patient activities.\nevent_position_df : pd.DataFrame\n    DataFrame specifying the positions of different events, with columns 'event', 'x', and 'y'.\nscenario : object\n    An object containing attributes for resource counts at different steps.\n    time_col_name : str, default=\"time\"\n    Name of the column in `event_log` that contains the timestamp of each event.\n    Timestamps should represent the number of time units since the simulation began.\nentity_col_name : str, default=\"entity_id\"\n    Name of the column in `event_log` that contains the unique identifier for each entity\n    (e.g., \"entity_id\",  \"entity\", \"patient\", \"patient_id\", \"customer\", \"ID\").\nevent_type_col_name : str, default=\"event_type\"\n    Name of the column in `event_log` that specifies the category of the event.\n    Supported event types include 'arrival_departure', 'resource_use',\n    'resource_use_end', and 'queue'.\nevent_col_name : str, default=\"event\"\n    Name of the column in `event_log` that specifies the actual event that occurred.\npathway_col_name : str, optional, default=None\n    Name of the column in `event_log` that identifies the specific pathway or\n    process flow the entity is following. If `None`, it is assumed that pathway\n    information is not present.\nresource_col_name : str, default=\"resource_id\"\n    Name of the column for the resource identifier. Used for 'resource_use' events.\nsimulation_time_unit: string, optional\n    Time unit used within the simulation (default is minutes).\n    Possible values are 'seconds', 'minutes', 'hours', 'days', 'weeks', 'years'\nevery_x_time_units : int, optional\n    Time interval between animation frames in minutes (default is 10).\nwrap_queues_at : int, optional\n    Maximum number of entities to display in a queue before wrapping to a new row (default is 20).\nwrap_resources_at : int, optional\n    Number of resources to show before wrapping to a new row (default is 20).\nstep_snapshot_max : int, optional\n    Maximum number of patients to show in each snapshot per event (default is 50).\nlimit_duration : int, optional\n    Maximum duration to animate in minutes (default is 10 days or 14400 minutes).\nplotly_height : int, optional\n    Height of the Plotly figure in pixels (default is 900).\nplotly_width : int, optional\n    Width of the Plotly figure in pixels (default is None, which auto-adjusts).\ninclude_play_button : bool, optional\n    Whether to include a play button in the animation (default is True).\nadd_background_image : str, optional\n    Path to a background image file to add to the animation (default is None).\ndisplay_stage_labels : bool, optional\n    Whether to display labels for each stage (default is True).\nentity_icon_size : int, optional\n    Size of entity icons in the animation (default is 24).\ntext_size : int, optional\n    Size of text labels in the animation (default is 24).\nresource_icon_size : int, optional\n    Size of resource icons in the animation (default is 24).\ngap_between_entities : int, optional\n    Horizontal spacing between entities in pixels (default is 10).\ngap_between_queue_rows : int, optional\n    Vertical spacing between rows in pixels (default is 30).\ngap_between_resource_rows : int, optional\n    Vertical spacing between rows in pixels (default is 30).\ngap_between_resources : int, optional\n    Horizontal spacing between resources in pixels (default is 10).\nresource_opacity : float, optional\n    Opacity of resource icons (default is 0.8).\ncustom_resource_icon : str, optional\n    Custom icon to use for resources (default is None).\noverride_x_max : int, optional\n    Override the maximum x-coordinate of the plot (default is None).\noverride_y_max : int, optional\n    Override the maximum y-coordinate of the plot (default is None).\ntime_display_units : str, optional\n    Format for displaying time on the animation timeline. This affects how simulation time is\n    converted into human-readable dates or clock formats. If `None` (default), the raw simulation\n    time is used.\n\n    Predefined options:\n    - 'dhms' : Day Month Year + HH:MM:SS (e.g., \"06 June 2025\n14:23:45”) - ‘dhms_ampm’ : Same as ‘dhms’, but in 12-hour format with AM/PM (e.g., “06 June 2025 02:23:45 PM”) - ‘dhm’ : Day Month Year + HH:MM (e.g., “06 June 2025 14:23”) - ‘dhm_ampm’ : 12-hour format with AM/PM (e.g., “06 June 2025 02:23 PM”) - ‘dh’ : Day Month Year + HH (e.g., “06 June 2025 14”) - ‘dh_ampm’ : 12-hour format with AM/PM (e.g., “06 June 2025 02 PM”) - ‘d’ : Full weekday and date (e.g., “Friday 06 June 2025”) - ‘m’ : Month and year (e.g., “June 2025”) - ‘y’ : Year only (e.g., “2025”) - ‘day_clock’ or ‘simulation_day_clock’: Show simulation-relative day and time (e.g., “Simulation Day 3 14:15”) - ‘day_clock_ampm’ or ‘simulation_day_clock_ampm’: Same as above, but time is shown in 12-hour clock with AM/PM (e.g., “Simulation Day 3 02:15 PM”)\n    Alternatively, you can supply a custom [strftime](https://strftime.org/) format string\n    (e.g., '%Y-%m-%d %H') to control the display manually.\nsetup_mode : bool, optional\n    If True, display grid and tick marks for initial setup (default is False).\nframe_duration : int, optional\n    Duration of each frame in milliseconds (default is 400).\nframe_transition_duration : int, optional\n    Duration of transition between frames in milliseconds (default is 600).\ndebug_mode : bool, optional\n    If True, print debug information during processing (default is False).\ncustom_entity_icon_list: list, optional\n    If given, overrides the default list of emojis used to represent entities\n\n\n\nplotly.graph_objs._figure.Figure\n    An animated Plotly figure object representing the patient flow.\n\n\n\n- This function uses helper functions: reshape_for_animations, generate_animation_df, and generate_animation.\n- The animation supports customization of icon sizes, resource representation, and animation speed.\n- Time can be displayed as actual dates or as model time units.\n- A background image can be added to provide context for the patient flow.\n- The function handles both queuing and resource use events.\n\n\n\n&gt;&gt;&gt; animation = animate_activity_log(event_log, event_positions, scenario,\n...                                  time_display_units='dhm',\n...                                  add_background_image='path/to/image.png')\n&gt;&gt;&gt; animation.show()",
    "crumbs": [
      "vidigi Function Reference",
      "All-In-One Animation Functions",
      "animation.animate_activity_log"
    ]
  },
  {
    "objectID": "reference/animation.animate_activity_log.html#parameters",
    "href": "reference/animation.animate_activity_log.html#parameters",
    "title": "animation.animate_activity_log",
    "section": "",
    "text": "event_log : pd.DataFrame\n    The log of events to be animated, containing patient activities.\nevent_position_df : pd.DataFrame\n    DataFrame specifying the positions of different events, with columns 'event', 'x', and 'y'.\nscenario : object\n    An object containing attributes for resource counts at different steps.\n    time_col_name : str, default=\"time\"\n    Name of the column in `event_log` that contains the timestamp of each event.\n    Timestamps should represent the number of time units since the simulation began.\nentity_col_name : str, default=\"entity_id\"\n    Name of the column in `event_log` that contains the unique identifier for each entity\n    (e.g., \"entity_id\",  \"entity\", \"patient\", \"patient_id\", \"customer\", \"ID\").\nevent_type_col_name : str, default=\"event_type\"\n    Name of the column in `event_log` that specifies the category of the event.\n    Supported event types include 'arrival_departure', 'resource_use',\n    'resource_use_end', and 'queue'.\nevent_col_name : str, default=\"event\"\n    Name of the column in `event_log` that specifies the actual event that occurred.\npathway_col_name : str, optional, default=None\n    Name of the column in `event_log` that identifies the specific pathway or\n    process flow the entity is following. If `None`, it is assumed that pathway\n    information is not present.\nresource_col_name : str, default=\"resource_id\"\n    Name of the column for the resource identifier. Used for 'resource_use' events.\nsimulation_time_unit: string, optional\n    Time unit used within the simulation (default is minutes).\n    Possible values are 'seconds', 'minutes', 'hours', 'days', 'weeks', 'years'\nevery_x_time_units : int, optional\n    Time interval between animation frames in minutes (default is 10).\nwrap_queues_at : int, optional\n    Maximum number of entities to display in a queue before wrapping to a new row (default is 20).\nwrap_resources_at : int, optional\n    Number of resources to show before wrapping to a new row (default is 20).\nstep_snapshot_max : int, optional\n    Maximum number of patients to show in each snapshot per event (default is 50).\nlimit_duration : int, optional\n    Maximum duration to animate in minutes (default is 10 days or 14400 minutes).\nplotly_height : int, optional\n    Height of the Plotly figure in pixels (default is 900).\nplotly_width : int, optional\n    Width of the Plotly figure in pixels (default is None, which auto-adjusts).\ninclude_play_button : bool, optional\n    Whether to include a play button in the animation (default is True).\nadd_background_image : str, optional\n    Path to a background image file to add to the animation (default is None).\ndisplay_stage_labels : bool, optional\n    Whether to display labels for each stage (default is True).\nentity_icon_size : int, optional\n    Size of entity icons in the animation (default is 24).\ntext_size : int, optional\n    Size of text labels in the animation (default is 24).\nresource_icon_size : int, optional\n    Size of resource icons in the animation (default is 24).\ngap_between_entities : int, optional\n    Horizontal spacing between entities in pixels (default is 10).\ngap_between_queue_rows : int, optional\n    Vertical spacing between rows in pixels (default is 30).\ngap_between_resource_rows : int, optional\n    Vertical spacing between rows in pixels (default is 30).\ngap_between_resources : int, optional\n    Horizontal spacing between resources in pixels (default is 10).\nresource_opacity : float, optional\n    Opacity of resource icons (default is 0.8).\ncustom_resource_icon : str, optional\n    Custom icon to use for resources (default is None).\noverride_x_max : int, optional\n    Override the maximum x-coordinate of the plot (default is None).\noverride_y_max : int, optional\n    Override the maximum y-coordinate of the plot (default is None).\ntime_display_units : str, optional\n    Format for displaying time on the animation timeline. This affects how simulation time is\n    converted into human-readable dates or clock formats. If `None` (default), the raw simulation\n    time is used.\n\n    Predefined options:\n    - 'dhms' : Day Month Year + HH:MM:SS (e.g., \"06 June 2025\n14:23:45”) - ‘dhms_ampm’ : Same as ‘dhms’, but in 12-hour format with AM/PM (e.g., “06 June 2025 02:23:45 PM”) - ‘dhm’ : Day Month Year + HH:MM (e.g., “06 June 2025 14:23”) - ‘dhm_ampm’ : 12-hour format with AM/PM (e.g., “06 June 2025 02:23 PM”) - ‘dh’ : Day Month Year + HH (e.g., “06 June 2025 14”) - ‘dh_ampm’ : 12-hour format with AM/PM (e.g., “06 June 2025 02 PM”) - ‘d’ : Full weekday and date (e.g., “Friday 06 June 2025”) - ‘m’ : Month and year (e.g., “June 2025”) - ‘y’ : Year only (e.g., “2025”) - ‘day_clock’ or ‘simulation_day_clock’: Show simulation-relative day and time (e.g., “Simulation Day 3 14:15”) - ‘day_clock_ampm’ or ‘simulation_day_clock_ampm’: Same as above, but time is shown in 12-hour clock with AM/PM (e.g., “Simulation Day 3 02:15 PM”)\n    Alternatively, you can supply a custom [strftime](https://strftime.org/) format string\n    (e.g., '%Y-%m-%d %H') to control the display manually.\nsetup_mode : bool, optional\n    If True, display grid and tick marks for initial setup (default is False).\nframe_duration : int, optional\n    Duration of each frame in milliseconds (default is 400).\nframe_transition_duration : int, optional\n    Duration of transition between frames in milliseconds (default is 600).\ndebug_mode : bool, optional\n    If True, print debug information during processing (default is False).\ncustom_entity_icon_list: list, optional\n    If given, overrides the default list of emojis used to represent entities",
    "crumbs": [
      "vidigi Function Reference",
      "All-In-One Animation Functions",
      "animation.animate_activity_log"
    ]
  },
  {
    "objectID": "reference/animation.animate_activity_log.html#returns",
    "href": "reference/animation.animate_activity_log.html#returns",
    "title": "animation.animate_activity_log",
    "section": "",
    "text": "plotly.graph_objs._figure.Figure\n    An animated Plotly figure object representing the patient flow.",
    "crumbs": [
      "vidigi Function Reference",
      "All-In-One Animation Functions",
      "animation.animate_activity_log"
    ]
  },
  {
    "objectID": "reference/animation.animate_activity_log.html#notes",
    "href": "reference/animation.animate_activity_log.html#notes",
    "title": "animation.animate_activity_log",
    "section": "",
    "text": "- This function uses helper functions: reshape_for_animations, generate_animation_df, and generate_animation.\n- The animation supports customization of icon sizes, resource representation, and animation speed.\n- Time can be displayed as actual dates or as model time units.\n- A background image can be added to provide context for the patient flow.\n- The function handles both queuing and resource use events.",
    "crumbs": [
      "vidigi Function Reference",
      "All-In-One Animation Functions",
      "animation.animate_activity_log"
    ]
  },
  {
    "objectID": "reference/animation.animate_activity_log.html#examples",
    "href": "reference/animation.animate_activity_log.html#examples",
    "title": "animation.animate_activity_log",
    "section": "",
    "text": "&gt;&gt;&gt; animation = animate_activity_log(event_log, event_positions, scenario,\n...                                  time_display_units='dhm',\n...                                  add_background_image='path/to/image.png')\n&gt;&gt;&gt; animation.show()",
    "crumbs": [
      "vidigi Function Reference",
      "All-In-One Animation Functions",
      "animation.animate_activity_log"
    ]
  },
  {
    "objectID": "reference/ciw.event_log_from_ciw_recs.html",
    "href": "reference/ciw.event_log_from_ciw_recs.html",
    "title": "ciw.event_log_from_ciw_recs",
    "section": "",
    "text": "ciw.event_log_from_ciw_recs(ciw_recs_obj, node_name_list)\nGiven the ciw recs object, return a dataframe in the format expected by the vidigi functions - reshape_for_animation OR - animate_activity_log\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nciw_recs_obj\n\nThe output of the .get_all_records() method run on the ciw simulation object. This is a list of named tuples. See https://ciw.readthedocs.io/en/latest/Tutorial/GettingStarted/part_3.html and https://ciw.readthedocs.io/en/latest/Reference/results.html for more details.\nrequired\n\n\nnode_name_list\n\nUser-defined list of strings where each string relates to the resource or activity that will take place at that ciw node\nrequired\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\npd.DataFrame\n\n\n\n\n\n\n\nGiven the ciw recs object, if we know the nodes and what they relate to, we can build up a picture the arrival date for the first tuple for a given user ID is the arrival\nThen, for each node: - the arrival date for a given node is when they start queueing - the service start date is when they stop queueing - the service start date is when they begin using the resource - the service end date is when the resource use ends - the server ID is the equivalent of a simpy resource use ID\nA more complex multi-node example can be found in https://github.com/Bergam0t/ciw-example-animation in the files - ciw_model.py - vidigi_experiments.py",
    "crumbs": [
      "vidigi Function Reference",
      "ciw Utility Functions",
      "ciw.event_log_from_ciw_recs"
    ]
  },
  {
    "objectID": "reference/ciw.event_log_from_ciw_recs.html#parameters",
    "href": "reference/ciw.event_log_from_ciw_recs.html#parameters",
    "title": "ciw.event_log_from_ciw_recs",
    "section": "",
    "text": "Name\nType\nDescription\nDefault\n\n\n\n\nciw_recs_obj\n\nThe output of the .get_all_records() method run on the ciw simulation object. This is a list of named tuples. See https://ciw.readthedocs.io/en/latest/Tutorial/GettingStarted/part_3.html and https://ciw.readthedocs.io/en/latest/Reference/results.html for more details.\nrequired\n\n\nnode_name_list\n\nUser-defined list of strings where each string relates to the resource or activity that will take place at that ciw node\nrequired",
    "crumbs": [
      "vidigi Function Reference",
      "ciw Utility Functions",
      "ciw.event_log_from_ciw_recs"
    ]
  },
  {
    "objectID": "reference/ciw.event_log_from_ciw_recs.html#returns",
    "href": "reference/ciw.event_log_from_ciw_recs.html#returns",
    "title": "ciw.event_log_from_ciw_recs",
    "section": "",
    "text": "Name\nType\nDescription\n\n\n\n\n\npd.DataFrame",
    "crumbs": [
      "vidigi Function Reference",
      "ciw Utility Functions",
      "ciw.event_log_from_ciw_recs"
    ]
  },
  {
    "objectID": "reference/ciw.event_log_from_ciw_recs.html#notes",
    "href": "reference/ciw.event_log_from_ciw_recs.html#notes",
    "title": "ciw.event_log_from_ciw_recs",
    "section": "",
    "text": "Given the ciw recs object, if we know the nodes and what they relate to, we can build up a picture the arrival date for the first tuple for a given user ID is the arrival\nThen, for each node: - the arrival date for a given node is when they start queueing - the service start date is when they stop queueing - the service start date is when they begin using the resource - the service end date is when the resource use ends - the server ID is the equivalent of a simpy resource use ID\nA more complex multi-node example can be found in https://github.com/Bergam0t/ciw-example-animation in the files - ciw_model.py - vidigi_experiments.py",
    "crumbs": [
      "vidigi Function Reference",
      "ciw Utility Functions",
      "ciw.event_log_from_ciw_recs"
    ]
  },
  {
    "objectID": "reference/logging.EventLogger.html",
    "href": "reference/logging.EventLogger.html",
    "title": "logging.EventLogger",
    "section": "",
    "text": "logging.EventLogger(self, event_model=BaseEvent, env=None, run_number=None)\n\n\n\n\n\nName\nDescription\n\n\n\n\nget_events_by_entity\nReturn all events associated with a specific entity_id.\n\n\nget_events_by_event_name\nReturn all events of a specific event_type.\n\n\nget_events_by_event_type\nReturn all events of a specific event_type.\n\n\nget_events_by_run\nReturn all events associated with a specific entity_id.\n\n\nlog_arrival\nHelper to log an arrival event with the correct event_type and event fields.\n\n\nlog_departure\nHelper to log a departure event with the correct event_type and event fields.\n\n\nlog_queue\nLog a queue event. The ‘event’ here can be any string describing the queue event.\n\n\nlog_resource_use_end\nLog the end of resource use. Requires resource_id.\n\n\nlog_resource_use_start\nLog the start of resource use. Requires resource_id.\n\n\nplot_entity_timeline\nPlot a timeline of events for a specific entity_id.\n\n\nto_csv\nWrite the log to a CSV file.\n\n\nto_dataframe\nConvert the event log to a pandas DataFrame.\n\n\nto_json\nWrite the event log to a JSON file or file-like buffer.\n\n\nto_json_string\nReturn the event log as a pretty JSON string.\n\n\n\n\n\nlogging.EventLogger.get_events_by_entity(entity_id, as_dataframe=True)\nReturn all events associated with a specific entity_id.\n\n\n\nlogging.EventLogger.get_events_by_event_name(event, as_dataframe=True)\nReturn all events of a specific event_type.\n\n\n\nlogging.EventLogger.get_events_by_event_type(event_type, as_dataframe=True)\nReturn all events of a specific event_type.\n\n\n\nlogging.EventLogger.get_events_by_run(run_number, as_dataframe=True)\nReturn all events associated with a specific entity_id.\n\n\n\nlogging.EventLogger.log_arrival(\n    entity_id,\n    time=None,\n    pathway=None,\n    run_number=None,\n    **extra_fields,\n)\nHelper to log an arrival event with the correct event_type and event fields.\n\n\n\nlogging.EventLogger.log_departure(\n    entity_id,\n    time=None,\n    pathway=None,\n    run_number=None,\n    **extra_fields,\n)\nHelper to log a departure event with the correct event_type and event fields.\n\n\n\nlogging.EventLogger.log_queue(\n    entity_id,\n    event,\n    time=None,\n    pathway=None,\n    run_number=None,\n    **extra_fields,\n)\nLog a queue event. The ‘event’ here can be any string describing the queue event.\n\n\n\nlogging.EventLogger.log_resource_use_end(\n    entity_id,\n    resource_id,\n    time=None,\n    pathway=None,\n    run_number=None,\n    **extra_fields,\n)\nLog the end of resource use. Requires resource_id.\n\n\n\nlogging.EventLogger.log_resource_use_start(\n    entity_id,\n    resource_id,\n    time=None,\n    pathway=None,\n    run_number=None,\n    **extra_fields,\n)\nLog the start of resource use. Requires resource_id.\n\n\n\nlogging.EventLogger.plot_entity_timeline(entity_id)\nPlot a timeline of events for a specific entity_id.\n\n\n\nlogging.EventLogger.to_csv(path_or_buffer)\nWrite the log to a CSV file.\n\n\n\nlogging.EventLogger.to_dataframe()\nConvert the event log to a pandas DataFrame.\n\n\n\nlogging.EventLogger.to_json(path_or_buffer, indent=2)\nWrite the event log to a JSON file or file-like buffer.\n\n\n\nlogging.EventLogger.to_json_string(indent=2)\nReturn the event log as a pretty JSON string.",
    "crumbs": [
      "vidigi Function Reference",
      "Event Logging Utility Functions and Classes",
      "logging.EventLogger"
    ]
  },
  {
    "objectID": "reference/logging.EventLogger.html#methods",
    "href": "reference/logging.EventLogger.html#methods",
    "title": "logging.EventLogger",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nget_events_by_entity\nReturn all events associated with a specific entity_id.\n\n\nget_events_by_event_name\nReturn all events of a specific event_type.\n\n\nget_events_by_event_type\nReturn all events of a specific event_type.\n\n\nget_events_by_run\nReturn all events associated with a specific entity_id.\n\n\nlog_arrival\nHelper to log an arrival event with the correct event_type and event fields.\n\n\nlog_departure\nHelper to log a departure event with the correct event_type and event fields.\n\n\nlog_queue\nLog a queue event. The ‘event’ here can be any string describing the queue event.\n\n\nlog_resource_use_end\nLog the end of resource use. Requires resource_id.\n\n\nlog_resource_use_start\nLog the start of resource use. Requires resource_id.\n\n\nplot_entity_timeline\nPlot a timeline of events for a specific entity_id.\n\n\nto_csv\nWrite the log to a CSV file.\n\n\nto_dataframe\nConvert the event log to a pandas DataFrame.\n\n\nto_json\nWrite the event log to a JSON file or file-like buffer.\n\n\nto_json_string\nReturn the event log as a pretty JSON string.\n\n\n\n\n\nlogging.EventLogger.get_events_by_entity(entity_id, as_dataframe=True)\nReturn all events associated with a specific entity_id.\n\n\n\nlogging.EventLogger.get_events_by_event_name(event, as_dataframe=True)\nReturn all events of a specific event_type.\n\n\n\nlogging.EventLogger.get_events_by_event_type(event_type, as_dataframe=True)\nReturn all events of a specific event_type.\n\n\n\nlogging.EventLogger.get_events_by_run(run_number, as_dataframe=True)\nReturn all events associated with a specific entity_id.\n\n\n\nlogging.EventLogger.log_arrival(\n    entity_id,\n    time=None,\n    pathway=None,\n    run_number=None,\n    **extra_fields,\n)\nHelper to log an arrival event with the correct event_type and event fields.\n\n\n\nlogging.EventLogger.log_departure(\n    entity_id,\n    time=None,\n    pathway=None,\n    run_number=None,\n    **extra_fields,\n)\nHelper to log a departure event with the correct event_type and event fields.\n\n\n\nlogging.EventLogger.log_queue(\n    entity_id,\n    event,\n    time=None,\n    pathway=None,\n    run_number=None,\n    **extra_fields,\n)\nLog a queue event. The ‘event’ here can be any string describing the queue event.\n\n\n\nlogging.EventLogger.log_resource_use_end(\n    entity_id,\n    resource_id,\n    time=None,\n    pathway=None,\n    run_number=None,\n    **extra_fields,\n)\nLog the end of resource use. Requires resource_id.\n\n\n\nlogging.EventLogger.log_resource_use_start(\n    entity_id,\n    resource_id,\n    time=None,\n    pathway=None,\n    run_number=None,\n    **extra_fields,\n)\nLog the start of resource use. Requires resource_id.\n\n\n\nlogging.EventLogger.plot_entity_timeline(entity_id)\nPlot a timeline of events for a specific entity_id.\n\n\n\nlogging.EventLogger.to_csv(path_or_buffer)\nWrite the log to a CSV file.\n\n\n\nlogging.EventLogger.to_dataframe()\nConvert the event log to a pandas DataFrame.\n\n\n\nlogging.EventLogger.to_json(path_or_buffer, indent=2)\nWrite the event log to a JSON file or file-like buffer.\n\n\n\nlogging.EventLogger.to_json_string(indent=2)\nReturn the event log as a pretty JSON string.",
    "crumbs": [
      "vidigi Function Reference",
      "Event Logging Utility Functions and Classes",
      "logging.EventLogger"
    ]
  },
  {
    "objectID": "reference/prep.reshape_for_animations.html",
    "href": "reference/prep.reshape_for_animations.html",
    "title": "prep.reshape_for_animations",
    "section": "",
    "text": "prep.reshape_for_animations(\n    event_log,\n    every_x_time_units=10,\n    limit_duration=10 * 60 * 24,\n    step_snapshot_max=50,\n    time_col_name='time',\n    entity_col_name='entity_id',\n    event_type_col_name='event_type',\n    event_col_name='event',\n    pathway_col_name=None,\n    debug_mode=False,\n)\nReshape event log data for animation purposes.\nThis function processes an event log to create a series of snapshots at regular time intervals, suitable for creating animations of patient flow through a system.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nevent_log\npd.DataFrame\nThe input event log containing entity events and timestamps in the form of a number of time units since the simulation began.\nrequired\n\n\nevery_x_time_units\nint\nThe time interval between snapshots in preferred time units (default is 10).\n10\n\n\nlimit_duration\nint\nThe maximum duration to consider in preferred time units (default is 10 days).\n10 * 60 * 24\n\n\nstep_snapshot_max\nint\nThe maximum number of entities to include in each snapshot for each event (default is 50).\n50\n\n\ntime_col_name\nstr\nName of the column in event_log that contains the timestamp of each event. Timestamps should represent the number of time units since the simulation began.\n\"time\"\n\n\nentity_col_name\nstr\nName of the column in event_log that contains the unique identifier for each entity (e.g., “entity_id”, “entity”, “patient”, “patient_id”, “customer”, “ID”).\n\"entity_id\"\n\n\nevent_type_col_name\nstr\nName of the column in event_log that specifies the category of the event. Supported event types include ‘arrival_departure’, ‘resource_use’, ‘resource_use_end’, and ‘queue’.\n\"event_type\"\n\n\nevent_col_name\nstr\nName of the column in event_log that specifies the actual event that occurred.\n\"event\"\n\n\npathway_col_name\nstr\nName of the column in event_log that identifies the specific pathway or process flow the entity is following. If None, it is assumed that pathway information is not present.\nNone\n\n\ndebug_mode\nbool\nIf True, print debug information during processing (default is False).\nFalse\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nDataFrame\nA reshaped DataFrame containing snapshots of entity positions at regular time intervals, sorted by minute and event.\n\n\n\n\n\n\n\nThe function creates snapshots of entity positions at specified time intervals.\nIt handles entities who are present in the system at each snapshot time.\nEntities are ranked within each event based on their arrival order.\nA maximum number of patients per event can be set to limit the number of entities who will be displayed on screen within any one event type at a time.\nAn ‘exit’ event is added for each entity at the end of their journey.\nThe function uses memory management techniques (del and gc.collect()) to handle large datasets.\n\n\n\n\n\nAdd behavior for when limit_duration is None.\nConsider adding ‘first step’ and ‘last step’ parameters.\nImplement pathway order and precedence columns.\nFix the automatic exit at the end of the simulation run for all entities.",
    "crumbs": [
      "vidigi Function Reference",
      "Step-By-Step Functions",
      "prep.reshape_for_animations"
    ]
  },
  {
    "objectID": "reference/prep.reshape_for_animations.html#parameters",
    "href": "reference/prep.reshape_for_animations.html#parameters",
    "title": "prep.reshape_for_animations",
    "section": "",
    "text": "Name\nType\nDescription\nDefault\n\n\n\n\nevent_log\npd.DataFrame\nThe input event log containing entity events and timestamps in the form of a number of time units since the simulation began.\nrequired\n\n\nevery_x_time_units\nint\nThe time interval between snapshots in preferred time units (default is 10).\n10\n\n\nlimit_duration\nint\nThe maximum duration to consider in preferred time units (default is 10 days).\n10 * 60 * 24\n\n\nstep_snapshot_max\nint\nThe maximum number of entities to include in each snapshot for each event (default is 50).\n50\n\n\ntime_col_name\nstr\nName of the column in event_log that contains the timestamp of each event. Timestamps should represent the number of time units since the simulation began.\n\"time\"\n\n\nentity_col_name\nstr\nName of the column in event_log that contains the unique identifier for each entity (e.g., “entity_id”, “entity”, “patient”, “patient_id”, “customer”, “ID”).\n\"entity_id\"\n\n\nevent_type_col_name\nstr\nName of the column in event_log that specifies the category of the event. Supported event types include ‘arrival_departure’, ‘resource_use’, ‘resource_use_end’, and ‘queue’.\n\"event_type\"\n\n\nevent_col_name\nstr\nName of the column in event_log that specifies the actual event that occurred.\n\"event\"\n\n\npathway_col_name\nstr\nName of the column in event_log that identifies the specific pathway or process flow the entity is following. If None, it is assumed that pathway information is not present.\nNone\n\n\ndebug_mode\nbool\nIf True, print debug information during processing (default is False).\nFalse",
    "crumbs": [
      "vidigi Function Reference",
      "Step-By-Step Functions",
      "prep.reshape_for_animations"
    ]
  },
  {
    "objectID": "reference/prep.reshape_for_animations.html#returns",
    "href": "reference/prep.reshape_for_animations.html#returns",
    "title": "prep.reshape_for_animations",
    "section": "",
    "text": "Name\nType\nDescription\n\n\n\n\n\nDataFrame\nA reshaped DataFrame containing snapshots of entity positions at regular time intervals, sorted by minute and event.",
    "crumbs": [
      "vidigi Function Reference",
      "Step-By-Step Functions",
      "prep.reshape_for_animations"
    ]
  },
  {
    "objectID": "reference/prep.reshape_for_animations.html#notes",
    "href": "reference/prep.reshape_for_animations.html#notes",
    "title": "prep.reshape_for_animations",
    "section": "",
    "text": "The function creates snapshots of entity positions at specified time intervals.\nIt handles entities who are present in the system at each snapshot time.\nEntities are ranked within each event based on their arrival order.\nA maximum number of patients per event can be set to limit the number of entities who will be displayed on screen within any one event type at a time.\nAn ‘exit’ event is added for each entity at the end of their journey.\nThe function uses memory management techniques (del and gc.collect()) to handle large datasets.",
    "crumbs": [
      "vidigi Function Reference",
      "Step-By-Step Functions",
      "prep.reshape_for_animations"
    ]
  },
  {
    "objectID": "reference/prep.reshape_for_animations.html#todo",
    "href": "reference/prep.reshape_for_animations.html#todo",
    "title": "prep.reshape_for_animations",
    "section": "",
    "text": "Add behavior for when limit_duration is None.\nConsider adding ‘first step’ and ‘last step’ parameters.\nImplement pathway order and precedence columns.\nFix the automatic exit at the end of the simulation run for all entities.",
    "crumbs": [
      "vidigi Function Reference",
      "Step-By-Step Functions",
      "prep.reshape_for_animations"
    ]
  },
  {
    "objectID": "reference/resources.VidigiPriorityStore.html",
    "href": "reference/resources.VidigiPriorityStore.html",
    "title": "resources.VidigiPriorityStore",
    "section": "",
    "text": "resources.VidigiPriorityStore(\n    self,\n    env,\n    capacity=float('inf'),\n    num_resources=None,\n)\nAn optimized SimPy priority store that eliminates delays between resource release and acquisition by directly triggering waiting events.\nThis implementation provides the same API as the original VidigiPriorityStore but with immediate resource handoff between processes.\nAI USE DISCLOSURE: This code was generated by Claude 3.7 Sonnet. It has been evaluated and tested by a human.\n\n\n\n\n\nName\nDescription\n\n\n\n\nget\nCreate an event to get an item from the store.\n\n\nget_direct\nGet an item from the store without the context manager.\n\n\npopulate\nPopulate this VidigiPriorityStore with VidigiResource objects.\n\n\nput\nPut an item into the store.\n\n\nrequest\nRequest context manager for getting an item from the store.\n\n\nrequest_direct\nAlias for get_direct() to maintain consistent API.\n\n\nreturn_item\nReturn an item to the store and immediately process any waiting get requests.\n\n\n\n\n\nresources.VidigiPriorityStore.get(priority=0)\nCreate an event to get an item from the store.\nArgs: priority: Lower values indicate higher priority (default: 0)\nReturns: A get event that can be yielded\n\n\n\nresources.VidigiPriorityStore.get_direct(priority=0)\nGet an item from the store without the context manager. Use this if you don’t want to automatically return the item.\nReturns: A get event that can be yielded\n\n\n\nresources.VidigiPriorityStore.populate(num_resources)\nPopulate this VidigiPriorityStore with VidigiResource objects.\nCreates num_resources VidigiResource objects and adds them to this store.\nEach VidigiResource is initialized with a capacity of 1 and a unique ID starting at 1.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nnum_resources\nint\nThe number of VidigiResource objects to create and add to the store.\nrequired\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nNone\n\n\n\n\n\n\n\n\nresources.VidigiPriorityStore.put(item)\nPut an item into the store.\nArgs: item: The item to put in the store\nReturns: A put event that can be yielded\n\n\n\nresources.VidigiPriorityStore.request(priority=0)\nRequest context manager for getting an item from the store. The item is automatically returned when exiting the context.\nArgs: priority: Lower values indicate higher priority (default: 0)\nReturns: A context manager that yields the get event and handles item return\n\n\n\nresources.VidigiPriorityStore.request_direct(priority=0)\nAlias for get_direct() to maintain consistent API.\nReturns: A get event that can be yielded\n\n\n\nresources.VidigiPriorityStore.return_item(item)\nReturn an item to the store and immediately process any waiting get requests.\nThis is the key to eliminating delays - it directly triggers waiting get requests without going through the normal put/get mechanism.\nArgs: item: The item to return to the store",
    "crumbs": [
      "vidigi Function Reference",
      "Simpy Resource Classes",
      "resources.VidigiPriorityStore"
    ]
  },
  {
    "objectID": "reference/resources.VidigiPriorityStore.html#methods",
    "href": "reference/resources.VidigiPriorityStore.html#methods",
    "title": "resources.VidigiPriorityStore",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nget\nCreate an event to get an item from the store.\n\n\nget_direct\nGet an item from the store without the context manager.\n\n\npopulate\nPopulate this VidigiPriorityStore with VidigiResource objects.\n\n\nput\nPut an item into the store.\n\n\nrequest\nRequest context manager for getting an item from the store.\n\n\nrequest_direct\nAlias for get_direct() to maintain consistent API.\n\n\nreturn_item\nReturn an item to the store and immediately process any waiting get requests.\n\n\n\n\n\nresources.VidigiPriorityStore.get(priority=0)\nCreate an event to get an item from the store.\nArgs: priority: Lower values indicate higher priority (default: 0)\nReturns: A get event that can be yielded\n\n\n\nresources.VidigiPriorityStore.get_direct(priority=0)\nGet an item from the store without the context manager. Use this if you don’t want to automatically return the item.\nReturns: A get event that can be yielded\n\n\n\nresources.VidigiPriorityStore.populate(num_resources)\nPopulate this VidigiPriorityStore with VidigiResource objects.\nCreates num_resources VidigiResource objects and adds them to this store.\nEach VidigiResource is initialized with a capacity of 1 and a unique ID starting at 1.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nnum_resources\nint\nThe number of VidigiResource objects to create and add to the store.\nrequired\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nNone\n\n\n\n\n\n\n\n\nresources.VidigiPriorityStore.put(item)\nPut an item into the store.\nArgs: item: The item to put in the store\nReturns: A put event that can be yielded\n\n\n\nresources.VidigiPriorityStore.request(priority=0)\nRequest context manager for getting an item from the store. The item is automatically returned when exiting the context.\nArgs: priority: Lower values indicate higher priority (default: 0)\nReturns: A context manager that yields the get event and handles item return\n\n\n\nresources.VidigiPriorityStore.request_direct(priority=0)\nAlias for get_direct() to maintain consistent API.\nReturns: A get event that can be yielded\n\n\n\nresources.VidigiPriorityStore.return_item(item)\nReturn an item to the store and immediately process any waiting get requests.\nThis is the key to eliminating delays - it directly triggers waiting get requests without going through the normal put/get mechanism.\nArgs: item: The item to return to the store",
    "crumbs": [
      "vidigi Function Reference",
      "Simpy Resource Classes",
      "resources.VidigiPriorityStore"
    ]
  },
  {
    "objectID": "reference/resources.VidigiResource.html",
    "href": "reference/resources.VidigiResource.html",
    "title": "resources.VidigiResource",
    "section": "",
    "text": "resources.VidigiResource(self, env, capacity, id_attribute=None)\nA custom resource class that extends simpy.Resource with an additional ID attribute.\nThis class allows for more detailed tracking and management of resources in a simulation by adding an ID attribute to each resource instance.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nenv\nsimpy.Environment\nThe SimPy environment in which this resource exists.\nrequired\n\n\ncapacity\nint\nThe capacity of the resource (how many units can be in use simultaneously).\nrequired\n\n\nid_attribute\nany\nAn identifier for the resource (default is None).\nNone\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nid_attribute\nany\nAn identifier for the resource, which can be used for custom tracking or logic.\n\n\n\n\n\n\nThis class inherits from simpy.Resource and overrides the request and release methods to allow for custom handling of the id_attribute. The actual implementation of ID assignment or reset logic should be added by the user as needed.\n\n\n\nenv = simpy.Environment()\ncustom_resource = VidigiResource(env, capacity=1, id_attribute=\"Resource_1\")\ndef process(env, resource):\n    with resource.request() as req:\n        yield req\n        print(f\"Using resource with ID: {resource.id_attribute}\")\n        yield env.timeout(1)\nenv.process(process(env, custom_resource))\nenv.run()\nUsing resource with ID: Resource_1\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nrelease\nRelease the resource.\n\n\nrequest\nRequest the resource.\n\n\n\n\n\nresources.VidigiResource.release(*args, **kwargs)\nRelease the resource.\nThis method can be customized to handle the ID attribute when a release is made. Currently, it simply calls the parent class’s release method.\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nNone\n\n\n\n\n\n\n\n\nresources.VidigiResource.request(*args, **kwargs)\nRequest the resource.\nThis method can be customized to handle the ID attribute when a request is made. Currently, it simply calls the parent class’s request method.\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nsimpy.events.Request\nA SimPy request event.",
    "crumbs": [
      "vidigi Function Reference",
      "Simpy Resource Classes",
      "resources.VidigiResource"
    ]
  },
  {
    "objectID": "reference/resources.VidigiResource.html#parameters",
    "href": "reference/resources.VidigiResource.html#parameters",
    "title": "resources.VidigiResource",
    "section": "",
    "text": "Name\nType\nDescription\nDefault\n\n\n\n\nenv\nsimpy.Environment\nThe SimPy environment in which this resource exists.\nrequired\n\n\ncapacity\nint\nThe capacity of the resource (how many units can be in use simultaneously).\nrequired\n\n\nid_attribute\nany\nAn identifier for the resource (default is None).\nNone",
    "crumbs": [
      "vidigi Function Reference",
      "Simpy Resource Classes",
      "resources.VidigiResource"
    ]
  },
  {
    "objectID": "reference/resources.VidigiResource.html#attributes",
    "href": "reference/resources.VidigiResource.html#attributes",
    "title": "resources.VidigiResource",
    "section": "",
    "text": "Name\nType\nDescription\n\n\n\n\nid_attribute\nany\nAn identifier for the resource, which can be used for custom tracking or logic.",
    "crumbs": [
      "vidigi Function Reference",
      "Simpy Resource Classes",
      "resources.VidigiResource"
    ]
  },
  {
    "objectID": "reference/resources.VidigiResource.html#notes",
    "href": "reference/resources.VidigiResource.html#notes",
    "title": "resources.VidigiResource",
    "section": "",
    "text": "This class inherits from simpy.Resource and overrides the request and release methods to allow for custom handling of the id_attribute. The actual implementation of ID assignment or reset logic should be added by the user as needed.",
    "crumbs": [
      "vidigi Function Reference",
      "Simpy Resource Classes",
      "resources.VidigiResource"
    ]
  },
  {
    "objectID": "reference/resources.VidigiResource.html#examples",
    "href": "reference/resources.VidigiResource.html#examples",
    "title": "resources.VidigiResource",
    "section": "",
    "text": "env = simpy.Environment()\ncustom_resource = VidigiResource(env, capacity=1, id_attribute=\"Resource_1\")\ndef process(env, resource):\n    with resource.request() as req:\n        yield req\n        print(f\"Using resource with ID: {resource.id_attribute}\")\n        yield env.timeout(1)\nenv.process(process(env, custom_resource))\nenv.run()\nUsing resource with ID: Resource_1",
    "crumbs": [
      "vidigi Function Reference",
      "Simpy Resource Classes",
      "resources.VidigiResource"
    ]
  },
  {
    "objectID": "reference/resources.VidigiResource.html#methods",
    "href": "reference/resources.VidigiResource.html#methods",
    "title": "resources.VidigiResource",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nrelease\nRelease the resource.\n\n\nrequest\nRequest the resource.\n\n\n\n\n\nresources.VidigiResource.release(*args, **kwargs)\nRelease the resource.\nThis method can be customized to handle the ID attribute when a release is made. Currently, it simply calls the parent class’s release method.\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nNone\n\n\n\n\n\n\n\n\nresources.VidigiResource.request(*args, **kwargs)\nRequest the resource.\nThis method can be customized to handle the ID attribute when a request is made. Currently, it simply calls the parent class’s request method.\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nsimpy.events.Request\nA SimPy request event.",
    "crumbs": [
      "vidigi Function Reference",
      "Simpy Resource Classes",
      "resources.VidigiResource"
    ]
  },
  {
    "objectID": "reference/utils.CustomResource.html",
    "href": "reference/utils.CustomResource.html",
    "title": "utils.CustomResource",
    "section": "",
    "text": "utils.CustomResource(self, env, capacity, id_attribute=None)\nA custom resource class that extends simpy.Resource with an additional ID attribute.\nThis class allows for more detailed tracking and management of resources in a simulation by adding an ID attribute to each resource instance.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nenv\nsimpy.Environment\nThe SimPy environment in which this resource exists.\nrequired\n\n\ncapacity\nint\nThe capacity of the resource (how many units can be in use simultaneously).\nrequired\n\n\nid_attribute\nany\nAn identifier for the resource (default is None).\nNone\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nid_attribute\nany\nAn identifier for the resource, which can be used for custom tracking or logic.\n\n\n\n\n\n\nThis class inherits from simpy.Resource and overrides the request and release methods to allow for custom handling of the id_attribute. The actual implementation of ID assignment or reset logic should be added by the user as needed.\n\n\n\nenv = simpy.Environment()\ncustom_resource = CustomResource(env, capacity=1, id_attribute=\"Resource_1\")\ndef process(env, resource):\n    with resource.request() as req:\n        yield req\n        print(f\"Using resource with ID: {resource.id_attribute}\")\n        yield env.timeout(1)\nenv.process(process(env, custom_resource))\nenv.run()\nUsing resource with ID: Resource_1\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nrelease\nRelease the resource.\n\n\nrequest\nRequest the resource.\n\n\n\n\n\nutils.CustomResource.release(*args, **kwargs)\nRelease the resource.\nThis method can be customized to handle the ID attribute when a release is made. Currently, it simply calls the parent class’s release method.\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nNone\n\n\n\n\n\n\n\n\nutils.CustomResource.request(*args, **kwargs)\nRequest the resource.\nThis method can be customized to handle the ID attribute when a request is made. Currently, it simply calls the parent class’s request method.\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nsimpy.events.Request\nA SimPy request event."
  },
  {
    "objectID": "reference/utils.CustomResource.html#parameters",
    "href": "reference/utils.CustomResource.html#parameters",
    "title": "utils.CustomResource",
    "section": "",
    "text": "Name\nType\nDescription\nDefault\n\n\n\n\nenv\nsimpy.Environment\nThe SimPy environment in which this resource exists.\nrequired\n\n\ncapacity\nint\nThe capacity of the resource (how many units can be in use simultaneously).\nrequired\n\n\nid_attribute\nany\nAn identifier for the resource (default is None).\nNone"
  },
  {
    "objectID": "reference/utils.CustomResource.html#attributes",
    "href": "reference/utils.CustomResource.html#attributes",
    "title": "utils.CustomResource",
    "section": "",
    "text": "Name\nType\nDescription\n\n\n\n\nid_attribute\nany\nAn identifier for the resource, which can be used for custom tracking or logic."
  },
  {
    "objectID": "reference/utils.CustomResource.html#notes",
    "href": "reference/utils.CustomResource.html#notes",
    "title": "utils.CustomResource",
    "section": "",
    "text": "This class inherits from simpy.Resource and overrides the request and release methods to allow for custom handling of the id_attribute. The actual implementation of ID assignment or reset logic should be added by the user as needed."
  },
  {
    "objectID": "reference/utils.CustomResource.html#examples",
    "href": "reference/utils.CustomResource.html#examples",
    "title": "utils.CustomResource",
    "section": "",
    "text": "env = simpy.Environment()\ncustom_resource = CustomResource(env, capacity=1, id_attribute=\"Resource_1\")\ndef process(env, resource):\n    with resource.request() as req:\n        yield req\n        print(f\"Using resource with ID: {resource.id_attribute}\")\n        yield env.timeout(1)\nenv.process(process(env, custom_resource))\nenv.run()\nUsing resource with ID: Resource_1"
  },
  {
    "objectID": "reference/utils.CustomResource.html#methods",
    "href": "reference/utils.CustomResource.html#methods",
    "title": "utils.CustomResource",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nrelease\nRelease the resource.\n\n\nrequest\nRequest the resource.\n\n\n\n\n\nutils.CustomResource.release(*args, **kwargs)\nRelease the resource.\nThis method can be customized to handle the ID attribute when a release is made. Currently, it simply calls the parent class’s release method.\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nNone\n\n\n\n\n\n\n\n\nutils.CustomResource.request(*args, **kwargs)\nRequest the resource.\nThis method can be customized to handle the ID attribute when a request is made. Currently, it simply calls the parent class’s request method.\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nsimpy.events.Request\nA SimPy request event."
  },
  {
    "objectID": "reference/utils.event_log_from_ciw_recs.html",
    "href": "reference/utils.event_log_from_ciw_recs.html",
    "title": "utils.event_log_from_ciw_recs",
    "section": "",
    "text": "utils.event_log_from_ciw_recs(ciw_recs_obj, node_name_list)\nGiven the ciw recs object, return a dataframe in the format expected by the vidigi functions - reshape_for_animation OR - animate_activity_log\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nciw_recs_obj\n\nThe output of the .get_all_records() method run on the ciw simulation object. This is a list of named tuples. See https://ciw.readthedocs.io/en/latest/Tutorial/GettingStarted/part_3.html and https://ciw.readthedocs.io/en/latest/Reference/results.html for more details.\nrequired\n\n\nnode_name_list\n\nUser-defined list of strings where each string relates to the resource or activity that will take place at that ciw node\nrequired\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\npd.DataFrame\n\n\n\n\n\n\n\nGiven the ciw recs object, if we know the nodes and what they relate to, we can build up a picture the arrival date for the first tuple for a given user ID is the arrival\nThen, for each node: - the arrival date for a given node is when they start queueing - the service start date is when they stop queueing - the service start date is when they begin using the resource - the service end date is when the resource use ends - the server ID is the equivalent of a simpy resource use ID\nA more complex multi-node example can be found in https://github.com/Bergam0t/ciw-example-animation in the files - ciw_model.py - vidigi_experiments.py"
  },
  {
    "objectID": "reference/utils.event_log_from_ciw_recs.html#parameters",
    "href": "reference/utils.event_log_from_ciw_recs.html#parameters",
    "title": "utils.event_log_from_ciw_recs",
    "section": "",
    "text": "Name\nType\nDescription\nDefault\n\n\n\n\nciw_recs_obj\n\nThe output of the .get_all_records() method run on the ciw simulation object. This is a list of named tuples. See https://ciw.readthedocs.io/en/latest/Tutorial/GettingStarted/part_3.html and https://ciw.readthedocs.io/en/latest/Reference/results.html for more details.\nrequired\n\n\nnode_name_list\n\nUser-defined list of strings where each string relates to the resource or activity that will take place at that ciw node\nrequired"
  },
  {
    "objectID": "reference/utils.event_log_from_ciw_recs.html#returns",
    "href": "reference/utils.event_log_from_ciw_recs.html#returns",
    "title": "utils.event_log_from_ciw_recs",
    "section": "",
    "text": "Name\nType\nDescription\n\n\n\n\n\npd.DataFrame"
  },
  {
    "objectID": "reference/utils.event_log_from_ciw_recs.html#notes",
    "href": "reference/utils.event_log_from_ciw_recs.html#notes",
    "title": "utils.event_log_from_ciw_recs",
    "section": "",
    "text": "Given the ciw recs object, if we know the nodes and what they relate to, we can build up a picture the arrival date for the first tuple for a given user ID is the arrival\nThen, for each node: - the arrival date for a given node is when they start queueing - the service start date is when they stop queueing - the service start date is when they begin using the resource - the service end date is when the resource use ends - the server ID is the equivalent of a simpy resource use ID\nA more complex multi-node example can be found in https://github.com/Bergam0t/ciw-example-animation in the files - ciw_model.py - vidigi_experiments.py"
  },
  {
    "objectID": "reference/utils.streamlit_play_all.html",
    "href": "reference/utils.streamlit_play_all.html",
    "title": "utils.streamlit_play_all",
    "section": "",
    "text": "utils.streamlit_play_all\nutils.streamlit_play_all()",
    "crumbs": [
      "vidigi Function Reference",
      "Streamlit Utility Functions",
      "utils.streamlit_play_all"
    ]
  },
  {
    "objectID": "reference/utils.VidigiPriorityStoreLegacy.html",
    "href": "reference/utils.VidigiPriorityStoreLegacy.html",
    "title": "utils.VidigiPriorityStoreLegacy",
    "section": "",
    "text": "utils.VidigiPriorityStoreLegacy()\nA SimPy store that processes requests with priority.\nThis class extends the SimPy Store to include a priority queue for handling requests. Requests are processed based on their priority, submission time, and preemption flag.\nAttributes: GetQueue (class): A reference to the sorted queue implementation used for handling prioritized requests. get (class): A reference to the PriorityGet class, which handles the creation of prioritized requests.\n\n\nCredit to arabinelli # https://stackoverflow.com/questions/58603000/how-do-i-make-a-priority-get-request-from-resource-store"
  },
  {
    "objectID": "reference/utils.VidigiPriorityStoreLegacy.html#notes",
    "href": "reference/utils.VidigiPriorityStoreLegacy.html#notes",
    "title": "utils.VidigiPriorityStoreLegacy",
    "section": "",
    "text": "Credit to arabinelli # https://stackoverflow.com/questions/58603000/how-do-i-make-a-priority-get-request-from-resource-store"
  },
  {
    "objectID": "vidigi_docs/adding_vidigi_to_a_simple_simpy_model_hsma_structure.html",
    "href": "vidigi_docs/adding_vidigi_to_a_simple_simpy_model_hsma_structure.html",
    "title": "Adding Vidigi to a Simple simpy Model (HSMA Structure) - vidigi 0.0.5 and above",
    "section": "",
    "text": "On the Health Service Modelling Associates (HSMA) course we teach a particular way of writing your simpy models. More details of the approach we take can be found in our Little Book of DES.\nHowever, the core concepts of adding vidigi to your models will be the same across different models - so this example will hopefully be helpful regardless of the way you structure your simpy models.",
    "crumbs": [
      "Walkthroughs",
      "Adding Vidigi to a Simple simpy Model (HSMA Structure) - vidigi 0.0.5 and above"
    ]
  },
  {
    "objectID": "vidigi_docs/adding_vidigi_to_a_simple_simpy_model_hsma_structure.html#vidigis-requirements",
    "href": "vidigi_docs/adding_vidigi_to_a_simple_simpy_model_hsma_structure.html#vidigis-requirements",
    "title": "Adding Vidigi to a Simple simpy Model (HSMA Structure) - vidigi 0.0.5 and above",
    "section": "Vidigi’s requirements",
    "text": "Vidigi’s requirements\nThe key input vidigi requires an event log of the times that each entity in your system reached key milestones like arriving in the system, beginning to queue for a resource, being seen by a resource, and exiting the system.\nWe also need to tell vidigi what kind of activity is happening at each point:\n\narrive/depart\nqueue\nresource_use\n\nWe also provide vidigi with a table of coordinates that will help it to lay out our entities and resources, and determine their path from the entrance, to the exit, and to some extent their movement between stages.\nVidigi then takes this event log and the layout table and will process them into a table that tracks the position of every entity in the system at specified time intervals.",
    "crumbs": [
      "Walkthroughs",
      "Adding Vidigi to a Simple simpy Model (HSMA Structure) - vidigi 0.0.5 and above"
    ]
  },
  {
    "objectID": "vidigi_docs/adding_vidigi_to_a_simple_simpy_model_hsma_structure.html#hsma-model-structure",
    "href": "vidigi_docs/adding_vidigi_to_a_simple_simpy_model_hsma_structure.html#hsma-model-structure",
    "title": "Adding Vidigi to a Simple simpy Model (HSMA Structure) - vidigi 0.0.5 and above",
    "section": "HSMA Model Structure",
    "text": "HSMA Model Structure\nIn HSMA, we use four primary classes to structure our models:\n\ng, which stores model parameters (like the number of resources of a given type and distribution parameters) and simulation parameters (like the number of replications to run and the )\nEntity, which may be named something more descriptive like ‘Patient’ or ‘Customer’. You may also have more than one entity class. Each entity will store information such as its ID, and will be passed into the model to work through the pathway.\nModel, which will generate entities, simulate the pathway the entity takes through the system, and contain a way to run a single replication of the model\nTrial, which allows us to run the simulation multiple times, collect results from all of these, and get an indication of average performance and performance variation across our different model runs",
    "crumbs": [
      "Walkthroughs",
      "Adding Vidigi to a Simple simpy Model (HSMA Structure) - vidigi 0.0.5 and above"
    ]
  },
  {
    "objectID": "vidigi_docs/adding_vidigi_to_a_simple_simpy_model_hsma_structure.html#a-simple-model",
    "href": "vidigi_docs/adding_vidigi_to_a_simple_simpy_model_hsma_structure.html#a-simple-model",
    "title": "Adding Vidigi to a Simple simpy Model (HSMA Structure) - vidigi 0.0.5 and above",
    "section": "A Simple Model",
    "text": "A Simple Model\nWe’re going to start off with a very simple model of a walk-in clinic pathway.\nIn this clinic, patients arrive and are seen in the order they arrive by one of several available nurses. All nurses have the same skillset, so the queue is a simple first-in-first-out (FIFO). There is some variability in the arrival time of patients, as well as variability in how long it takes for each patient to be seen.\n\nthe g Class\nIn our g class, we set up parameters that will be used throughout.\n\nclass g:\n    random_number_set = 42 # Control\n    ial seeds of each stream of pseudorandom numbers used\n\n    n_cubicles = 3 # The number of treatment cubicles\n    trauma_treat_mean = 40 # Mean of the trauma cubicle treatment distribution (Lognormal)\n    trauma_treat_var = 5 # Variance of the trauma cubicle treatment distribution (Lognormal)\n\n    arrival_rate = 5 # mean of the exponential distribution for sampling the inter-arrival time of entities\n\n\n    sim_duration = 600 # The number of time units the simulation will run for\n    number_of_runs = 100 # The number of times the simulation will be run with different random number streams\n\n\n\nthe Patient Class\nOur Patient class represents a single individual.\nThe attributes in this class are used to track various metrics that will be used for determining how well our particular scenario has performed - think of it like a person holding a clipboard that is having various times and figures recorded on it as they move through the system.\n\nclass Patient:\n    def __init__(self, p_id):\n        self.identifier = p_id\n        self.arrival = -np.inf\n        self.wait_treat = -np.inf\n        self.total_time = -np.inf\n        self.treat_duration = -np.inf\n\n\n\nthe Model Class\nOur model class is more complex.\n:::\n\nthe init method\nFirst, we set up a series of attributes\n\n    def __init__(self, run_number):\n        # Create a SimPy environment in which everything will live\n        self.env = simpy.Environment()\n\n        # Create a patient counter (which we'll use as a patient ID)\n        self.patient_counter = 0\n\n        self.patients = []\n\n        # Create our resources\n        self.init_resources()\n\n        # Store the passed in run number\n        self.run_number = run_number\n\n        # Create a new Pandas DataFrame that will store some results against\n        # the patient ID (which we'll use as the index).\n        self.results_df = pd.DataFrame()\n        self.results_df[\"Patient ID\"] = [1]\n        self.results_df[\"Queue Time Cubicle\"] = [0.0]\n        self.results_df[\"Time with Nurse\"] = [0.0]\n        self.results_df.set_index(\"Patient ID\", inplace=True)\n\n        # Create an attribute to store the mean queuing times across this run of\n        # the model\n        self.mean_q_time_cubicle = 0\n\n        self.patient_inter_arrival_dist = Exponential(mean = g.arrival_rate,\n                                                      random_seed = self.run_number*g.random_number_set)\n        self.treat_dist = Lognormal(mean = g.trauma_treat_mean,\n                                    stdev = g.trauma_treat_var,\n                                    random_seed = self.run_number*g.random_number_set)\n\n\n\nthe init_resources method\n\n    def init_resources(self):\n        '''\n        Init the number of resources\n\n        Resource list:\n            1. Nurses/treatment bays (same thing in this model)\n\n        '''\n        self.treatment_cubicles = simpy.Resource(self.env, capacity=g.n_cubicles)\n\n\n\nthe generator_patient_arrivals method\n\n    def generator_patient_arrivals(self):\n        # We use an infinite loop here to keep doing this indefinitely whilst\n        # the simulation runs\n        while True:\n            # Increment the patient counter by 1 (this means our first patient\n            # will have an ID of 1)\n            self.patient_counter += 1\n\n            # Create a new patient - an instance of the Patient Class we\n            # defined above.  Remember, we pass in the ID when creating a\n            # patient - so here we pass the patient counter to use as the ID.\n            p = Patient(self.patient_counter)\n\n            # Store patient in list for later easy access\n            self.patients.append(p)\n\n            # Tell SimPy to start up the attend_clinic generator function with\n            # this patient (the generator function that will model the\n            # patient's journey through the system)\n            self.env.process(self.attend_clinic(p))\n\n            # Randomly sample the time to the next patient arriving.  Here, we\n            # sample from an exponential distribution (common for inter-arrival\n            # times), and pass in a lambda value of 1 / mean.  The mean\n            # inter-arrival time is stored in the g class.\n            sampled_inter = self.patient_inter_arrival_dist.sample()\n\n            # Freeze this instance of this function in place until the\n            # inter-arrival time we sampled above has elapsed.  Note - time in\n            # SimPy progresses in \"Time Units\", which can represent anything\n            # you like (just make sure you're consistent within the model)\n            yield self.env.timeout(sampled_inter)\n\n\n\nthe attend_clinic function\n\n    def attend_clinic(self, patient):\n        patient.arrival = self.env.now\n\n        # request examination resource\n        start_wait = self.env.now\n\n        with self.treatment_cubicles.request() as req:\n            # Seize a treatment resource when available\n            yield req\n\n            # record the waiting time for registration\n            patient.wait_treat = self.env.now - start_wait\n\n            # sample treatment duration\n            patient.treat_duration = self.treat_dist.sample()\n            yield self.env.timeout(patient.treat_duration)\n\n        # total time in system\n        patient.total_time = self.env.now - patient.arrival\n\n\n\nthe calculate_run_results function\n\n    def calculate_run_results(self):\n        # Take the mean of the queuing times across patients in this run of the\n        # model.\n        self.mean_q_time_cubicle = self.results_df[\"Queue Time Cubicle\"].mean()\n\n\n\nthe run function\n\n    def run(self):\n        # Start up our DES entity generators that create new patients.  We've\n        # only got one in this model, but we'd need to do this for each one if\n        # we had multiple generators.\n        self.env.process(self.generator_patient_arrivals())\n\n        # Run the model for the duration specified in g class\n        self.env.run(until=g.sim_duration)\n\n        # Now the simulation run has finished, call the method that calculates\n        # run results\n        self.calculate_run_results()\n\n\n\n\nthe Trial Class\n\nthe init method\n\ndef  __init__(self):\n    self.df_trial_results = pd.DataFrame()\n    self.df_trial_results[\"Run Number\"] = [0]\n    self.df_trial_results[\"Arrivals\"] = [0]\n    self.df_trial_results[\"Mean Queue Time Cubicle\"] = [0.0]\n    self.df_trial_results.set_index(\"Run Number\", inplace=True)\n\n\n\nThe run_trial method\nRun the simulation for the number of runs specified in g class.\nor each run, we create a new instance of the Model class and call its run method, which sets everything else in motion.\nOnce the run has completed, we grab out the stored run results (just mean queuing time here) and store it against the run number in the trial results dataframe.\n\n    def run_trial(self):\n        print(f\"{g.n_cubicles} nurses\")\n        print(\"\") ## Print a blank line\n\n        for run in range(1, g.number_of_runs+1):\n            random.seed(run)\n\n            my_model = Model(run)\n            my_model.run()\n\n            self.df_trial_results.loc[run] = [my_model.mean_q_time_cubicle]\n\n        return self.df_trial_results",
    "crumbs": [
      "Walkthroughs",
      "Adding Vidigi to a Simple simpy Model (HSMA Structure) - vidigi 0.0.5 and above"
    ]
  },
  {
    "objectID": "vidigi_docs/adding_vidigi_to_a_simple_simpy_model_hsma_structure.html#making-changes-for-vidigi",
    "href": "vidigi_docs/adding_vidigi_to_a_simple_simpy_model_hsma_structure.html#making-changes-for-vidigi",
    "title": "Adding Vidigi to a Simple simpy Model (HSMA Structure) - vidigi 0.0.5 and above",
    "section": "Making Changes for Vidigi",
    "text": "Making Changes for Vidigi\n\nimports\n\n\n\nOriginal\n\nimport random\nimport numpy as np\nimport pandas as pd\nimport simpy\nfrom sim_tools.distributions import Exponential, Lognormal\n\n\n\n\n\n\nWith Vidigi Modifications\n\nimport random\nimport numpy as np\nimport pandas as pd\nimport simpy\nfrom sim_tools.distributions import Exponential, Lognormal\nfrom vidigi.resources import VidigiStore \nfrom vidigi.logging import EventLogger \nfrom vidigi.animation import animate_activity_log \n\n\n\n\n\n\nthe g Class\nOur g class is unchanged.\n\n\nthe Entity Class\nOur entity class - in this case, Patient - is unchanged.\n\n\nthe Model Class\n\nThe init method\nTo our init method for the Model class, we add an instance of the vidigi EventLogger class that will help us to generate our event logs.\nWe will also remove the various bits of code that will track different metrics - the vidigi EventLogger class can help us with that later on too, and it’s more efficient to calculate these things after running our simulation, and keeps this logic more separate from the simulation logic, making our code easier to modify and maintain.\n\n\n\nOriginal\n\ndef __init__(self, run_number):\n    # Create a SimPy environment in which everything will live\n    self.env = simpy.Environment()\n\n    # Create a patient counter (which we'll use as a patient ID)\n    self.patient_counter = 0\n\n    # Create an empty list to store patient objects in\n    self.patients = []\n\n    # Create our resources\n    self.init_resources()\n\n    # Store the passed in run number\n    self.run_number = run_number\n\n    # Create a new Pandas DataFrame that will store some results\n    # against the patient ID (which we'll use as the index).\n    self.results_df = pd.DataFrame()\n    self.results_df[\"Patient ID\"] = [1]\n    self.results_df[\"Queue Time Cubicle\"] = [0.0]\n    self.results_df[\"Time with Nurse\"] = [0.0]\n    self.results_df.set_index(\"Patient ID\", inplace=True)\n\n    # Create an attribute to store the mean queuing times\n    # across this run of the model\n    self.mean_q_time_cubicle = 0\n\n    self.patient_inter_arrival_dist = Exponential(\n        mean = g.arrival_rate,\n        random_seed = self.run_number*g.random_number_set\n        )\n\n    self.treat_dist = Lognormal(\n        mean = g.trauma_treat_mean,\n        stdev = g.trauma_treat_var,\n        random_seed = self.run_number*g.random_number_set\n        )\n\n\n\n\n\n\nWith Vidigi Modifications\n\ndef __init__(self, run_number):\n    # Create a SimPy environment in which everything will live\n    self.env = simpy.Environment()\n\n    # Store the passed in run number\n    self.run_number = run_number\n\n    # By passing in the env we've created, the logger will default to the simulation  \n    # time when populating the time column of our event logs  \n    # Passing the run number also ensures we can separate out different runs  \n    # of the simulation in our later calculations \n    self.logger = EventLogger( \n        env=self.env,  \n        run_number=self.run_number \n        ) \n\n    # Create a patient counter (which we'll use as a patient ID)\n    self.patient_counter = 0\n\n    # Create an empty list to store patient objects in\n    self.patients = []\n\n    # Create our resources\n    self.init_resources()\n\n    self.patient_inter_arrival_dist = Exponential(\n        mean = g.arrival_rate,\n        random_seed = self.run_number*g.random_number_set\n        )\n\n    self.treat_dist = Lognormal(\n        mean = g.trauma_treat_mean,\n        stdev = g.trauma_treat_var,\n        random_seed = self.run_number*g.random_number_set\n        )\n\n\n\n\n\n\nthe init_resources method\nVidigi needs to know which resource a user made use of so that we can ensure it stays with the correct resource throughout its time in the animation.\nThe standard simpy Resource does not have a way of tracking that, so we need to use a special store type provided by Vidigi that allows us to track resource IDs - without having to change our code as much as we would with a standard Simpy store.\nIf you are using priority resources, this step will be a little different - see Example 3 in the documents if you need to use Resources that prioritise some entities over others.\n\n\n\nOriginal\n\ndef init_resources(self):\n    self.treatment_cubicles = simpy.Resource(\n        self.env,\n        capacity=g.n_cubicles\n        )\n\n\n\n\n\n\nWith Vidigi Modifications\n\ndef init_resources(self):\n    self.treatment_cubicles = VidigiStore( \n        self.env, \n        num_resources=g.n_cubicles \n        ) \n\n\n\n\n\n\nthe generator_patient_arrivals method\nThis method is unchanged.\n\n\nthe attend_clinic method\nThis is the key place in which we add our logging. The logs are what vidigi relies on to calculate who should be where, when, within the animation.\nThis is also where we need to slightly change the way we request resources to allow us to access their ID attribute.\nWhere we would have previously used\n\nwith self.treatment_cubicles.request() as req:\n    # Seize a treatment resource when available\n    yield req\n\n    # ALL CODE WHERE WE NEED TO KEEP HOLD OF THE RESOURCE\n\n# CONTINUE AFTER RELEASING RESOURCE HERE\n\nwe instead now use\n\nwith self.treatment_cubicles.request() as req:\n    # Seize a treatment resource when available\n    treatment_cubicle = yield req\n\n    # ALL CODE WHERE WE NEED TO KEEP HOLD OF THE RESOURCE\n\n# CONTINUE AFTER RELEASING RESOURCE HERE\n\n\n\n\nOriginal\n\ndef attend_clinic(self, patient):\n    patient.arrival = self.env.now\n\n    # request examination resource\n    start_wait = self.env.now\n\n    with self.treatment_cubicles.request() as req:\n        # Seize a treatment resource when available\n        yield req\n\n        # record the waiting time for registration\n        patient.wait_treat = self.env.now - start_wait\n\n        # sample treatment duration\n        patient.treat_duration = self.treat_dist.sample()\n        yield self.env.timeout(patient.treat_duration)\n\n    # total time in system\n    patient.total_time = self.env.now - patient.arrival\n\n\n\n\n\n\nWith Vidigi Modifications\n\ndef attend_clinic(self, patient):\n    patient.arrival = self.env.now\n\n    # First, we log when the patient arrives  \n    # The time will automatically be recorded as the current\n    # simulation time\n    self.logger.log_arrival( \n            entity_id=patient.identifier \n            ) \n\n    # request examination resource\n    start_wait = self.env.now\n\n    self.logger.log_queue(  \n        entity_id=patient.identifier,  \n        event=\"treatment_wait_begins\"  \n        )  \n\n    # Seize a treatment resource when available\n    with self.treatment_cubicles.request() as req:\n        treatment_cubicle = yield req    \n\n        # record the waiting time for registration\n        patient.wait_treat = self.env.now - start_wait\n\n        self.logger.log_resource_use_start(  \n                entity_id=patient.identifier,  \n                event=\"treatment_begins\",  \n                resource_id=treatment_cubicle.id_attribute  \n                )  \n\n        # sample treatment duration\n        patient.treat_duration = self.treat_dist.sample()\n        yield self.env.timeout(patient.treat_duration)\n\n        self.logger.log_resource_use_end(  \n            entity_id=patient.identifier,  \n            event=\"treatment_complete\",  \n            resource_id=treatment_cubicle.id_attribute  \n            )  \n\n    # total time in system\n    patient.total_time = self.env.now - patient.arrival\n\n    # Finally, we record when the entity leaves the system  \n    self.logger.log_departure(  \n        entity_id=patient.identifier  \n        )  \n\n\n\n\n\n\nthe calculate_run_results method\nWe can remove this method entirely from our new code - we can use the event log and vidigi helper functions to calculate all this information outside of the model, keeping our model code focussed on the modelling.\n\n\nthe run method\nIn this method, we can remove the code that runs the .calculate_run_results() method.\n\n\n\nOriginal\n\ndef run(self):\n    # Start up our DES entity generators that create new patients.  We've\n    # only got one in this model, but we'd need to do this for each one if\n    # we had multiple generators.\n    self.env.process(self.generator_patient_arrivals())\n\n    # Run the model for the duration specified in g class\n    self.env.run(until=g.sim_duration)\n\n    # Now the simulation run has finished, call the method that calculates\n    # run results\n    self.calculate_run_results()\n\n\n\n\n\n\nWith Vidigi Modifications\n\ndef run(self):\n    # Start up our DES entity generators that create new patients.  We've\n    # only got one in this model, but we'd need to do this for each one if\n    # we had multiple generators.\n    self.env.process(self.generator_patient_arrivals())\n\n    # Run the model for the duration specified in g class\n    self.env.run(until=g.sim_duration)\n\n\n\n\n\n\n\nthe Trial Class\nIn our trial class, we will no longer have any code relating to calculating the averages - we can do this all later from our event logs.\nInstead, we will create some useful attributes that will be populated by run_trial(), and also set run_trial() to be automatically executed (though this is optional).\n\nthe init method\n\n\n\nOriginal\n\ndef  __init__(self):\n    self.df_trial_results = pd.DataFrame()\n    self.df_trial_results[\"Run Number\"] = [0]\n    self.df_trial_results[\"Arrivals\"] = [0]\n    self.df_trial_results[\"Mean Queue Time Cubicle\"] = [0.0]\n    self.df_trial_results.set_index(\"Run Number\", inplace=True)\n\n\n\n\n\n\nWith Vidigi Modifications\n\ndef  __init__(self):\n        self.all_event_logs = [] \n        self.df_trial_results = pd.DataFrame() \n\n        self.run_trial() \n\n\n\n\n\n\nthe run_trial method\n\n\n\nOriginal\n\ndef run_trial(self):\n    for run in range(1, g.number_of_runs+1):\n        random.seed(run)\n\n        my_model = Model(run)\n        my_model.run()\n\n        self.df_trial_results.loc[run] = [\n            my_model.mean_q_time_cubicle\n        ]\n\n    return self.df_trial_results\n\n\n\n\n\n\nWith Vidigi Modifications\n\ndef run_trial(self):\n    for run in range(1, g.number_of_runs+1):\n        random.seed(run)\n\n        my_model = Model(run)\n        my_model.run()\n\n        # For each run, we append the logger object (which is of class EventLogger)  \n        # to our list all_event_logs, which started out empty  \n        self.all_event_logs.append(my_model.logger) \n\n    # At the end, we create one large pandas dataframe of the results from every run\n    self.df_trial_results = pd.concat(  \n        [run_results.to_dataframe() for run_results in self.all_event_logs]  \n        )",
    "crumbs": [
      "Walkthroughs",
      "Adding Vidigi to a Simple simpy Model (HSMA Structure) - vidigi 0.0.5 and above"
    ]
  },
  {
    "objectID": "vidigi_docs/adding_vidigi_to_a_simple_simpy_model_hsma_structure.html#using-vidigi-to-create-an-animation-from-our-event-log",
    "href": "vidigi_docs/adding_vidigi_to_a_simple_simpy_model_hsma_structure.html#using-vidigi-to-create-an-animation-from-our-event-log",
    "title": "Adding Vidigi to a Simple simpy Model (HSMA Structure) - vidigi 0.0.5 and above",
    "section": "Using vidigi to create an animation from our event log",
    "text": "Using vidigi to create an animation from our event log\nFor simple animations with vidigi, it is recommended that you use the animate_activity_log function.\nThis all-in-one function takes an event log of the structure discussed above, then turns it into an animated output that can be embedded in a quarto document, a web app, or saved as a standalone HTML file.\nFirst, we need to create an instance of our trial class, then run the trial.\n\nmy_trial = Trial()\n\nmy_trial.run_trial()\n\nThe dataframe of event logs can then be viewed using my_trial.df_trial_results\n\nThe event_position_df\nWe can then generate our coordinates for the initial positioning of each step.\n\n\n\n\n\n\nNote\n\n\n\nThe ‘event’ names must match the event names you assigned in the logging steps.\nHowever, this will not be displayed anywhere in the final setup. Instead, use ‘label’ to define a human-readable label that can optionally be displayed in the final animation.\n\n\n\n\n\n\n\n\nWarning\n\n\n\n‘label’ should not be left out or be an empty string - both of these will cause problems.\n\n\n\n\n\n\n\n\nNote\n\n\n\nYou only need to provide positions for\n\narrival\ndeparture\nqueue\nresource_use (optional - you can have an animation that is only queues)\n\ni.e. you do not need to provide coordinates for resource_use_end\nYou can also opt to skip any queue or resource_use steps you do not want to show, though note that this could produce a misleading output if not carefully explained to end users\n\n\n\n\n\n\n\n\nTip\n\n\n\nFor queues and resource use, the coordinate will correspond to the bottom-right-hand corner of the block of queueing entities or resources.\n\n\n\nevent_position_df = pd.DataFrame([\n                    {'event': 'arrival',\n                     'x':  50, 'y': 300,\n                     'label': \"Arrival\" },\n\n                    # Triage - minor and trauma\n                    {'event': 'treatment_wait_begins',\n                     'x':  205, 'y': 275,\n                     'label': \"Waiting for Treatment\"},\n\n                    {'event': 'treatment_begins',\n                     'x':  205, 'y': 175,\n                     'resource':'n_cubicles',\n                     'label': \"Being Treated\"},\n\n                    {'event': 'depart',\n                     'x':  270, 'y': 70,\n                     'label': \"Exit\"}\n\n                ])",
    "crumbs": [
      "Walkthroughs",
      "Adding Vidigi to a Simple simpy Model (HSMA Structure) - vidigi 0.0.5 and above"
    ]
  },
  {
    "objectID": "vidigi_docs/adding_vidigi_to_a_simple_simpy_model_hsma_structure.html#creating-the-animation",
    "href": "vidigi_docs/adding_vidigi_to_a_simple_simpy_model_hsma_structure.html#creating-the-animation",
    "title": "Adding Vidigi to a Simple simpy Model (HSMA Structure) - vidigi 0.0.5 and above",
    "section": "Creating the animation",
    "text": "Creating the animation\nFinally, we can create the animation.\n\n\n\n\n\n\nWarning\n\n\n\nIt is important that you only pass in a single run at a time!\nPassing a dataframe in containing more than one run will produce incorrect animations.\nYou may, however, wish to give the user control over which run they visualise using a dropdown in something like Streamlit or Shiny - or perhaps\n\n\n\nsingle_run_event_log_df = my_trial.df_trial_results[my_trial.df_trial_results['run_number']==1]\n\nanimate_activity_log(\n        event_log=single_run_event_log_df,\n        event_position_df= event_position_df,\n        scenario=g(), # Use an instance of the g class as our scenario\n        limit_duration=g.sim_duration,\n        debug_mode=True, # Turn on logging messages\n        setup_mode=True, # Turn on axis units - this can help with honing your event_position_df\n        every_x_time_units=1,\n        include_play_button=True,\n        entity_icon_size=20,\n        resource_icon_size=20,\n        gap_between_entities=6,\n        gap_between_entity_rows=25,\n        plotly_height=700,\n        frame_duration=200,\n        plotly_width=1200,\n        override_x_max=300,\n        override_y_max=500,\n        wrap_queues_at=25,\n        step_snapshot_max=125,\n        time_display_units=\"dhm\",\n        display_stage_labels=True # display our Label column from our event_position_df\n    )\n\n\n\n\n\n\n\nClick here to view the full code\n\n\n\n\n\n\nimport random\nimport numpy as np\nimport pandas as pd\nimport simpy\nfrom sim_tools.distributions import Exponential, Lognormal\nfrom vidigi.resources import VidigiStore \nfrom vidigi.logging import EventLogger \nfrom vidigi.animation import animate_activity_log \n\n# Class to store global parameter values.  We don't create an instance of this\n# class - we just refer to the class blueprint itself to access the numbers\n# inside.\nclass g:\n    '''\n    Create a scenario to parameterise the simulation model\n\n    Parameters:\n    -----------\n    random_number_set: int, optional (default=DEFAULT_RNG_SET)\n        Set to control the initial seeds of each stream of pseudo\n        random numbers used in the model.\n\n    n_cubicles: int\n        The number of treatment cubicles\n\n    trauma_treat_mean: float\n        Mean of the trauma cubicle treatment distribution (Lognormal)\n\n    trauma_treat_var: float\n        Variance of the trauma cubicle treatment distribution (Lognormal)\n\n    arrival_rate: float\n        Set the mean of the exponential distribution that is used to sample the\n        inter-arrival time of patients\n\n    sim_duration: int\n        The number of time units the simulation will run for\n\n    number_of_runs: int\n        The number of times the simulation will be run with different random number streams\n\n    '''\n    random_number_set = 42\n\n    n_cubicles = 3\n    trauma_treat_mean = 40\n    trauma_treat_var = 5\n\n    arrival_rate = 5\n\n    sim_duration = 600\n    number_of_runs = 100\n\n# Class representing patients coming in to the clinic.\nclass Patient:\n    '''\n    Class defining details for a patient entity\n    '''\n    def __init__(self, p_id):\n        '''\n        Constructor method\n\n        Params:\n        -----\n        identifier: int\n            a numeric identifier for the patient.\n        '''\n        self.identifier = p_id\n        self.arrival = -np.inf\n        self.wait_treat = -np.inf\n        self.total_time = -np.inf\n        self.treat_duration = -np.inf\n\n# Class representing our model of the clinic.\nclass Model:\n    '''\n    Simulates the simplest minor treatment process for a patient\n\n    1. Arrive\n    2. Examined/treated by nurse when one available\n    3. Discharged\n    '''\n    # Constructor to set up the model for a run.  We pass in a run number when\n    # we create a new model.\n    def __init__(self, run_number):\n        # Create a SimPy environment in which everything will live\n        self.env = simpy.Environment()\n\n        # Store the passed in run number\n        self.run_number = run_number\n\n        # By passing in the env we've created, the logger will default to the simulation  \n        # time when populating the time column of our event logs  \n        # Passing the run number also ensures we can separate out different runs  \n        # of the simulation in our later calculations \n        self.logger = EventLogger( \n            env=self.env,  \n            run_number=self.run_number \n            ) \n\n        # Create a patient counter (which we'll use as a patient ID)\n        self.patient_counter = 0\n\n        # Create an empty list to store patient objects in\n        self.patients = []\n\n        # Create our resources\n        self.init_resources()\n\n        self.patient_inter_arrival_dist = Exponential(\n            mean = g.arrival_rate,\n            random_seed = self.run_number*g.random_number_set\n            )\n\n        self.treat_dist = Lognormal(\n            mean = g.trauma_treat_mean,\n            stdev = g.trauma_treat_var,\n            random_seed = self.run_number*g.random_number_set\n            )\n\n    def init_resources(self):\n        '''\n        Init the number of resources\n        and store in the arguments container object\n\n        Resource list:\n            1. Nurses/treatment bays (same thing in this model)\n\n        '''\n        self.treatment_cubicles = simpy.Store(self.env)\n\n        self.treatment_cubicles = VidigiStore( \n                self.env, \n                num_resources=g.n_cubicles \n                ) \n\n    # A generator function that represents the DES generator for patient\n    # arrivals\n    def generator_patient_arrivals(self):\n        # We use an infinite loop here to keep doing this indefinitely whilst\n        # the simulation runs\n        while True:\n            # Increment the patient counter by 1 (this means our first patient\n            # will have an ID of 1)\n            self.patient_counter += 1\n\n            # Create a new patient - an instance of the Patient Class we\n            # defined above.  Remember, we pass in the ID when creating a\n            # patient - so here we pass the patient counter to use as the ID.\n            p = Patient(self.patient_counter)\n\n            # Store patient in list for later easy access\n            self.patients.append(p)\n\n            # Tell SimPy to start up the attend_clinic generator function with\n            # this patient (the generator function that will model the\n            # patient's journey through the system)\n            self.env.process(self.attend_clinic(p))\n\n            # Randomly sample the time to the next patient arriving.  Here, we\n            # sample from an exponential distribution (common for inter-arrival\n            # times), and pass in a lambda value of 1 / mean.  The mean\n            # inter-arrival time is stored in the g class.\n            sampled_inter = self.patient_inter_arrival_dist.sample()\n\n            # Freeze this instance of this function in place until the\n            # inter-arrival time we sampled above has elapsed.  Note - time in\n            # SimPy progresses in \"Time Units\", which can represent anything\n            # you like (just make sure you're consistent within the model)\n            yield self.env.timeout(sampled_inter)\n\n    # A generator function that represents the pathway for a patient going\n    # through the clinic.\n    # The patient object is passed in to the generator function so we can\n    # extract information from / record information to it\n    def attend_clinic(self, patient):\n        patient.arrival = self.env.now\n\n        # First, we log when the patient arrives  \n        # The time will automatically be recorded as the current\n        # simulation time\n        self.logger.log_arrival( \n                entity_id=patient.identifier \n                ) \n\n        # request examination resource\n        start_wait = self.env.now\n\n        self.logger.log_queue(  \n            entity_id=patient.identifier,  \n            event=\"treatment_wait_begins\"  \n            )  \n\n        # Seize a treatment resource when available\n        with self.treatment_cubicles.request() as req:\n            treatment_cubicle = yield req    \n\n            # record the waiting time for registration\n            patient.wait_treat = self.env.now - start_wait\n\n            self.logger.log_resource_use_start(  \n                    entity_id=patient.identifier,  \n                    event=\"treatment_begins\",  \n                    resource_id=treatment_cubicle.id_attribute  \n                    )  \n\n            # sample treatment duration\n            patient.treat_duration = self.treat_dist.sample()\n            yield self.env.timeout(patient.treat_duration)\n\n            self.logger.log_resource_use_end(  \n                entity_id=patient.identifier,  \n                event=\"treatment_complete\",  \n                resource_id=treatment_cubicle.id_attribute  \n                )  \n\n        # total time in system\n        patient.total_time = self.env.now - patient.arrival\n\n        # Finally, we record when the entity leaves the system  \n        self.logger.log_departure(  \n            entity_id=patient.identifier  \n            )  \n\n    # The run method starts up the DES entity generators, runs the simulation,\n    # and in turns calls anything we need to generate results for the run\n    def run(self):\n        # Start up our DES entity generators that create new patients.  We've\n        # only got one in this model, but we'd need to do this for each one if\n        # we had multiple generators.\n        self.env.process(self.generator_patient_arrivals())\n\n        # Run the model for the duration specified in g class\n        self.env.run(until=g.sim_duration)\n\n# Class representing a Trial for our simulation - a batch of simulation runs.\nclass Trial:\n    # The constructor sets up a pandas dataframe that will store the key\n    # results from each run against run number, with run number as the index.\n    def  __init__(self):\n        self.all_event_logs = [] \n        self.df_trial_results = pd.DataFrame() \n\n        self.run_trial() \n\n    # Method to run a trial\n    def run_trial(self):\n        for run in range(1, g.number_of_runs+1):\n            random.seed(run)\n\n            my_model = Model(run)\n            my_model.run()\n\n            # For each run, we append the logger object (which is of class EventLogger)  \n            # to our list all_event_logs, which started out empty  \n            self.all_event_logs.append(my_model.logger) \n\n        # At the end, we create one large pandas dataframe of the results from every run\n        self.df_trial_results = pd.concat(  \n            [run_results.to_dataframe() for run_results in self.all_event_logs]  \n            )  \n\n\n\n\n\nmy_trial = Trial()\n\nmy_trial.run_trial()\n\n\nmy_trial.df_trial_results.head(10)\n\n\n\n\n\n\n\n\nentity_id\nevent_type\nevent\ntime\npathway\nrun_number\ntimestamp\nresource_id\n\n\n\n\n0\n1\narrival_departure\narrival\n0.000000\nNone\n1\nNone\nNaN\n\n\n1\n1\nqueue\ntreatment_wait_begins\n0.000000\nNone\n1\nNone\nNaN\n\n\n2\n1\nresource_use\ntreatment_begins\n0.000000\nNone\n1\nNone\n1.0\n\n\n3\n2\narrival_departure\narrival\n12.021043\nNone\n1\nNone\nNaN\n\n\n4\n2\nqueue\ntreatment_wait_begins\n12.021043\nNone\n1\nNone\nNaN\n\n\n5\n2\nresource_use\ntreatment_begins\n12.021043\nNone\n1\nNone\n2.0\n\n\n6\n3\narrival_departure\narrival\n23.701991\nNone\n1\nNone\nNaN\n\n\n7\n3\nqueue\ntreatment_wait_begins\n23.701991\nNone\n1\nNone\nNaN\n\n\n8\n3\nresource_use\ntreatment_begins\n23.701991\nNone\n1\nNone\n3.0\n\n\n9\n4\narrival_departure\narrival\n35.625796\nNone\n1\nNone\nNaN\n\n\n\n\n\n\n\n\nsingle_run_event_log_df = my_trial.df_trial_results[my_trial.df_trial_results['run_number']==1]\n\nanimate_activity_log(\n        event_log=single_run_event_log_df,\n        event_position_df= event_position_df,\n        scenario=g(), # Use an instance of the g class as our scenario\n        limit_duration=g.sim_duration,\n        debug_mode=True, # Turn on logging messages\n        setup_mode=True, # Turn on axis units - this can help with honing your event_position_df\n        every_x_time_units=1,\n        include_play_button=True,\n        entity_icon_size=20,\n        resource_icon_size=20,\n        gap_between_entities=6,\n        gap_between_queue_rows=25,\n        plotly_height=700,\n        frame_duration=200,\n        plotly_width=1200,\n        override_x_max=300,\n        override_y_max=500,\n        wrap_queues_at=25,\n        step_snapshot_max=125,\n        time_display_units=\"dhm\",\n        display_stage_labels=True # display our Label column from our event_position_df\n    )\n\nAnimation function called at 17:20:35\nIteration through time-unit-by-time-unit logs complete 17:20:37\nSnapshot df concatenation complete at 17:20:38\nReshaped animation dataframe finished construction at 17:20:38\nPlacement dataframe finished construction at 17:20:38\nOutput animation generation complete at 17:20:40\nTotal Time Elapsed: 5.92 seconds\n\n\n        \n        \n        \n\n\n                                                    \n\n\nWhen you have finished tweaking the layout, you can further enhance your output.\n\nanimate_activity_log(\n        event_log=single_run_event_log_df,\n        event_position_df= event_position_df,\n        scenario=g(),\n        limit_duration=g.sim_duration,\n        debug_mode=False, # Turn off logging messages\n        setup_mode=False, # Turn off axis units\n        every_x_time_units=1,\n        include_play_button=True,\n        entity_icon_size=20,\n        resource_icon_size=20,\n        gap_between_entities=6,\n        gap_between_queue_rows=25,\n        plotly_height=700,\n        frame_duration=200,\n        plotly_width=1200,\n        override_x_max=300,\n        override_y_max=500,\n        wrap_queues_at=25,\n        step_snapshot_max=125,\n        time_display_units=\"dhm\",\n        display_stage_labels=False, # hide our Label column from our event_position_df\n        # Add a local or web-hosted image as our background\n        add_background_image=\"https://raw.githubusercontent.com/Bergam0t/vidigi/refs/heads/main/examples/example_1_simplest_case/Simplest%20Model%20Background%20Image%20-%20Horizontal%20Layout.drawio.png\")\n\n                                                    \n\n\nWe can then rerun our animation, passing in different parameters - though make sure to rerun your trial if you do so!\nHere, we will increase the number of cubicles from 3 to 7 and see the impact this has on the queue size.\n\ng.n_cubicles = 7 \n\nmy_trial = Trial()\n\nmy_trial.run_trial()\n\nsingle_run_event_log_df = my_trial.df_trial_results[my_trial.df_trial_results['run_number']==1]\n\nanimate_activity_log(\n        event_log=single_run_event_log_df,\n        event_position_df= event_position_df,\n        scenario=g(),\n        limit_duration=g.sim_duration,\n        debug_mode=False, # Turn off logging messages\n        setup_mode=False, # Turn off axis units\n        every_x_time_units=1,\n        include_play_button=True,\n        entity_icon_size=20,\n        resource_icon_size=20,\n        gap_between_entities=6,\n        gap_between_queue_rows=25,\n        plotly_height=700,\n        frame_duration=200,\n        plotly_width=1200,\n        override_x_max=300,\n        override_y_max=500,\n        wrap_queues_at=25,\n        step_snapshot_max=125,\n        time_display_units=\"dhm\",\n        display_stage_labels=False, # hide our Label column from our event_position_df\n        # Add a local or web-hosted image as our background\n        add_background_image=\"https://raw.githubusercontent.com/Bergam0t/vidigi/refs/heads/main/examples/example_1_simplest_case/Simplest%20Model%20Background%20Image%20-%20Horizontal%20Layout.drawio.png\")",
    "crumbs": [
      "Walkthroughs",
      "Adding Vidigi to a Simple simpy Model (HSMA Structure) - vidigi 0.0.5 and above"
    ]
  },
  {
    "objectID": "vidigi_docs/index.html",
    "href": "vidigi_docs/index.html",
    "title": "vidigi (Visual Interactive Dynamics and Integrated Graphical Insights)",
    "section": "",
    "text": "Welcome to vidigi - a package for visualising real or simulated pathways.\n\nPrimarily developed for healthcare simulation and intended to allow easy integration with tools like Streamlit so users can see the impact of changes to simulation parameters in real-time, vidigi handles the conversion of your simulation event logs into engaging and flexible animations.\nWith just a minimal set of logs - with helper functions provided to make that easier than ever to integrate into existing SimPy or Ciw simulations - you can start generating and customising your visualisations in minutes.\n\n\n\n\n\nSpotted a bug? Or just have a new feature you’d like adding? Raise an issue here\nVidigi is released under the MIT licence.\nThe source code is available on GitHub: github.com/Bergam0t/vidigi.\n\n\n\nvidigi is the Esperanto  for ‘to show’\n(or it’s the backronym ‘Visual Interactive Dynamics and Integrated Graphical Insights’ - whichever floats your boat)",
    "crumbs": [
      "Welcome"
    ]
  },
  {
    "objectID": "vidigi_docs/index.html#useful-links",
    "href": "vidigi_docs/index.html#useful-links",
    "title": "vidigi (Visual Interactive Dynamics and Integrated Graphical Insights)",
    "section": "",
    "text": "Spotted a bug? Or just have a new feature you’d like adding? Raise an issue here\nVidigi is released under the MIT licence.\nThe source code is available on GitHub: github.com/Bergam0t/vidigi.",
    "crumbs": [
      "Welcome"
    ]
  },
  {
    "objectID": "vidigi_docs/index.html#what-does-the-name-mean",
    "href": "vidigi_docs/index.html#what-does-the-name-mean",
    "title": "vidigi (Visual Interactive Dynamics and Integrated Graphical Insights)",
    "section": "",
    "text": "vidigi is the Esperanto  for ‘to show’\n(or it’s the backronym ‘Visual Interactive Dynamics and Integrated Graphical Insights’ - whichever floats your boat)",
    "crumbs": [
      "Welcome"
    ]
  },
  {
    "objectID": "vidigi_docs/populating_event_logs.html",
    "href": "vidigi_docs/populating_event_logs.html",
    "title": "Populating Event Logs",
    "section": "",
    "text": "Four event types are supported in the model:\n\n‘arrival_departure’\n‘resource_use’\n‘resource_use_end’\n‘queue’.\n\nAs a minimum, you will require the use of ‘arrival_departure’ events and one of\n\n‘resource_use’ / ‘resource_use_end’\nOR ‘queue’\n\nYou can also use both ‘resource_use’ and ‘queue’ within the same model very effectively (see ex_1_simplest_case and ex_2_branching_and_optional_paths, among others).\n\n\nWithin this, two ‘arrival_departure’ events per entity are mandatory - arrival and depart, both with an event_type of arrival_departure, as shown below.\n\n\n\n\n\n\n\n\nImportant\n\n\n\nArrivals must use\n‘event_type’: ‘arrival_departure’\n‘event’: ‘arrival’\n\n\n\nevent_log.append(\n      {'patient': unique_entity_identifier,\n      'pathway': 'Revision',\n      'event_type': 'arrival_departure',\n      'event': 'arrival',\n      'time': env.now}\n  )\n\n\n\n\n\n\n\n\n\n\nImportant\n\n\n\nDepartures must use\n‘event_type’: ‘arrival_departure’\n‘event’: ‘depart’\n\n\n\nevent_log.append(\n      {'patient': unique_entity_identifier,\n      'pathway': 'Revision',\n      'event_type': 'arrival_departure',\n      'event': 'depart',\n      'time': env.now}\n  )\n\n\n\n\n\n\n\nWarning\n\n\n\nThese are critical as they are used to determine when patients should first and last appear in the model.\n\n\n\n\n\n\n\n\nImportant\n\n\n\nForgetting to include a departure step for all types of patients can lead to slow model and animation performance as the size of the event logs for individual moments will continue to increase indefinitely.\n\n\n\n\n\n\nQueues are key steps in the model.\nIt is possible to solely use queues and never make use of a simpy resource.\nBy tracking each important step in the process as a ‘queue’ step, the movement of patients can be accurately tracked.\nPatients will be ordered by the point at which they are added to the queue, with the first entries appearing at the front (bottom-right) of the queue.\nRecord the time the entity begins queueing for a resource with an event_type of ‘queue’.\nYou may use whatever string you wish to for the event name.\n\nevent_log.append(\n            {'patient': unique_entity_identifier,\n             'pathway': 'High intensity',\n             'event_type': 'queue',\n             'event': 'appointment_booked_waiting',\n             'time': self.env.now\n             }\n        )\n\nWhile the keys shown above are mandatory, you can add as many additional keys to a step’s log as desired. This can allow you to flexibly make use of the event log for other purposes as well as the animation.\n\n\n\nResource use is more complex to include but comes with two key benefits over the queue: - it becomes easier to monitor the length of time a resource is in use by a single entity as users won’t ‘move through’ the resource use stage (which can also prove confusing to less experienced viewers) - it becomes possible to show the total number of resources that are available, making it easier to understand how well resources are being utilised at different stages\nIn addition to the other fields, this also requires you to pass a resource_id argument. If you have set up your simpy store using the populate_store function from the utils module of the vidigi package, then your resources will have an ID attribute you can access in the way shown below after you have requested the resource with .get()\nRecord the time the resource begins use with an event_type of ‘resource_use’.\nYou may use whatever string you wish to for the event name.\n\n# request the resource\nmy_resource = yield my_resource_store.get()\n\nevent_log.append( \n    {'patient': unique_entity_identifier, \n     'pathway': 'My Pathway Name', \n     'event_type': 'resource_use', \n     'event': 'triage_begins', \n     'time': env.now, \n     'resource_id': triage_resource.id_attribute \n    } \n) \n\nWhen the resource is no longer in use, record the time with an event_type of ‘resource_use_end’.\nAgain, you may use whatever string you wish to for the event name.\nOnce again, you must record the ID of the resource that is being freed up.\nYou can do this before or after putting the resource back in the store.\n\nevent_log.append( \n            {'patient': unique_entity_identifier, \n             'pathway': 'My Pathway Name', \n             'event_type': 'resource_use_end', \n             'event': 'triage_complete', \n             'time': env.now, \n             'resource_id': triage_resource.id_attribute} \n        ) \n\n# Resource is no longer in use, so put it back in the store\nmy_resource_store.put(my_resource)",
    "crumbs": [
      "Details",
      "Populating Event Logs"
    ]
  },
  {
    "objectID": "vidigi_docs/populating_event_logs.html#event-types",
    "href": "vidigi_docs/populating_event_logs.html#event-types",
    "title": "Populating Event Logs",
    "section": "",
    "text": "Four event types are supported in the model:\n\n‘arrival_departure’\n‘resource_use’\n‘resource_use_end’\n‘queue’.\n\nAs a minimum, you will require the use of ‘arrival_departure’ events and one of\n\n‘resource_use’ / ‘resource_use_end’\nOR ‘queue’\n\nYou can also use both ‘resource_use’ and ‘queue’ within the same model very effectively (see ex_1_simplest_case and ex_2_branching_and_optional_paths, among others).\n\n\nWithin this, two ‘arrival_departure’ events per entity are mandatory - arrival and depart, both with an event_type of arrival_departure, as shown below.\n\n\n\n\n\n\n\n\nImportant\n\n\n\nArrivals must use\n‘event_type’: ‘arrival_departure’\n‘event’: ‘arrival’\n\n\n\nevent_log.append(\n      {'patient': unique_entity_identifier,\n      'pathway': 'Revision',\n      'event_type': 'arrival_departure',\n      'event': 'arrival',\n      'time': env.now}\n  )\n\n\n\n\n\n\n\n\n\n\nImportant\n\n\n\nDepartures must use\n‘event_type’: ‘arrival_departure’\n‘event’: ‘depart’\n\n\n\nevent_log.append(\n      {'patient': unique_entity_identifier,\n      'pathway': 'Revision',\n      'event_type': 'arrival_departure',\n      'event': 'depart',\n      'time': env.now}\n  )\n\n\n\n\n\n\n\nWarning\n\n\n\nThese are critical as they are used to determine when patients should first and last appear in the model.\n\n\n\n\n\n\n\n\nImportant\n\n\n\nForgetting to include a departure step for all types of patients can lead to slow model and animation performance as the size of the event logs for individual moments will continue to increase indefinitely.\n\n\n\n\n\n\nQueues are key steps in the model.\nIt is possible to solely use queues and never make use of a simpy resource.\nBy tracking each important step in the process as a ‘queue’ step, the movement of patients can be accurately tracked.\nPatients will be ordered by the point at which they are added to the queue, with the first entries appearing at the front (bottom-right) of the queue.\nRecord the time the entity begins queueing for a resource with an event_type of ‘queue’.\nYou may use whatever string you wish to for the event name.\n\nevent_log.append(\n            {'patient': unique_entity_identifier,\n             'pathway': 'High intensity',\n             'event_type': 'queue',\n             'event': 'appointment_booked_waiting',\n             'time': self.env.now\n             }\n        )\n\nWhile the keys shown above are mandatory, you can add as many additional keys to a step’s log as desired. This can allow you to flexibly make use of the event log for other purposes as well as the animation.\n\n\n\nResource use is more complex to include but comes with two key benefits over the queue: - it becomes easier to monitor the length of time a resource is in use by a single entity as users won’t ‘move through’ the resource use stage (which can also prove confusing to less experienced viewers) - it becomes possible to show the total number of resources that are available, making it easier to understand how well resources are being utilised at different stages\nIn addition to the other fields, this also requires you to pass a resource_id argument. If you have set up your simpy store using the populate_store function from the utils module of the vidigi package, then your resources will have an ID attribute you can access in the way shown below after you have requested the resource with .get()\nRecord the time the resource begins use with an event_type of ‘resource_use’.\nYou may use whatever string you wish to for the event name.\n\n# request the resource\nmy_resource = yield my_resource_store.get()\n\nevent_log.append( \n    {'patient': unique_entity_identifier, \n     'pathway': 'My Pathway Name', \n     'event_type': 'resource_use', \n     'event': 'triage_begins', \n     'time': env.now, \n     'resource_id': triage_resource.id_attribute \n    } \n) \n\nWhen the resource is no longer in use, record the time with an event_type of ‘resource_use_end’.\nAgain, you may use whatever string you wish to for the event name.\nOnce again, you must record the ID of the resource that is being freed up.\nYou can do this before or after putting the resource back in the store.\n\nevent_log.append( \n            {'patient': unique_entity_identifier, \n             'pathway': 'My Pathway Name', \n             'event_type': 'resource_use_end', \n             'event': 'triage_complete', \n             'time': env.now, \n             'resource_id': triage_resource.id_attribute} \n        ) \n\n# Resource is no longer in use, so put it back in the store\nmy_resource_store.put(my_resource)",
    "crumbs": [
      "Details",
      "Populating Event Logs"
    ]
  }
]