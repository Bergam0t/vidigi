{
  "hash": "522d827a3b535fd34d33b20c65456a31",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: Populating Event Logs\nexecute:\n  eval: false\nformat:\n  html:\n    toc: true\n    toc-depth: 4\n    toc-expand: 4\nfilters:\n  - quarto\n  - line-highlight\n---\n\n## Event types\n\nFour **event types** are supported in the model:\n\n- 'arrival_departure'\n- 'resource_use'\n- 'resource_use_end'\n- 'queue'.\n\nAs a minimum, you will require the use of 'arrival_departure' events and one of\n\n- 'resource_use' / 'resource_use_end'\n- OR 'queue'\n\nYou can also use both 'resource_use' and 'queue' within the same model very effectively (see `ex_1_simplest_case` and `ex_2_branching_and_optional_paths`, among others).\n\n### arrival_departure\n\nWithin this, two 'arrival_departure' **events** per entity are mandatory - `arrival` and `depart`, both with an event_type of `arrival_departure`, as shown below.\n\n#### Arrivals\n\n:::{.callout-important}\nArrivals **must** use\n\n'event_type': 'arrival_departure'\n\n'event': 'arrival'\n\n:::\n\n::: {#7906f51f .cell execution_count=1}\n``` {.python .cell-code}\nevent_log.append(\n      {'patient': unique_entity_identifier,\n      'pathway': 'Revision',\n      'event_type': 'arrival_departure',\n      'event': 'arrival',\n      'time': env.now}\n  )\n```\n:::\n\n\n#### Departures\n\n:::{.callout-important}\nDepartures **must** use\n\n'event_type': 'arrival_departure'\n\n'event': 'depart'\n\n:::\n\n::: {#427cc9ed .cell execution_count=2}\n``` {.python .cell-code}\nevent_log.append(\n      {'patient': unique_entity_identifier,\n      'pathway': 'Revision',\n      'event_type': 'arrival_departure',\n      'event': 'depart',\n      'time': env.now}\n  )\n```\n:::\n\n\n:::{.callout-warning}\nThese are critical as they are used to determine when patients should first and last appear in the model.\n:::\n\n:::{.callout-important}\nForgetting to include a departure step for all types of patients can lead to slow model and animation performance as the size of the event logs for individual moments will continue to increase indefinitely.\n:::\n\n### queue\n\nQueues are key steps in the model.\n\nIt is possible to solely use queues and never make use of a simpy resource.\n\nBy tracking each important step in the process as a 'queue' step, the movement of patients can be accurately tracked.\n\nPatients will be ordered by the point at which they are added to the queue, with the first entries appearing at the front (bottom-right) of the queue.\n\nRecord the time the entity begins queueing for a resource with an event_type of 'queue'.\n\nYou may use whatever string you wish to for the `event` name.\n\n::: {#91817a58 .cell execution_count=3}\n``` {.python .cell-code}\nevent_log.append(\n            {'patient': unique_entity_identifier,\n             'pathway': 'High intensity',\n             'event_type': 'queue',\n             'event': 'appointment_booked_waiting',\n             'time': self.env.now\n             }\n        )\n```\n:::\n\n\nWhile the keys shown above are mandatory, you can add as many additional keys to a step's log as desired. This can allow you to flexibly make use of the event log for other purposes as well as the animation.\n\n### resource_use and resource_use_end\n\nResource use is more complex to include but comes with two key benefits over the queue:\n- it becomes easier to monitor the length of time a resource is in use by a single entity as users won't 'move through' the resource use stage (which can also prove confusing to less experienced viewers)\n- it becomes possible to show the total number of resources that are available, making it easier to understand how well resources are being utilised at different stages\n\nIn addition to the other fields, this also requires you to pass a `resource_id` argument. If you have set up your simpy store using the `populate_store` function from the `utils` module of the vidigi package, then your resources will have an ID attribute you can access in the way shown below after you have requested the resource with `.get()`\n\nRecord the time the resource begins use with an event_type of 'resource_use'.\n\nYou may use whatever string you wish to for the `event` name.\n\n::: {#54a4b4ba .cell execution_count=4}\n``` {.python .cell-code}\n# request the resource\nmy_resource = yield my_resource_store.get()\n\nevent_log.append( #<<\n    {'patient': unique_entity_identifier, #<<\n     'pathway': 'My Pathway Name', #<<\n     'event_type': 'resource_use', #<<\n     'event': 'triage_begins', #<<\n     'time': env.now, #<<\n     'resource_id': triage_resource.id_attribute #<<\n    } #<<\n) #<<\n```\n:::\n\n\nWhen the resource is no longer in use, record the time with an event_type of 'resource_use_end'.\n\nAgain, you may use whatever string you wish to for the `event` name.\n\nOnce again, you must record the ID of the resource that is being freed up.\n\nYou can do this before or after putting the resource back in the store.\n\n::: {#6d5c0dd5 .cell execution_count=5}\n``` {.python .cell-code}\nevent_log.append( #<<\n            {'patient': unique_entity_identifier, #<<\n             'pathway': 'My Pathway Name', #<<\n             'event_type': 'resource_use_end', #<<\n             'event': 'triage_complete', #<<\n             'time': env.now, #<<\n             'resource_id': triage_resource.id_attribute} #<<\n        ) #<<\n\n# Resource is no longer in use, so put it back in the store\nmy_resource_store.put(my_resource)\n```\n:::\n\n\n",
    "supporting": [
      "populating_event_logs_files"
    ],
    "filters": [],
    "includes": {}
  }
}